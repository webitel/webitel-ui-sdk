# Filters module
Відомі як "нові фільтри".

## Prerequisites
[Table Store Module](../table-store-module/Readme.md)

## Історіографія питання

### Для чого потрібні фільтри, і які до них вимоги?

Фільтри потрібні, вочевидь, щоб фільтувати масиви даних. Чому масиви? - Тому що коли ми 
дивимось на один ітем, в його карточці - він вже відфільтрований. У нашому випадку,
ми хочемо фільтрувати табличне представлення даних, відправляючи запити на сервер з урахуванням
вибраної користувачем фільтрації (або фільтрації за замовчуванням!).

**Отже, які ж вимоги?**

- **Значення фільтрів повинні зберігатися у роуті**, щоб можна було відновити стан фільтрації після
оновлення сторінки.

- **Фільтри мають бути реюзабельними**, щоб не писати їх кожен раз заново. Втім, це складна задача,
адже включає в себе реюзабельність як компонентів, так і роботи з роутером, так і агрегацію та трансформування
цих даних для відправки на сервер.

### Як працювали попередні фільтри?

[Детально, QueryFilters](../query-filters%20(old)/Readme.md)

### Query Controller Mixin
Є міксин, який керує router'ом. Все вертиться навколо нього (міксина, власне).

### Filter mixins
Є міксини фільтрів, в задачу яких входить відновлення стану фільтрації з роута, а також
set параметрів у store. Вони наслідують міксин роутера.

### Filter components
Є компоненти (селекти, наприклад), які використовують міксини фільтрів. Вони
використовують свої міксини, які є обгортками над двома попередніми, з відповідним
функціоналом: відновити дані, потягти дані з сервера, якщо це API-select.

Можна скористатись цим компонентом, а можна імпортувати міксини напряму - і написати свій кастомний
фільтр.

### Store
Є стор, у якому описуються схеми фільтрів, та в нього кладуться дані з компонентів - через міксини, знов таки.

Є набір класів фільтрів, які форсять дефолтну схему певного фільтра за його типом (дефолт, єнам, апі).

### Watcher у компоненті таблиці
Компонент таблиці watch'ить router.query, і, коли він змінився - викликає перезавантаженя
ліста.

### GET_FILTERS
У перезавантаженні ліста викликається метод, який агрегує значення фільтрів зі стор модуля, та надсилає їх.

Все це виглядає приблизно так:

*Hint: "Open image in new tab" for better view.*

![](old-schema.jpg)

Тут ми бачимо декілька "центрів тяжіння":
- З одного боку, це router controller mixin, який взаємодіє з router,
- А з іншого, це компонент таблиці, який "дивиться" на router і запускає перезавантаження даних.

### Які ж проблеми виникали?

### Суто архітектурна.
Як правило, стор має керувати апплікейшеном, містити в собі всю heavy
логіку. Тут же стор фільтрів є просто додатком, а основний контроль покладається на міксини.

### Кожен компонент містить в собі міксин, який самостійно керує роутером.
Через це, немає єдиної "точки входу" в роутер, а отже, важко підписатись на цю подію, чи зробити до неї якісь
централізовані хуки або міддлвару.

### Batch update
Через попередню причину, виникає проблема просто в тому, щоб оновити одночасно 2 параметри,
при цьому, не викликаючи перезавантаження даних на кожну зміну: наприклад, оновлюється один фільтр,
а нам після його оновлення треба скинути пейджу. Як? А ніяк: вотчером на роутер? - побіжить 2 запити.
А перехопити зміну фільтра і додати якусь додаткову логіку можливості немає.

### Неявна залежність між оновленням фільтрів та перезавантаженням даних.
Вотчер на роутер.квері можна
забути написати. Немає зручної можливості перебирати, що змінилось, і все таке. Більше того:
у нас проблеми з тим, щоб визначити джерело істиності фільтра: кверя роутера, яка є основним контролюючим елементом
схеми, або роутер - який концептуально мав би бути основним?

### Наше улюблене: міксин в міксині, в міксині. Ням-ням.

Отже, виходить, що старі фільтри виглядають доволі складними, неочевидними та заплутаними через
перевертання керуючих компонентів, а також через неможливість задовільнити вимогу скидати пейджу,
коли оновлюється фільтр.

## Як працюють нові фільтри?

Отже, через це постала потреба в нових фільтрах.

В нових фільтрах було перевернуто "головою до верху" підхід до керування логікою: тепер вона міститься
у сторі, і стор є основним джерелом як істини, так і керування всією логікою фільтрації.

Крім того, тепер кожен параметр запиту є фільтром: зокрема, пейджа та сайз.

### Store 
У нас є стор, основна ідея стора така:
- Реалізувати керування роутером.
- Зберігати, модифікувати, та повертати стан фільтрації (а отже, кожного фільтра).
- Нотифікувати сабскрайберів про зміни у фільтрах.

На відміну від підписки на роутер.квері тепер необхідно підписатися на подію зміни фільтра у сторі,
що дозволяє більш гнучко як модулю фільтрації нотифікувати сабскрайберів, так і сабскрайберам реагувати
на зміну фільтрації.

Необхідність робити batch update фільтрів (те, про що ми говорили вище: оновити фільтр + ресетнути пейджу)
реалізовано через можливість робити `silent` апдейти, які не триггерять сабскрайберів.

Оновлення даних тепер реалізується через передачу у фільтри неймспейсу тейбл модуля, через, власне,
піписку на оновлення фільтрів.

### Store state
Стор, у стейті, містить в собі набір фільтрів, які реалізують клас `(Base?)FilterSchema.js`.
В ньому можна описати схему даних, а також наконфігурувати логіку їх відновлення з роутера,
та ключ для зберігання у localStorage.

### Компоненти
Тут все просто: компонент вміє взаємодіяти зі стором на рівні `get`/`set`, але очікує
пропсом `namespace` фільтрів, як параметр.

### Composable
Для підключення фільтрів до компонента з таблицею.

Все це виглядає приблизно так:

*Hint: "Open image in new tab" for better view.*

![](new-schema.jpg)

Тут "центром тяжіння" є саме стор модуль, який керує фільтрами, взаємодіє з роутером, та нотифікує
таблицю про зміни.

## Які є проблеми в нових фільтрах?

### Хвіст, який виляє собакою

Головна проблема: перевернута логіка керування: не тейбл стор опціонально використовує фільтри,
а фільтри мають тейбл стор як залежність, та триггерять його. Це принципово неправильно, тому що
фільтр є додатком до таблиці, а не навпаки.

Звідти випливає неправильна логіка, де підписка на оновлення фільтрів відбувається одразу в середині
фільтр модуля, а не десь в умовному сабскрайбері.

### `Silent` оновлення фільтрів

Я сумніваюсь щодо вдалості цієї ідеї. Якщо ми робимо `silent` оновлення, то ми, виходить, на рівні
фільтрів визначаємо, що ця подія є непотрібною сабскрайберу - і він її не може отримати. Я думаю, що сабскрайбер
має сам визначати, на які події він реагуватиме, а на які - ні. Через це, я думаю, необхідно реалізувати
більш гнучкий механізм підписки на події, або збільшити кількість подій. Словом, розширити інтерфейс підписки на фільтри.

### Table `headers` vs Filters `fields`, а також `sort`

Тут все складно. З одного боку, сортування та вибрані колонки мають лежати на рівні таблиці (як мінімум, щоб їх намалювати),
а, з іншого, філди і сортування є фільтрами, які мають бути в сторі. Як це розрулити? - Я розділив окремо сутність хедера,
і фільтр філдів та сортування. Через це логіка взаємодії з таблицею дуже ускладнилась через необхідність відновлювати
та змінювати хедери відносно змін у фільтрах. Більше того, через це довелось дописувати спеціальні методи у Тейбл Стор - що
теж є дуже небажаним.

Коли я це робив, я не придумав кращого варіанту, але, я хотів би переглянути це рішення.

### Page & Size як фільтри

Дискусійним є питання, чи пейджа та сайз є фільтрами? - Я вважаю, що є. Але ось тестувальниця до мене підходила,
і питала, чому так. Тож, просто фіксую це, як альтернативну думку.
