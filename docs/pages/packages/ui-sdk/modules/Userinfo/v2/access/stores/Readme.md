# Userinfo v2, Access Control: `accessStore`

Pinia Store, який акумулює в собі логіку, повʼязану з перевіркою прав доступу.

## Користування

### Функції перевірки `WtObject`'ів

"Виставляє" примітивні, універсальні функції для перевірки прав доступу
**до конкретного `WtObject`'а (!)**.

```ts
return {
    // ...
    hasReadAccess, // (WtObject) => boolean
    hasCreateAccess, // (WtObject) => boolean
    hasUpdateAccess, // (WtObject) => boolean
    hasDeleteAccess, // (WtObject) => boolean
    hasSpecialGlobalActionAccess, // (SpecialGlobalAction) => boolean
    // ...
}
```

> [!WARNING]
> **Зверніть увагу!** Ще раз: **ці методи – не перевіряють доступ до видимості розділів**. 
>
> Перевіряється тільки право до конкретного набору обʼєктів.
> aka WtObject aka [`WtSysType`'ів](../../../../../../../knowledge-base/namings/wt-types/WtTypes.md)

## Route Access Guard

### Задача

**Нам треба перевіряти право доступу (видимість) до конкретних розділів, які, фактично, є певними роутами.**
Наприклад, для окремих ролей чи користувачів заховати розділ "Черги", але показати розділ "Регіони".

Чому просто не перевірити `WtObject`? – тому що **може бути (і зазвичай є) кейс, коли
необхідно обмежити візуальний доступ до таблички сутності, але при цьому дати можливість відображати
список записів для певного фільтра по цій сутності.**

Або, тому що візуальний доступ налаштувати значно простіше, хоч він і "дірявий", ніж розібратися
у складній системі керування доступами.

## Рішення

Логічно – повісити guard. 

Але основне питання – де ж його повісити, і в який момент?

Я думаю (станом на `v25.08`), що найкращим способом для цього є не розмазувати
цей функціонал тонким шаром з купою імпортів, а якось "купкою" це скласти.

Для цього я одразу ж **в рамках `accessStore` написав `routeAccessGuard`-функцію, яку треба засетапити в роутер
клієнт-апплікейшена – і воно "полетить".**

Ця функція (яка сетапиться в роутер як access guard) **перевіряє права згідно `meta`-даних роуту**, і "дозволяє",
або перекидає на 403 сторінку.

### Route meta

Але, який нюанс: для цього guard'а необхідно вказати до роута, який має перевірятись,
секцію або (та? – не памʼятаю) `WtObject`, який перевіряється (або навпаки, не вказати, 
якщо роут не має перевірятись на права)

Виглядає це приблизно так:

```ts
// crm/router.ts

import { CrmSections, WtObject } from '@webitel/ui-sdk/enums'; // [!code ++]
// ...

const routes = [
    // ...
    {
        path: 'close-reason-groups/:id',
        name: `${CrmSections.CloseReasonGroups}-card`,
        component: OpenedCloseReasonGroups,
        redirect: {name: `${CrmSections.CloseReasonGroups}-general`},
        meta: { // [!code ++]
            WtObject: WtObject.CloseReasonGroup, // [!code ++]
            UiSection: CrmSections.CloseReasonGroups, // [!code ++]
        }, // [!code ++]
    },
// ...
];
```

#### Як відбувається setup guard'а?

Окрема стаття: [Setting up Access Control](#)

#### `WtObject` vs `UiSection` – що використовувати?

А я не памʼятаю. Там були якісь нюанси, але не пригадаю. Якщо виявите, що щось з того зайве – забирайте. 

## Та інші кейси користування `accessStore`

Зазвичай, з `accessStore` треба щось тягнути, якщо у вас якесь специфічне завдання.

Тому що, це доволі низькорівневий леєр, і більшість роботи з правами:

* на рівні компонента виконується через повʼязані `composables`,

*  з роутером – route guard сетапиться один раз.

## FAQ

