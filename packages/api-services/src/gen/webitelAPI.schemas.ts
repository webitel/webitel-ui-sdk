/**
 * Generated by orval v8.0.2 üç∫
 * Do not edit manually.
 * Webitel API
 * OpenAPI spec version: 24.04.0
 */
export type AccessStoreToggleDefaultAccessBodyObject = { [key: string]: unknown };

export interface ApiObjectId {
  id?: string;
  name?: string;
}

export interface ApiGrantAccessRequestV1 {
  grantee?: string;
  grants?: string;
  object?: ApiObjectId;
}

export interface AccessStoreToggleDefaultAccessBody {
  /** list of changes ...

[TO] (GRANT/REVOKE) */
  list?: ApiGrantAccessRequestV1[];
  object?: AccessStoreToggleDefaultAccessBodyObject;
}

export type ClassesUpdateClassBodyClass = {
  abac?: boolean;
  class?: string;
  obac?: boolean;
  rbac?: boolean;
};

export interface ClassesUpdateClassBody {
  class?: ClassesUpdateClassBodyClass;
  domain?: string;
  fields?: string[];
}

export interface FormatBold { [key: string]: unknown }

export interface FormatCodeblock {
  language?: string;
}

export interface FormatItalic { [key: string]: unknown }

export interface FormatLink {
  url?: string;
}

export interface FormatMonospace { [key: string]: unknown }

export interface FormatStrikethrough { [key: string]: unknown }

export interface FormatUnderline { [key: string]: unknown }

export interface CommentFormat {
  bold?: FormatBold;
  codeblock?: FormatCodeblock;
  italic?: FormatItalic;
  /** Length text runes count. */
  length?: number;
  link?: FormatLink;
  monospace?: FormatMonospace;
  /** Offset text runes count. */
  offset?: number;
  strikethrough?: FormatStrikethrough;
  underline?: FormatUnderline;
}

export type WfmAbsenceType = typeof WfmAbsenceType[keyof typeof WfmAbsenceType];


export const WfmAbsenceType = {
  AbsenceTypeUnspecified: 'ABSENCE_TYPE_UNSPECIFIED',
  AbsenceTypeDayoff: 'ABSENCE_TYPE_DAYOFF',
  AbsenceTypeVacation: 'ABSENCE_TYPE_VACATION',
  AbsenceTypeSickday: 'ABSENCE_TYPE_SICKDAY',
} as const;

export interface CreateAgentsAbsencesRequestabsentType {
  dateFrom?: string;
  dateTo?: string;
  typeId?: WfmAbsenceType;
}

export type DictionariesImportCSVBodyFields = {[key: string]: number};

export type ImportCSVRequestaction = typeof ImportCSVRequestaction[keyof typeof ImportCSVRequestaction];


export const ImportCSVRequestaction = {
  Continue: 'continue',
  Break: 'break',
} as const;

export interface DictionariesImportCSVBody {
  data?: string;
  fields?: DictionariesImportCSVBodyFields;
  lineBegin?: number;
  lineEnd?: number;
  onDataError?: ImportCSVRequestaction;
  onEmptyLine?: ImportCSVRequestaction;
}

export type DomainsUpdateDomainBodyDomain = {
  country?: string;
  createdAt?: string;
  createdBy?: string;
  domain?: string;
  email?: string;
  locality?: string;
  organization?: string;
  postalAddress?: string;
  postalCode?: string;
  stateOrProvince?: string;
  streetAddress?: string;
  telephoneNumber?: string;
  updatedAt?: string;
  updatedBy?: string;
};

export interface DomainsUpdateDomainBody {
  domain?: DomainsUpdateDomainBodyDomain;
}

/**
 * Lookup reference information.
Simplified search filter to uniquely identify related object.
 */
export interface WebitelcontactsLookup {
  /** Reference Object unique ID. */
  id?: string;
  /** Reference Object display name. */
  name?: string;
  /** Reference Object well-known type. */
  type?: string;
}

/**
 * Request message for creating a new condition.
 */
export interface DynamicConditionsCreateConditionBody {
  /** The ID of the assignee that should be assigned if the condition is met (optional). */
  assignee?: WebitelcontactsLookup;
  /** The query or condition expression used to evaluate the group. */
  expression?: string;
  /** The ID of the static group that should be assigned if the condition is met. */
  group?: WebitelcontactsLookup;
}

export type LDAPCreateLDAPTemplateBodyAgent = { [key: string]: unknown };

export type LDAPCreateLDAPTemplateBodyCatalog = {
  name?: string;
};

export type LDAPCreateLDAPTemplateBodyDevice = { [key: string]: unknown };

export type LDAPCreateLDAPTemplateBodyRole = { [key: string]: unknown };

export type LDAPCreateLDAPTemplateBodyUser = { [key: string]: unknown };

/**
 * UserId lookup value.
 */
export interface ApiUserId {
  id?: string;
  name?: string;
}

export interface LDAPCreateLDAPTemplateBody {
  agent?: LDAPCreateLDAPTemplateBodyAgent;
  baseDn?: string;
  catalog?: LDAPCreateLDAPTemplateBodyCatalog;
  /** unix */
  createdAt?: string;
  createdBy?: ApiUserId;
  device?: LDAPCreateLDAPTemplateBodyDevice;
  enabled?: boolean;
  id?: string;
  name?: string;
  role?: LDAPCreateLDAPTemplateBodyRole;
  search?: string;
  updatedAt?: string;
  updatedBy?: ApiUserId;
  user?: LDAPCreateLDAPTemplateBodyUser;
}

export interface LDAPDeleteLDAPTemplateBody {
  baseDn?: string;
  disabled?: boolean;
  enabled?: boolean;
  fields?: string[];
  id?: string[];
  name?: string;
  objclass?: string;
  /** default: 1 */
  page?: number;
  q?: string;
  size?: number;
  sort?: string[];
}

export interface ApiLDAPControl {
  controlType?: string;
  controlValue?: string;
  criticality?: boolean;
}

export interface ApiLDAPSearchRequestTLSConfig {
  /** base64 */
  pem?: string;
}

export interface LDAPLDAPSearchBody {
  attributes?: string[];
  baseObject?: string;
  /** authorization method e.g.: SIMPLE, SAML, NTLM, etc. */
  bind?: string;
  controls?: ApiLDAPControl[];
  derefAliases?: number;
  filter?: string;
  password?: string;
  scope?: number;
  sizeLimit?: string;
  timeLimit?: string;
  tls?: ApiLDAPSearchRequestTLSConfig;
  typesOnly?: boolean;
  /** URL e.g.: [(ldap|ldapi|ldaps)://]host[:port] */
  url?: string;
  username?: string;
}

export interface ApiLDAProcessOptions {
  linkExistingObjects?: boolean;
  reassignDeviceUsers?: boolean;
  test?: boolean;
  timeout?: string;
}

export interface LDAPResyncLDAPCatalogBody {
  options?: ApiLDAProcessOptions;
}

/**
 * RoleId lookup value.
 */
export interface ApiRoleId {
  id?: string;
  name?: string;
  user?: boolean;
}

/**
 * map<string, string> entry = 1;
 */
export type ApiLDAPObjentryEntry = { [key: string]: unknown };

export type ApiLDAPObjentryObject = { [key: string]: unknown };

export interface ApiLDAPObjentry {
  class?: string;
  /** map<string, string> entry = 1; */
  entry?: ApiLDAPObjentryEntry;
  errs?: string[];
  object?: ApiLDAPObjentryObject;
  proc?: string;
  warn?: string[];
}

export interface ApiLDAProcess {
  /** Optional. If not <zero> indicates that this process is completed. */
  completeAt?: string;
  executeAt?: string;
  executeBy?: ApiRoleId;
  id?: string;
  options?: ApiLDAProcessOptions;
  progress?: ApiLDAPObjentry[];
  status?: string;
}

export type ApiLDAPTemplateAgent = { [key: string]: unknown };

export type ApiLDAPTemplateDevice = { [key: string]: unknown };

export type ApiLDAPTemplateRole = { [key: string]: unknown };

export type ApiLDAPTemplateUser = { [key: string]: unknown };

export interface ApiLDAPTemplate {
  agent?: ApiLDAPTemplateAgent;
  baseDn?: string;
  catalog?: ApiObjectId;
  /** unix */
  createdAt?: string;
  createdBy?: ApiUserId;
  device?: ApiLDAPTemplateDevice;
  enabled?: boolean;
  id?: string;
  name?: string;
  role?: ApiLDAPTemplateRole;
  search?: string;
  updatedAt?: string;
  updatedBy?: ApiUserId;
  user?: ApiLDAPTemplateUser;
}

export interface ApiLDAPCatalogTLSConfig {
  ca?: string;
  /** PEM: base64 */
  cert?: string;
  key?: string;
}

/**
 * LDAP Catalog changes.
 */
export type LDAPUpdateLDAPCatalogBodyCatalog = {
  baseDn?: string;
  /** authorization method e.g.: SIMPLE, SAML, NTLM, etc. */
  bind?: string;
  /** unix */
  createdAt?: string;
  createdBy?: ApiUserId;
  /** [CRON]OS SPEC ! github.com/robfig/cron/v3 */
  cron?: string;
  entryModify?: string;
  /** entry unique id (except DN which may be updated) */
  entryUuid?: string;
  name?: string;
  password?: string;
  process?: ApiLDAProcess;
  sync?: ApiLDAProcessOptions;
  templates?: ApiLDAPTemplate[];
  tls?: ApiLDAPCatalogTLSConfig;
  updatedAt?: string;
  updatedBy?: ApiUserId;
  /** URL e.g.: [(ldap|ldapi|ldaps)://]host[:port] */
  url?: string;
  username?: string;
};

export interface LDAPUpdateLDAPCatalogBody {
  /** LDAP Catalog changes. */
  catalog?: LDAPUpdateLDAPCatalogBodyCatalog;
  fields?: string[];
}

export type LDAPUpdateLDAPTemplateBodyTemplateAgent = { [key: string]: unknown };

export type LDAPUpdateLDAPTemplateBodyTemplateCatalog = {
  name?: string;
};

export type LDAPUpdateLDAPTemplateBodyTemplateDevice = { [key: string]: unknown };

export type LDAPUpdateLDAPTemplateBodyTemplateRole = { [key: string]: unknown };

export type LDAPUpdateLDAPTemplateBodyTemplateUser = { [key: string]: unknown };

/**
 * Template changes.
 */
export type LDAPUpdateLDAPTemplateBodyTemplate = {
  agent?: LDAPUpdateLDAPTemplateBodyTemplateAgent;
  baseDn?: string;
  catalog?: LDAPUpdateLDAPTemplateBodyTemplateCatalog;
  /** unix */
  createdAt?: string;
  createdBy?: ApiUserId;
  device?: LDAPUpdateLDAPTemplateBodyTemplateDevice;
  enabled?: boolean;
  name?: string;
  role?: LDAPUpdateLDAPTemplateBodyTemplateRole;
  search?: string;
  updatedAt?: string;
  updatedBy?: ApiUserId;
  user?: LDAPUpdateLDAPTemplateBodyTemplateUser;
};

export interface LDAPUpdateLDAPTemplateBody {
  fields?: string[];
  /** Template changes. */
  template?: LDAPUpdateLDAPTemplateBodyTemplate;
}

export interface OAuth2FederationDeleteOAuthServiceBody {
  permanent?: boolean;
}

export type OAuth2FederationUpdateOAuthServiceBodyChangesMetadata = { [key: string]: unknown };

export interface ApiClaim {
  type?: string;
  value?: string;
}

/**
 * Configuration changes.
 */
export type OAuth2FederationUpdateOAuthServiceBodyChanges = {
  authUrl?: string;
  /** google.protobuf.Struct claims = 7; */
  claims?: ApiClaim[];
  clientId?: string;
  clientSecret?: string;
  createdAt?: string;
  createdBy?: ApiObjectId;
  discoveryUrl?: string;
  domain?: ApiObjectId;
  enabled?: boolean;
  logo?: string;
  metadata?: OAuth2FederationUpdateOAuthServiceBodyChangesMetadata;
  name?: string;
  scopes?: string[];
  tokenUrl?: string;
  type?: string;
  updatedAt?: string;
  updatedBy?: ApiObjectId;
  userinfoUrl?: string;
};

export interface OAuth2FederationUpdateOAuthServiceBody {
  /** Configuration changes. */
  changes?: OAuth2FederationUpdateOAuthServiceBodyChanges;
  fields?: string[];
}

/**
 * BODY: partial modifications
 */
export type PresenceSetStatusBodyPublish = {
  expires?: number;
  note?: string;
  status?: string;
  timestamp?: string;
};

export interface PresenceSetStatusBody {
  fields?: string[];
  /** BODY: partial modifications */
  publish?: PresenceSetStatusBodyPublish;
}

export type RolesUpdateRoleBodyRoleMetadata = { [key: string]: unknown };

export interface ApiPermission {
  /** [required] e.g.: 'read', 'playback_record_file', ... */
  id?: string;
  name?: string;
  usage?: string;
}

export type RolesUpdateRoleBodyRole = {
  createdAt?: string;
  createdBy?: ApiUserId;
  deletedAt?: string;
  deletedBy?: ApiUserId;
  description?: string;
  /** users/roles */
  members?: ApiObjectId[];
  metadata?: RolesUpdateRoleBodyRoleMetadata;
  name?: string;
  permissions?: ApiPermission[];
  updatedAt?: string;
  updatedBy?: ApiUserId;
  user?: boolean;
};

export interface RolesUpdateRoleBody {
  fields?: string[];
  role?: RolesUpdateRoleBodyRole;
}

export interface SearchUsersRequestPresence {
  note?: string;
  status?: string;
}

export interface UsersLogoutUserBody { [key: string]: unknown }

export interface ApiAccessRule {
  granted?: string;
  grantee?: ApiRoleId;
  /** [WHO]: operational; current user NEED to be rechecked !!! */
  grantor?: ApiRoleId;
}

export interface ApiAccessToken {
  /** REQUIRED. The access token issued by the authorization server. */
  accessToken?: string;
  /** RECOMMENDED. The lifetime in seconds of the access token. */
  expiresIn?: number;
  /** OPTIONAL. The refresh token, which can be used to obtain
new access tokens using the same authorization grant. */
  refreshToken?: string;
  /** OPTIONAL, if identical to the scope requested by the client;
otherwise, REQUIRED. The scope of the access token.
repeated string scope = 5 [ json_name = "scope" ];
REQUIRED if the "state" parameter was present in the client
authorization request. The exact value received from the client. */
  state?: string;
  /** REQUIRED. The type of the token issued. Value is case insensitive. */
  tokenType?: string;
}

export type ApiDeviceProvision = {[key: string]: string};

export interface ApiDevice {
  /** username */
  account?: string;
  /** vendor brand name */
  brand?: string;
  createdAt?: string;
  createdBy?: ApiUserId;
  deletedAt?: string;
  deletedBy?: ApiUserId;
  /** act as a hotdesk */
  hotdesk?: boolean;
  hotdesks?: string[];
  id?: string;
  ip?: string;
  loggedIn?: string;
  mac?: string;
  model?: string;
  /** display name */
  name?: string;
  password?: string;
  provision?: ApiDeviceProvision;
  reged?: boolean;
  updatedAt?: string;
  updatedBy?: ApiUserId;
  user?: ApiUserId;
}

export interface ApiCreateDeviceResponse {
  device?: ApiDevice;
}

export interface ApiOrganization {
  country?: string;
  createdAt?: string;
  createdBy?: string;
  dc?: string;
  domain?: string;
  email?: string;
  locality?: string;
  organization?: string;
  postalAddress?: string;
  postalCode?: string;
  stateOrProvince?: string;
  streetAddress?: string;
  telephoneNumber?: string;
  updatedAt?: string;
  updatedBy?: string;
}

export interface ApiCreateDomainRequest {
  organization?: ApiOrganization;
  password?: string;
  superuser?: string;
}

export interface ApiCreateDomainResponse { [key: string]: unknown }

export type ApiRoleMetadata = { [key: string]: unknown };

export interface ApiRole {
  createdAt?: string;
  createdBy?: ApiUserId;
  deletedAt?: string;
  deletedBy?: ApiUserId;
  description?: string;
  id?: string;
  /** users/roles */
  members?: ApiObjectId[];
  metadata?: ApiRoleMetadata;
  name?: string;
  permissions?: ApiPermission[];
  updatedAt?: string;
  updatedBy?: ApiUserId;
  user?: boolean;
}

export interface ApiCreateRoleRequest {
  copyId?: string;
  role?: ApiRole;
}

export interface ApiCreateRoleResponse {
  created?: ApiRole;
}

export interface ApiLicenseUser {
  expiresAt?: string;
  id?: string;
  issuedAt?: string;
  prod?: string;
  scope?: string[];
  user?: ApiObjectId;
}

export interface ApiUserPresence {
  expires?: number;
  id?: string;
  note?: string;
  status?: string;
  timestamp?: string;
}

export type ApiUserProfile = {[key: string]: string};

/**
 * User profile.
 */
export interface ApiUser {
  /** The "chat_name" field is used to store the name displayed externally on the platform.
For example, "chat_name" is shown when an agent connects to chats with clients. */
  chatName?: string;
  /** [optional] contact connected to this user */
  contact?: ApiObjectId;
  createdAt?: string;
  createdBy?: ApiUserId;
  deletedAt?: string;
  deletedBy?: ApiUserId;
  device?: ApiObjectId;
  /** [editable] list of unique `regular` devices, attached to this user */
  devices?: ApiObjectId[];
  email?: string;
  extension?: string;
  /** When set to true, the user will be required to change their password on next login. */
  forcePasswordChange?: boolean;
  hotdesks?: ApiObjectId[];
  id?: string;
  license?: ApiLicenseUser[];
  name?: string;
  password?: string;
  permissions?: ApiPermission[];
  /** string presence = 7; // unique set of <user> presentity <status:basic> tuples open[ed]
 string status = 8; // short display status (short description) */
  presence?: ApiUserPresence;
  profile?: ApiUserProfile;
  roles?: ApiObjectId[];
  totpUrl?: string;
  updatedAt?: string;
  updatedBy?: ApiUserId;
  username?: string;
}

export interface ApiCreateUserRequest {
  confirmPassword?: string;
  user?: ApiUser;
  userPassword?: string;
}

export interface ApiCreateUserResponse {
  user?: ApiUser;
}

/**
 * defines map[class]limit usage
 */
export type ApiCustomerLimit = {[key: string]: number};

export interface ApiVerification {
  errors?: string[];
  notify?: string[];
}

export interface ApiLicenseV1 {
  competitive?: boolean;
  id?: string;
  limit?: number;
  notAfter?: string;
  notBefore?: string;
  product?: string;
  /** available */
  remain?: number;
  /** list of known classes, &this product grants mandatory access to, e.g.: 'users', 'roles', 'cc_agent', 'calendars', ... */
  scope?: string[];
  status?: ApiVerification;
  users?: ApiLicenseUser[];
}

export interface ApiCustomer {
  /** local created ms */
  createdAt?: string;
  dnsrv?: ApiObjectId[];
  id?: string;
  /** [required] issuer(CA) created at */
  issuedAt?: string;
  /** grants issued */
  license?: ApiLicenseV1[];
  /** defines map[class]limit usage */
  limit?: ApiCustomerLimit;
  nextUpdate?: string;
  notAfter?: string;
  notBefore?: string;
  organization?: string;
  revokedAt?: string;
  /** [optional]: issuer(CA) signed at */
  thisUpdate?: string;
  updatedAt?: string;
  /** [optional] validation results */
  verify?: ApiVerification;
}

export interface ApiDeleteDeviceResponse {
  deleted?: ApiDevice[];
}

export interface ApiDeleteDomainResponse { [key: string]: unknown }

export interface ApiDeleteLDAPRequest {
  id?: string;
  relatedObjects?: boolean;
}

export interface ApiDeleteOAuthServiceRequest {
  id?: string[];
  permanent?: boolean;
}

export interface ApiDeleteOAuthServiceResponse { [key: string]: unknown }

export interface ApiDeleteRoleResponse {
  deleted?: ApiRole;
}

export interface ApiDeleteUsersResponse {
  deleted?: ApiUser[];
}

export interface ApiDeviceId {
  id?: string;
  name?: string;
}

export interface ApiDeviceAudit {
  device?: ApiDeviceId;
  hotdesk?: string;
  loggedIn?: string;
  loggedOut?: string;
  user?: ApiUserId;
}

export interface ApiDeviceAuditResponse {
  items?: ApiDeviceAudit[];
  next?: boolean;
  page?: number;
  size?: number;
}

export interface ApiTfaUrl {
  url?: string;
  user?: ApiUserId;
}

export interface ApiGenerateUserTfaKeyResponse {
  totp?: ApiTfaUrl;
}

export interface ApiGetCustomerResponse {
  customer?: ApiCustomer;
}

export type ApiGetPasswordSettingsResponseSettings = {[key: string]: string};

export interface ApiGetPasswordSettingsResponse {
  settings?: ApiGetPasswordSettingsResponseSettings;
}

export interface ApiGetUserTfaKeyResponse {
  totp?: ApiTfaUrl;
}

export interface ApiLDAPCatalog {
  baseDn?: string;
  /** authorization method e.g.: SIMPLE, SAML, NTLM, etc. */
  bind?: string;
  /** unix */
  createdAt?: string;
  createdBy?: ApiUserId;
  /** [CRON]OS SPEC ! github.com/robfig/cron/v3 */
  cron?: string;
  entryModify?: string;
  /** entry unique id (except DN which may be updated) */
  entryUuid?: string;
  id?: string;
  name?: string;
  password?: string;
  process?: ApiLDAProcess;
  sync?: ApiLDAProcessOptions;
  templates?: ApiLDAPTemplate[];
  tls?: ApiLDAPCatalogTLSConfig;
  updatedAt?: string;
  updatedBy?: ApiUserId;
  /** URL e.g.: [(ldap|ldapi|ldaps)://]host[:port] */
  url?: string;
  username?: string;
}

export interface ApiLDAPSearchRequest {
  attributes?: string[];
  baseObject?: string;
  /** authorization method e.g.: SIMPLE, SAML, NTLM, etc. */
  bind?: string;
  catalogId?: string;
  controls?: ApiLDAPControl[];
  derefAliases?: number;
  filter?: string;
  password?: string;
  scope?: number;
  sizeLimit?: string;
  timeLimit?: string;
  tls?: ApiLDAPSearchRequestTLSConfig;
  typesOnly?: boolean;
  /** URL e.g.: [(ldap|ldapi|ldaps)://]host[:port] */
  url?: string;
  username?: string;
}

export type ApiLDAPSearchResponseEntriesItem = { [key: string]: unknown };

export interface ApiLDAPSearchResponse {
  controls?: ApiLDAPControl[];
  diagnosticMessage?: string;
  entries?: ApiLDAPSearchResponseEntriesItem[];
  matchedDn?: string;
  referral?: string[];
  resultCode?: number;
}

export interface ApiLDAPTemplateResponse {
  items?: ApiLDAPTemplate[];
  next?: boolean;
  page?: number;
}

export interface ApiLDAProcessResponse {
  items?: ApiLDAProcess[];
  next?: boolean;
  page?: number;
}

export interface ApiLicenseUsageResponse {
  items?: ApiLicenseV1[];
  next?: boolean;
  /** this page number ! */
  page?: number;
}

export interface ApiProductUser {
  domain?: ApiObjectId;
  expiresAt?: string;
  issuedAt?: string;
  sessions?: number;
  user?: ApiObjectId;
}

export interface ApiLicenseUsersResponse {
  items?: ApiProductUser[];
  next?: boolean;
  /** this page number ! */
  page?: number;
}

export interface ApiListAccessResponseV1 {
  items?: ApiAccessRule[];
  next?: boolean;
  page?: number;
}

export interface ApiRegistration {
  callid?: string;
  contact?: string;
  device?: ApiDeviceId;
  expiresAt?: string;
  id?: string;
  instance?: string;
  received?: string;
  registerAt?: string;
  socket?: string;
  user?: ApiUserId;
  userAgent?: string;
}

export interface ApiListRegistrationsResponse {
  items?: ApiRegistration[];
  next?: boolean;
  page?: number;
  size?: number;
}

export interface ApiPasswordExpiryWarning {
  daysRemaining?: string;
  expiresAt?: string;
}

export interface ApiWarningData {
  passwordExpiry?: ApiPasswordExpiryWarning;
}

export interface ApiUserWarning {
  detail?: string;
  id?: string;
  warningData?: ApiWarningData;
}

export interface ApiLoginResponse {
  authorization?: ApiAccessToken;
  warnings?: ApiUserWarning[];
}

export interface ApiLogoutUserResponse { [key: string]: unknown }

export type ApiOAuthServiceMetadata = { [key: string]: unknown };

export interface ApiOAuthService {
  authUrl?: string;
  /** google.protobuf.Struct claims = 7; */
  claims?: ApiClaim[];
  clientId?: string;
  clientSecret?: string;
  createdAt?: string;
  createdBy?: ApiObjectId;
  discoveryUrl?: string;
  domain?: ApiObjectId;
  enabled?: boolean;
  id?: string;
  logo?: string;
  metadata?: ApiOAuthServiceMetadata;
  name?: string;
  scopes?: string[];
  tokenUrl?: string;
  type?: string;
  updatedAt?: string;
  updatedBy?: ApiObjectId;
  userinfoUrl?: string;
}

export interface ApiObjclass {
  /** [A]ttribute-[b]ased;  not implemented; next releases ... */
  abac?: boolean;
  /** flags: [ CREATE | SELECT | UPDATE | DELETE ] */
  access?: string;
  class?: string;
  /** class: object id */
  id?: string;
  name?: string;
  obac?: boolean;
  rbac?: boolean;
}

export interface ApiObjectClass {
  abac?: boolean;
  class?: string;
  id?: string;
  obac?: boolean;
  rbac?: boolean;
}

export interface ApiPresenceStatus {
  app?: string;
  closed?: boolean;
  contact?: string;
  domainId?: string;
  expires?: string;
  /** [required] tuple unique id; <track> */
  id?: string;
  note?: string;
  open?: number;
  /** // FIXME: well-known types ?
 repeated Dialog  call = 9;
 repeated Sipreg  sip = 9;
 repeated Websock wss = 9; */
  presence?: ApiPresenceStatus[];
  priority?: number;
  sequence?: string;
  status?: string;
  timestamp?: string;
}

export interface ApiReadClassResponse {
  class?: ApiObjectClass;
}

export interface ApiReadDeviceResponse {
  device?: ApiDevice;
}

export interface ApiReadDomainResponse {
  domain?: ApiOrganization;
}

export interface ApiReadRoleResponse {
  role?: ApiRole;
}

export interface ApiReadUserResponse {
  user?: ApiUser;
}

export interface ApiRoleMetadataResponse {
  key?: string;
  value?: unknown;
}

export interface ApiSearchClassesResponse {
  items?: ApiObjectClass[];
  next?: boolean;
  page?: number;
  size?: number;
}

export interface ApiSearchDeviceResponse {
  items?: ApiDevice[];
  next?: boolean;
  page?: number;
  size?: number;
}

export interface ApiSearchDomainsResponse {
  domains?: ApiOrganization[];
}

export interface ApiSearchLDAPResponse {
  items?: ApiLDAPCatalog[];
  next?: boolean;
  page?: number;
}

export interface ApiSearchOAuthServiceResponse {
  items?: ApiOAuthService[];
  next?: boolean;
  page?: number;
}

export interface ApiSearchPermissionResponse {
  items?: ApiPermission[];
  next?: boolean;
  page?: number;
  size?: number;
}

export interface ApiSearchRolesResponse {
  items?: ApiRole[];
  next?: boolean;
  /** select: offset {page} */
  page?: number;
  size?: number;
}

export interface ApiSearchUsersRequest {
  /** filter: include 'deleted' ALSO ! (inactive) */
  any?: boolean;
  deleted?: boolean;
  extension?: string;
  /** select: output (fields,...) */
  fields?: string[];
  /** filter: .id = any({id}...) */
  id?: string[];
  name?: string;
  notId?: string[];
  page?: number;
  presence?: SearchUsersRequestPresence;
  /** filter: (.name|.username|.extension|.status) ILIKE '{q}' */
  q?: string;
  size?: number;
  sort?: string[];
  status?: string;
  username?: string;
}

export interface ApiSearchUsersResponse {
  items?: ApiUser[];
  next?: boolean;
  page?: number;
  size?: number;
}

export interface ApiServerInfoResponse {
  key?: string;
}

export interface ApiSetStatusRequest {
  fields?: string[];
  /** BODY: partial modifications */
  publish?: ApiUserPresence;
}

export type ApiSystemObjects = typeof ApiSystemObjects[keyof typeof ApiSystemObjects];


export const ApiSystemObjects = {
  Contacts: 'contacts',
  CcList: 'cc_list',
  CcBucket: 'cc_bucket',
  Calendars: 'calendars',
  Devices: 'devices',
  CcAgent: 'cc_agent',
  CcTeam: 'cc_team',
  CcResource: 'cc_resource',
  CcResourceGroup: 'cc_resource_group',
  CcQueue: 'cc_queue',
  Roles: 'roles',
  Users: 'users',
  CognitiveProfile: 'cognitive_profile',
} as const;

export interface ApiToggleDefaultAccessResponse {
  granted?: ApiAccessRule[];
  revoked?: ApiAccessRule[];
}

export interface ApiUpdateAccessResponseV1 {
  granted?: string;
  revoked?: string;
}

export interface ApiUpdateClassResponse {
  class?: ApiObjectClass;
}

export interface ApiUpdateCustomerResponse {
  customer?: ApiCustomer;
}

export interface ApiUpdateDeviceResponse {
  device?: ApiDevice;
}

export interface ApiUpdateDomainResponse {
  domain?: ApiOrganization;
}

export interface ApiUpdatePasswordRequest {
  confirmPassword?: string;
  domain?: string;
  id?: string;
  oldPassword?: string;
  userPassword?: string;
  username?: string;
}

export interface ApiUpdatePasswordResponse { [key: string]: unknown }

export interface ApiUpdateRoleResponse {
  updated?: ApiRole;
}

export interface ApiUpdateUserResponse {
  updated?: ApiUser;
}

/**
 * UserId lookup value.
 */
export interface ApiUserAccessToken {
  createdAt?: string;
  createdBy?: ApiObjectId;
  deletedAt?: string;
  deletedBy?: ApiObjectId;
  id?: string;
  token?: string;
  updatedAt?: string;
  updatedBy?: ApiObjectId;
  usage?: string;
  user?: ApiObjectId;
}

export interface ApiUserAccessTokenList {
  items?: ApiUserAccessToken[];
  next?: boolean;
  page?: number;
  size?: string;
}

export interface ApiUserSetting {
  key?: string;
}

export interface ApiUserinfo {
  dc?: string;
  domain?: string;
  expiresAt?: string;
  extension?: string;
  license?: ApiLicenseUser[];
  name?: string;
  permissions?: ApiPermission[];
  preferredUsername?: string;
  roles?: ApiObjectId[];
  scope?: ApiObjclass[];
  updatedAt?: string;
  userId?: string;
  username?: string;
}

export type ContactsAccessMode = typeof ContactsAccessMode[keyof typeof ContactsAccessMode];


export const ContactsAccessMode = {
  Read: 'READ',
  Write: 'WRITE',
  Delete: 'DELETE',
} as const;

/**
 * Request message for adding contacts to a group.
 */
export interface ContactsAddContactsToGroupRequest {
  /** List of contact IDs to add to the group. */
  contactIds?: string[];
  /** The unique ID of the group. */
  groupIds?: string[];
}

export interface ContactsCallFile {
  id?: string;
  mimeType?: string;
  name?: string;
  size?: string;
  startAt?: string;
  stopAt?: string;
}

export interface ContactsTranscriptLookup {
  file?: WebitelcontactsLookup;
  id?: string;
  locale?: string;
}

export interface ContactsCallEvent {
  closedAt?: string;
  duration?: string;
  files?: ContactsCallFile[];
  flowScheme?: WebitelcontactsLookup;
  gateway?: WebitelcontactsLookup;
  id?: string;
  isDetailed?: boolean;
  isInbound?: boolean;
  isMissed?: boolean;
  participants?: WebitelcontactsLookup[];
  queue?: WebitelcontactsLookup;
  totalDuration?: string;
  transcripts?: ContactsTranscriptLookup[];
}

export interface ContactsChatEvent {
  closedAt?: string;
  duration?: string;
  flowScheme?: WebitelcontactsLookup;
  gateway?: WebitelcontactsLookup;
  id?: string;
  isDetailed?: boolean;
  isInbound?: boolean;
  isMissed?: boolean;
  participants?: WebitelcontactsLookup[];
  queue?: WebitelcontactsLookup;
}

export interface ContactsComment {
  /** The user who created this Field. */
  createdAt?: string;
  /** Timestamp(milli) of the Field creation. */
  createdBy?: WebitelcontactsLookup;
  /** Unique ID of the latest version of the update.
This ID changes after any update to the underlying value(s). */
  etag?: string;
  /** Styles of the text components. */
  format?: CommentFormat[];
  /** The unique ID of the Comment. Never changes. */
  id?: string;
  /** Rich Text, multi-line[d] string value. */
  text?: string;
  /** Timestamp(milli) of the last Field update.
Take part in Etag generation. */
  updatedAt?: string;
  /** The user who performed last Update. */
  updatedBy?: WebitelcontactsLookup;
  /** Version of the latest update. Numeric sequence. */
  ver?: number;
}

/**
 * Comment dataset.
 */
export interface ContactsCommentList {
  /** Comment dataset page. */
  data?: ContactsComment[];
  next?: boolean;
  /** The page number of the partial result. */
  page?: number;
}

export interface ContactsCondition {
  /** The ID of the assignee that should be assigned if the condition is met (optional). */
  assignee?: WebitelcontactsLookup;
  /** The timestamp (in milliseconds) of when the condition was created. */
  createdAt?: string;
  /** The user who created this condition. */
  createdBy?: WebitelcontactsLookup;
  /** The query or condition expression used to evaluate the group. */
  expression?: string;
  /** The ID of the static group that should be assigned if the condition is met. */
  group?: WebitelcontactsLookup;
  /** The unique ID of the condition. */
  id?: string;
  /** The timestamp (in milliseconds) of the last update. */
  updatedAt?: string;
  /** The user who performed the last update. */
  updatedBy?: WebitelcontactsLookup;
}

/**
 * A list of Conditions.
 */
export interface ContactsConditionList {
  /** List of conditions. */
  items?: ContactsCondition[];
  /** Have more records. */
  next?: boolean;
  /** Page number of the partial result. */
  page?: number;
}

/**
 * The Contact's Group association.
 */
export interface ContactsContactGroup {
  /** The user who created this Field. */
  createdAt?: string;
  /** Timestamp(milli) of the Field creation. */
  createdBy?: WebitelcontactsLookup;
  /** Unique ID of the latest version of the update.
This ID changes after any update to the underlying value(s). */
  etag?: string;
  /** Group of contacts associated. */
  group?: WebitelcontactsLookup;
  /** The unique ID of the association. Never changes. */
  id?: string;
  /** Timestamp(milli) of the last Field update.
Take part in Etag generation. */
  updatedAt?: string;
  /** The user who performed last Update. */
  updatedBy?: WebitelcontactsLookup;
  /** Version of the latest update. Numeric sequence. */
  ver?: number;
}

/**
 * Contact groups dataset.
NOTE: Edge represents connection between two nodes.
So this ContactGroupList.data are always subordinate to some contact.id.
 */
export interface ContactsContactGroupList {
  /** Group dataset page. */
  data?: ContactsContactGroup[];
  next?: boolean;
  /** The page number of the partial result. */
  page?: number;
}

/**
 * The Contact's email address.
 */
export interface ContactsEmailAddress {
  /** The user who created this Field. */
  createdAt?: string;
  /** Timestamp(milli) of the Field creation. */
  createdBy?: WebitelcontactsLookup;
  /** The email address. */
  email?: string;
  /** Unique ID of the latest version of the update.
This ID changes after any update to the underlying value(s). */
  etag?: string;
  /** The unique ID of the association. Never changes. */
  id?: string;
  /** Indicates whether this phone number is default within other channels of the same type(phone). */
  primary?: boolean;
  type?: WebitelcontactsLookup;
  /** Timestamp(milli) of the last Field update.
Take part in Etag generation. */
  updatedAt?: string;
  /** The user who performed last Update. */
  updatedBy?: WebitelcontactsLookup;
  /** Version of the latest update. Numeric sequence. */
  ver?: number;
  verified?: boolean;
}

/**
 * Email dataset.
 */
export interface ContactsEmailList {
  /** EmailAddress dataset page. */
  data?: ContactsEmailAddress[];
  next?: boolean;
  /** The page number of the partial result. */
  page?: number;
}

/**
 * A contact's [I]nstant[M]essaging client.
 */
export interface ContactsIMClient {
  /** App (Text-Gateway) used to connect the IM client.
Id will be internal id of gateway.
Name will be name of the gateway. */
  app?: WebitelcontactsLookup;
  /** The user who created this Field. */
  createdAt?: string;
  /** Timestamp(milli) of the Field creation. */
  createdBy?: WebitelcontactsLookup;
  /** Unique ID of the latest version of the update.
This ID changes after any update to the underlying value(s). */
  etag?: string;
  /** External user id. */
  externalId?: string;
  /** The unique ID of the association. Never changes. */
  id?: string;
  /** Protocol used to connect the IM client. */
  protocol?: string;
  /** Timestamp(milli) of the last Field update.
Take part in Etag generation. */
  updatedAt?: string;
  /** The user who performed last Update. */
  updatedBy?: WebitelcontactsLookup;
  /** External user which contacted to us.
Id will be from external service.
Name will be from external service. */
  user?: WebitelcontactsLookup;
  /** Version of the latest update. Numeric sequence. */
  ver?: number;
  /** [Via] App(-specific) peer(-id) to connect[from] the IM client. */
  via?: string;
}

export interface ContactsIMClientList {
  /** IMClient dataset page. */
  data?: ContactsIMClient[];
  next?: boolean;
  /** The page number of the partial result. */
  page?: number;
}

/**
 * A Contact's associated Tag.
Output purpose only.
 */
export interface WebitelcontactsLabel {
  /** The user who created this Field. */
  createdAt?: string;
  /** Timestamp(milli) of the Field creation. */
  createdBy?: WebitelcontactsLookup;
  /** Unique ID of the latest version of the update.
This ID changes after any update to the underlying value(s). */
  etag?: string;
  /** The unique ID of the association. Never changes. */
  id?: string;
  /** REQUIRED. Tag value;
NOTE: Keep in mind, hashtags are not case-sensitive,
but adding capital letters does make them easier to read:
#MakeAWish vs. #makeawish. */
  label?: string;
  /** Timestamp(milli) of the last Field update.
Take part in Etag generation. */
  updatedAt?: string;
  /** The user who performed last Update. */
  updatedBy?: WebitelcontactsLookup;
  /** Version of the latest update. Numeric sequence. */
  ver?: number;
}

/**
 * LabelList dataset.
NOTE: Edge represents connection between two nodes.
So this ContactLabels.data are always subordinate to some contact.id.
 */
export interface ContactsLabelList {
  /** Label(s) dataset page. */
  data?: WebitelcontactsLabel[];
  next?: boolean;
  /** Page number of partial result. */
  page?: number;
}

/**
 * A Contact's locale preference.
Output purpose only.
 */
export interface ContactsLanguage {
  code?: string;
  /** The user who created this Field. */
  createdAt?: string;
  /** Timestamp(milli) of the Field creation. */
  createdBy?: WebitelcontactsLookup;
  /** Unique ID of the latest version of the update.
This ID changes after any update to the underlying value(s). */
  etag?: string;
  /** The unique ID of the association. Never changes. */
  id?: string;
  lang?: string;
  name?: string;
  /** Indicates whether this association is the default
among others of the same type. */
  primary?: boolean;
  region?: string;
  script?: string;
  tag?: string;
  /** Timestamp(milli) of the last Field update.
Take part in Etag generation. */
  updatedAt?: string;
  /** The user who performed last Update. */
  updatedBy?: WebitelcontactsLookup;
  /** Version of the latest update. Numeric sequence. */
  ver?: number;
}

/**
 * LabelsData
NOTE: Edge represents connection between two nodes.
So this ContactLabels.data are always subordinate to some contact.id.
 */
export interface ContactsLanguageList {
  /** Page of the Contact's Language(s) dataset. */
  data?: ContactsLanguage[];
  next?: boolean;
  /** Page number of partial result dataset records. */
  page?: number;
}

/**
 * Manager. The Contact's responsible User.
 */
export interface ContactsManager {
  /** The user who created this Field. */
  createdAt?: string;
  /** Timestamp(milli) of the Field creation. */
  createdBy?: WebitelcontactsLookup;
  /** Unique ID of the latest version of the update.
This ID changes after any update to the underlying value(s). */
  etag?: string;
  /** The unique ID of the association. Never changes. */
  id?: string;
  /** Indicates whether this association is the default
among others of the same type. */
  primary?: boolean;
  /** Timestamp(milli) of the last Field update.
Take part in Etag generation. */
  updatedAt?: string;
  /** The user who performed last Update. */
  updatedBy?: WebitelcontactsLookup;
  /** Responsible User. */
  user?: WebitelcontactsLookup;
  /** Version of the latest update. Numeric sequence. */
  ver?: number;
}

/**
 * Manager dataset.
 */
export interface ContactsManagerList {
  /** Manager dataset page. */
  data?: ContactsManager[];
  next?: boolean;
  /** The page number of the partial result. */
  page?: number;
}

/**
 * A contact's name.
If the name is a mononym, the family name is empty.

Inspired:
https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims
https://developers.google.com/people/api/rest/v1/people#name
 */
export interface ContactsName {
  /** REQUIRED. End-User's full name in displayable form
including all name parts, possibly including titles and suffixes,
ordered according to the End-User's locale and preferences. */
  commonName?: string;
  familyName?: string;
  givenName?: string;
  /** OPTIONAL. Middle name(s) of the End-User.
Note that in some cultures, people can have multiple middle names;
all can be present, with the names being separated by space characters.
Also note that in some cultures, middle names are not used. */
  middleName?: string;
  /** Indicate whether Contact, as a Person, realy owns this associated name. */
  verified?: boolean;
}

/**
 * The Contact's phone number.
 */
export interface ContactsPhoneNumber {
  /** The user who created this Field. */
  createdAt?: string;
  /** Timestamp(milli) of the Field creation. */
  createdBy?: WebitelcontactsLookup;
  /** Unique ID of the latest version of the update.
This ID changes after any update to the underlying value(s). */
  etag?: string;
  /** The unique ID of the association. Never changes. */
  id?: string;
  /** The phone number. */
  number?: string;
  /** Indicates whether this phone number is default within other channels of the same type(phone). */
  primary?: boolean;
  type?: WebitelcontactsLookup;
  /** Timestamp(milli) of the last Field update.
Take part in Etag generation. */
  updatedAt?: string;
  /** The user who performed last Update. */
  updatedBy?: WebitelcontactsLookup;
  /** Version of the latest update. Numeric sequence. */
  ver?: number;
  verified?: boolean;
}

/**
 * PhoneNumber dataset.
 */
export interface ContactsPhoneList {
  /** PhoneNumber dataset page. */
  data?: ContactsPhoneNumber[];
  next?: boolean;
  /** The page number of the partial result. */
  page?: number;
}

/**
 * A contact's photo.
A picture shown next to the contact's name
to help others recognize the contact.
 */
export interface ContactsPhoto {
  /** The user who created this Field. */
  createdAt?: string;
  /** Timestamp(milli) of the Field creation. */
  createdBy?: WebitelcontactsLookup;
  /** Unique ID of the latest version of the update.
This ID changes after any update to the underlying value(s). */
  etag?: string;
  /** The unique ID of the association. Never changes. */
  id?: string;
  photoId?: string;
  photoUrl?: string;
  /** True if the photo is a default photo; false if the photo is a user-provided photo. */
  primary?: boolean;
  /** Timestamp(milli) of the last Field update.
Take part in Etag generation. */
  updatedAt?: string;
  /** The user who performed last Update. */
  updatedBy?: WebitelcontactsLookup;
  /** Version of the latest update. Numeric sequence. */
  ver?: number;
}

/**
 * Photo dataset.
 */
export interface ContactsPhotoList {
  /** Photo dataset page. */
  data?: ContactsPhoto[];
  next?: boolean;
  /** The page number of the partial result. */
  page?: number;
}

/**
 * A Contact's timezone preference.
 */
export interface ContactsTimezone {
  /** The user who created this Field. */
  createdAt?: string;
  /** Timestamp(milli) of the Field creation. */
  createdBy?: WebitelcontactsLookup;
  /** Unique ID of the latest version of the update.
This ID changes after any update to the underlying value(s). */
  etag?: string;
  /** The unique ID of the association. Never changes. */
  id?: string;
  /** Indicates whether this association is the default
among others of the same type. */
  primary?: boolean;
  /** Timezone dictionary reference value associated. */
  timezone?: WebitelcontactsLookup;
  /** Timestamp(milli) of the last Field update.
Take part in Etag generation. */
  updatedAt?: string;
  /** The user who performed last Update. */
  updatedBy?: WebitelcontactsLookup;
  /** Version of the latest update. Numeric sequence. */
  ver?: number;
}

/**
 * Timezone dataset.
NOTE: Edge represents connection between two nodes.
So this ContactTimezones.data are always subordinate to some contact.id.
 */
export interface ContactsTimezoneList {
  /** Timezone dataset page. */
  data?: ContactsTimezone[];
  next?: boolean;
  /** The page number of the partial result. */
  page?: number;
}

/**
 * The Contact's variable.
Arbitrary data that is populated by users or clients.
Duplicate keys and values are allowed.
 */
export interface ContactsVariable {
  /** The user who created this Field. */
  createdAt?: string;
  /** Timestamp(milli) of the Field creation. */
  createdBy?: WebitelcontactsLookup;
  /** Unique ID of the latest version of the update.
This ID changes after any update to the underlying value(s). */
  etag?: string;
  /** The unique ID of the association. Never changes. */
  id?: string;
  /** Key name of the variable. */
  key?: string;
  /** Timestamp(milli) of the last Field update.
Take part in Etag generation. */
  updatedAt?: string;
  /** The user who performed last Update. */
  updatedBy?: WebitelcontactsLookup;
  /** JSON value of the variable. */
  value?: unknown;
  /** Version of the latest update. Numeric sequence. */
  ver?: number;
}

/**
 * Variable dataset.
 */
export interface ContactsVariableList {
  /** Variable dataset page. */
  data?: ContactsVariable[];
  next?: boolean;
  /** The page number of the partial result. */
  page?: number;
}

/**
 * The Contact principal source.
OUTPUT purpose only.
 */
export interface WebitelcontactsContact {
  /** BIO. Short description about the Contact person.
OPTIONAL. Multi-lined text. */
  about?: string;
  /** The Contact's internal comment(s). */
  comments?: ContactsCommentList;
  createdAt?: string;
  createdBy?: WebitelcontactsLookup;
  /** READONLY. The contact's metadata. */
  domain?: WebitelcontactsLookup;
  /** The Contact's email address(es). */
  emails?: ContactsEmailList;
  /** Unique ID of the latest version of the update.
This ID changes after any update to the underlying value(s). */
  etag?: string;
  /** The Contact's associated group(s). */
  groups?: ContactsContactGroupList;
  /** The unique ID of the association. Never changes. */
  id?: string;
  /** The contact's [I]nstant[M]essaging clients. */
  imclients?: ContactsIMClientList;
  /** The Contact's associated tag(s). */
  labels?: ContactsLabelList;
  /** A Contact's locale preference(s). */
  languages?: ContactsLanguageList;
  /** The Contact's internal manager(s). */
  managers?: ContactsManagerList;
  /** [R]ecord[b]ased[A]ccess[C]ontrol mode granted. */
  mode?: string;
  /** The Contact's name.
This field is a singleton for Contact sources. */
  name?: ContactsName;
  /** The Contact's phone numbers. */
  phones?: ContactsPhoneList;
  /** Output only. The Contact's photo(s). */
  readonly photos?: ContactsPhotoList;
  /** The Contact's timezone preference(s). */
  timezones?: ContactsTimezoneList;
  updatedAt?: string;
  updatedBy?: WebitelcontactsLookup;
  user?: WebitelcontactsLookup;
  /** Arbitrary client data that is populated by clients.
Duplicate keys and values are allowed. */
  variables?: ContactsVariableList;
  /** READONLY. Operational attributes
Version of the latest update. Numeric sequence. */
  ver?: number;
}

/**
 * Contact dataset.
 */
export interface ContactsContactList {
  /** Contact(s) dataset page. */
  data?: WebitelcontactsContact[];
  next?: boolean;
  /** The page number of the partial result. */
  page?: number;
}

export interface ContactsInputDynamicCondition {
  /** The ID of the assignee that should be assigned if the condition is met (optional). */
  assignee?: WebitelcontactsLookup;
  /** The query or condition expression used to evaluate the group. */
  expression?: string;
  /** The ID of the static group that should be assigned if the condition is met. */
  group?: WebitelcontactsLookup;
}

/**
 * Request message for creating a new dynamic group.
 */
export interface ContactsCreateDynamicGroupRequest {
  /** Input details for the dynamic group. */
  condition?: ContactsInputDynamicCondition[];
  /** Default static group to assign if no conditions are met. */
  defaultGroup?: WebitelcontactsLookup;
  /** The description of the dynamic group. */
  description?: string;
  /** Enabled status of the dynamic group: active/inactive. */
  enabled?: boolean;
  /** The name of the dynamic group. */
  name: string;
}

/**
 * Request message for creating a new group.
 */
export interface ContactsCreateGroupRequest {
  /** The description of the group. */
  description?: string;
  /** The enabled status of the group. */
  enabled?: boolean;
  /** The name of the group. */
  name: string;
}

export interface WebitelcontactsAttachment {
  id?: string;
  mime?: string;
  name?: string;
  size?: string;
  url?: string;
}

export interface ContactsEmailEvent {
  attachments?: WebitelcontactsAttachment[];
  body?: string;
  cc?: string[];
  from?: string[];
  html?: string;
  id?: string;
  isDetailed?: boolean;
  isInbound?: boolean;
  owner?: WebitelcontactsLookup;
  profile?: WebitelcontactsLookup;
  sender?: string[];
  subject?: string;
  to?: string[];
}

export type ContactsTimelineEventType = typeof ContactsTimelineEventType[keyof typeof ContactsTimelineEventType];


export const ContactsTimelineEventType = {
  Chat: 'chat',
  Call: 'call',
  Email: 'email',
} as const;

export interface ContactsEvent {
  call?: ContactsCallEvent;
  chat?: ContactsChatEvent;
  createdAt?: string;
  email?: ContactsEmailEvent;
  type?: ContactsTimelineEventType;
}

export interface ContactsDayTimeline {
  callsCount?: string;
  chatsCount?: string;
  dayTimestamp?: string;
  emailsCount?: string;
  items?: ContactsEvent[];
}

export interface ContactsDynamicCondition {
  /** The ID of the assignee that should be assigned if the condition is met (optional). */
  assignee?: WebitelcontactsLookup;
  /** The query or condition expression used to evaluate the group. */
  expression?: string;
  /** The ID of the static group that should be assigned if the condition is met. */
  group?: WebitelcontactsLookup;
  /** The unique ID of the condition. */
  id?: string;
}

export interface ContactsDynamicGroup {
  /** List of dynamic conditions associated with the group. */
  conditions?: ContactsDynamicCondition[];
  /** Timestamp(milli) of the group's creation. */
  createdAt?: string;
  /** The user who created this dynamic group. */
  createdBy?: WebitelcontactsLookup;
  /** Default static group to be assigned if no conditions are met. */
  defaultGroup?: WebitelcontactsLookup;
  /** The description of the dynamic group. */
  description?: string;
  /** Enabled status of the group: active or inactive. */
  enabled?: boolean;
  /** The unique ID of the dynamic group. Never changes. */
  id?: string;
  /** The name of the dynamic group. */
  name?: string;
  /** Timestamp(milli) of the last group update. */
  updatedAt?: string;
  /** The user who performed the last update. */
  updatedBy?: WebitelcontactsLookup;
}

/**
 * Input message for creating/updating a dynamic group.
 */
export interface ContactsDynamicGroupInput {
  /** Default static group to assign if no conditions are met. */
  defaultGroup?: WebitelcontactsLookup;
  /** The description of the dynamic group. */
  description?: string;
  /** Enabled status of the dynamic group: active/inactive. */
  enabled?: boolean;
  /** The name of the dynamic group. */
  name?: string;
}

/**
 * A list of Dynamic Groups.
 */
export interface ContactsDynamicGroupList {
  /** List of dynamic groups. */
  items?: ContactsDynamicGroup[];
  /** Have more records. */
  next?: boolean;
  /** Page number of the partial result. */
  page?: number;
}

export interface ContactsEmptyResponse { [key: string]: unknown }

export interface ContactsGetTimelineCounterResponse {
  callsCount?: string;
  chatsCount?: string;
  dateFrom?: string;
  dateTo?: string;
  emailsCount?: string;
}

export interface ContactsGetTimelineResponse {
  days?: ContactsDayTimeline[];
  next?: boolean;
  page?: string;
}

/**
 * - GROUP_TYPE_UNSPECIFIED: Default value
 - STATIC: Static group
 - DYNAMIC: Dynamic group
 */
export type ContactsGroupType = typeof ContactsGroupType[keyof typeof ContactsGroupType];


export const ContactsGroupType = {
  GroupTypeUnspecified: 'GROUP_TYPE_UNSPECIFIED',
  Static: 'STATIC',
  Dynamic: 'DYNAMIC',
} as const;

export interface ContactsGroup {
  /** List of dynamic conditions associated with the group. */
  conditions?: ContactsDynamicCondition[];
  contactsSize?: string;
  /** Timestamp(milli) of the group's creation. */
  createdAt?: string;
  /** The user who created this group. */
  createdBy?: WebitelcontactsLookup;
  /** Default static group to be assigned if no conditions are met. */
  defaultGroup?: WebitelcontactsLookup;
  /** The description of the group. */
  description?: string;
  enabled?: boolean;
  /** The unique ID of the group. Never changes. */
  id?: string;
  /** The name of the group. */
  name?: string;
  type?: ContactsGroupType;
  /** Timestamp(milli) of the last group update. */
  updatedAt?: string;
  /** The user who performed the last update. */
  updatedBy?: WebitelcontactsLookup;
}

/**
 * A list of Groups.
 */
export interface ContactsGroupList {
  /** List of groups. */
  items?: ContactsGroup[];
  /** Have more records. */
  next?: boolean;
  /** Page number of the partial result. */
  page?: number;
}

export interface ContactsInputComment {
  /** Unique ID of the latest version of an existing resorce. */
  etag?: string;
  /** NEW Text components styling format. */
  format?: CommentFormat[];
  /** NEW Text of the comment. */
  text: string;
}

/**
 * Position details for conditions in the group.
 */
export interface ContactsPosition {
  condDown?: string;
  condUp?: string;
}

/**
 * Input message for creating/updating a condition.
 */
export interface ContactsInputCondition {
  /** The ID of the assignee that should be assigned if the condition is met (optional). */
  assignee?: WebitelcontactsLookup;
  /** The query or condition expression used to evaluate the group. */
  expression?: string;
  /** The ID of the static group that should be assigned if the condition is met. */
  group?: string;
  /** The position of the condition in the group. */
  position?: ContactsPosition;
}

/**
 * Input of the Contact's email address.
 */
export interface ContactsInputEmailAddress {
  /** The email address. */
  email: string;
  /** Unique ID of the latest version of an existing resorce. */
  etag?: string;
  /** Indicates whether this phone number is default within other channels of the same type(phone). */
  primary?: boolean;
  type?: WebitelcontactsLookup;
  verified?: boolean;
}

/**
 * An input of the Contact's groups.
 */
export interface ContactsInputContactGroup {
  /** Unique ID of the latest version of an existing resource. */
  etag: string;
  /** Group of contacts associated. */
  group?: WebitelcontactsLookup;
}

/**
 * Input of the contact IM client.
 */
export interface ContactsInputIMClient {
  /** Id of Agent created this IM client. */
  createdBy?: string;
  externalUser?: string;
  /** App (Text-Gateway) used to connect the IM client. */
  gatewayId?: string;
  protocol?: string;
  /** [Via] App(-specific) peer(-id) to connect[from] the IM client. */
  via?: string;
}

/**
 * A Contact's associated Tag.
Output purpose only.
 */
export interface ContactsInputLabel {
  /** Unique ID of the latest version of an existing resorce. */
  etag?: string;
  /** REQUIRED. Hashtag value;
NOTE: Keep in mind, hashtags are not case-sensitive,
but adding capital letters does make them easier to read:
#MakeAWish vs. #makeawish. */
  label?: string;
}

/**
 * An input of the Contact's language.
 */
export interface ContactsInputLanguage {
  /** Unique ID of the latest version of an existing association. */
  etag: string;
  /** Indicates whether this association must be default
among others of the same type. */
  primary?: boolean;
  tag?: string;
}

export interface ContactsInputManager {
  /** Unique ID of the latest version of an existing resource. */
  etag: string;
  /** Indicates whether this association must be default among others. */
  primary?: boolean;
  /** Responsible User. */
  user?: WebitelcontactsLookup;
}

export interface ContactsInputName {
  /** REQUIRED. End-User's full name in displayable form
including all name parts, possibly including titles and suffixes,
ordered according to the End-User's locale and preferences. */
  commonName?: string;
  familyName?: string;
  givenName?: string;
  /** OPTIONAL. Middle name(s) of the End-User.
Note that in some cultures, people can have multiple middle names;
all can be present, with the names being separated by space characters.
Also note that in some cultures, middle names are not used. */
  middleName?: string;
  /** Indicate whether Contact, as a Person, realy owns this associated name. */
  verified?: boolean;
}

/**
 * Input of the contact phone number.
 */
export interface ContactsInputPhoneNumber {
  /** Unique ID of the latest version of an existing resorce. */
  etag?: string;
  /** The phone number. */
  number: string;
  /** Indicates whether this phone number is default within other channels of the same type(phone). */
  primary?: boolean;
  type?: WebitelcontactsLookup;
  verified?: boolean;
}

/**
 * Input of the photo.
 */
export interface ContactsInputPhoto {
  /** Unique ID of the latest version of an existing association. */
  etag?: string;
  photoId?: string;
  photoUrl?: string;
  /** True if the photo is a default photo; false if the photo is a user-provided photo. */
  primary?: boolean;
}

/**
 * An input of the Contact's timezones.
 */
export interface ContactsInputTimezone {
  /** Unique ID of the latest version of an existing resource. */
  etag: string;
  /** Indicates whether this association must be default among others. */
  primary?: boolean;
  /** Timezone dictionary reference value associated. */
  timezone?: WebitelcontactsLookup;
}

/**
 * Input of the Contact's variable.
 */
export interface ContactsInputVariable {
  /** Unique ID of the latest version of an existing resorce. */
  etag?: string;
  /**
   * NEW Key.
   * @pattern ^\w+$
   */
  key: string;
  /** NEW Value. */
  value?: unknown;
}

/**
 * The Contact principal input.
 */
export interface ContactsInputContact {
  /** BIO. Short description about the Contact person.
OPTIONAL. Multi-lined text. */
  about?: string;
  /** Publish NEW comment(s) for this Contact. */
  comments?: ContactsInputComment[];
  /** The Contact's email address(es). */
  emails?: ContactsInputEmailAddress[];
  /** Unique ID of the latest version of an existing resorce. */
  etag?: string;
  /** The Contact's associated group(s). */
  groups?: ContactsInputContactGroup[];
  /** The contact's [I]nstant[M]essaging clients. */
  imclients?: ContactsInputIMClient[];
  /** The Contact's associated label(s). */
  labels?: ContactsInputLabel[];
  /** A Contact's locale preference(s). */
  languages?: ContactsInputLanguage[];
  /** The Contact's internal manager(s). */
  managers?: ContactsInputManager[];
  name?: ContactsInputName;
  /** The Contact's phone numbers. */
  phones?: ContactsInputPhoneNumber[];
  /** Output only. The Contact's photo(s). */
  readonly photos?: readonly ContactsInputPhoto[];
  /** The Contact's timezone preference(s). */
  timezones?: ContactsInputTimezone[];
  /** Arbitrary client data that is populated by clients. */
  variables?: ContactsInputVariable[];
}

export interface ContactsInputGroup {
  /** The new description of the group. */
  description?: string;
  /** The new enabled status of the group. */
  enabled?: boolean;
  /** The new name of the group. */
  name?: string;
}

export interface ContactsLabelInfo {
  /** Label tag.

Count of sources.
int32 count = 2;
 Sources of Contacts assigned.
repeated string sources = 3; */
  label?: string;
}

/**
 * LabelTags dataset list of label's info.
 */
export interface ContactsLabelTags {
  labels?: ContactsLabelInfo[];
  next?: boolean;
  /** Page number of partial result. */
  page?: number;
  sources?: WebitelcontactsLookup[];
}

/**
 * Response message for locating a condition by ID.
 */
export interface ContactsLocateConditionResponse {
  condition?: ContactsCondition;
}

/**
 * Response message for locating a dynamic group by ID.
 */
export interface ContactsLocateDynamicGroupResponse {
  group?: ContactsDynamicGroup;
}

/**
 * Response message for locating a group.
 */
export interface ContactsLocateGroupResponse {
  /** The located group. */
  group?: ContactsGroup;
}

export interface ContactsTimeRange {
  /** Since timestamp(milli). Not before. */
  since?: string;
  /** Until timestamp(milli). Not after. */
  until?: string;
}

export type DataDatasetDataItem = { [key: string]: unknown };

export interface DataLookupValue {
  /** Required. Unique Identifier. */
  id?: string;
  /** Readonly. Display name. */
  name?: string;
  /** Optional. Reference type. */
  type?: string;
}

export type TypeBinaryViolation = {[key: string]: string};

export interface TypeBinary {
  maxBytes?: number;
  violation?: TypeBinaryViolation;
}

export interface TypeBool { [key: string]: unknown }

/**
 * Datetime type settings.

enum Part {
   full = 0; // date & time
   date = 1; // date only ; YYYY-MM-DD
   time = 2; // time only ; HH:mm:ss[.pres]
 }
 Part part = 1; // part of: [ date &| time ]
 enum Stamp {
   s  =  0; // seconds
   ms =  1; // [milli]seconds ; E+3
   mc =  2; // [micro]seconds ; E+6
   ns =  3; // [nano]seconds  ; E+9
   m  = -1; // minutes
   h  = -2; // hours
 }
 Stamp time = 2; // time precision
 string zone = 3; // ??? [ Europe/Kyiv | +03:00 ]
 */
export interface TypeDatetime {
  /** Epoch timestamp.
If zero - UNIX epoch (1970-01-01 00:00:00) will be used. */
  epoch?: number;
  format?: string;
  /** Timezone associated.
Default: `UTC`. */
  zone?: string;
}

export type TypeDurationViolation = {[key: string]: string};

export interface TypeDuration {
  format?: string;
  max?: string;
  min?: string;
  violation?: TypeDurationViolation;
}

export type TypeFloatViolation = {[key: string]: string};

export interface TypeFloat {
  frac?: number;
  max?: number;
  min?: number;
  violation?: TypeFloatViolation;
}

export type TypeIntViolation = {[key: string]: string};

export interface TypeInt {
  max?: string;
  min?: string;
  violation?: TypeIntViolation;
}

/**
 * Kind of primitive data types.

 - none: option allow_alias = true;
 - list: [array]
 - int: int32
 - uint: uint32
 - float: float32
 - datetime: date &| time
 */
export type TypeKind = typeof TypeKind[keyof typeof TypeKind];


export const TypeKind = {
  None: 'none',
  List: 'list',
  Bool: 'bool',
  Int: 'int',
  Int32: 'int32',
  Int64: 'int64',
  Uint: 'uint',
  Uint32: 'uint32',
  Uint64: 'uint64',
  Float: 'float',
  Float32: 'float32',
  Float64: 'float64',
  Binary: 'binary',
  Lookup: 'lookup',
  String: 'string',
  Richtext: 'richtext',
  Datetime: 'datetime',
  Duration: 'duration',
} as const;

export type DatatypeLookupQuery = {[key: string]: string};

export type DatatypeLookupViolation = {[key: string]: string};

/**
 * Lookup ( REFERENCE ) type descriptor.
Simplified [webitel.custom.Struct] options.
 */
export interface DatatypeLookup {
  /** [Readonly]. Display dataset field.
(lookup).{`name`} value relation. */
  display?: string;
  /** [Readonly]. Dataset title. */
  name?: string;
  /** [Required]. Reference dataset relative path
e.g.: "contacts", "dictionaries/cities".
(lookup).{`type`} value relation. */
  path?: string;
  /** [Readonly]. Primary dataset field.
(lookup).{`id`} value relation. */
  primary?: string;
  query?: DatatypeLookupQuery;
  violation?: DatatypeLookupViolation;
}

export type TypeTextViolation = {[key: string]: string};

export interface TypeText {
  maxBytes?: number;
  maxChars?: number;
  multiline?: boolean;
  violation?: TypeTextViolation;
}

export type TypeUintViolation = {[key: string]: string};

export interface TypeUint {
  max?: string;
  min?: string;
  violation?: TypeUintViolation;
}

/**
 * Field of the struct.
 */
export interface DataField {
  /** Always signifies that the field value will be computed on any write (INSERT OR UPDATE) operations.
The field cannot be written to, and when read the result of the last generated expression will be returned.

The generation expression can refer to other columns in the table, but not other generated columns. Any functions and operators used must be immutable. References to other tables are not allowed. */
  always?: unknown;
  binary?: TypeBinary;
  bool?: TypeBool;
  datetime?: TypeDatetime;
  /** The `default` expression will be used in `INSERT` operation
that does not specify a value for the field.

If there is no default for a field, then the default is null. */
  default?: unknown;
  disabled?: boolean;
  duration?: TypeDuration;
  float?: TypeFloat;
  float32?: TypeFloat;
  float64?: TypeFloat;
  hidden?: boolean;
  /** Short description. Default: {name}. */
  hint?: string;
  /** Field [code] name.

code */
  id?: string;
  int?: TypeInt;
  int32?: TypeInt;
  int64?: TypeInt;
  /** Required. The field type. */
  kind?: TypeKind;
  lookup?: DatatypeLookup;
  /** Title of the field. Lang specific.

title */
  name?: string;
  /** Optional. Disable any write (INSERT OR UPDATE) operations.
READONLY signifies that the field value will be always computed on any write (INSERT OR UPDATE) operations.
If selected, the `default` value MUST be specified.

FIXME: Is base field ? [ id, created_, updated_ ] */
  readonly?: boolean;
  required?: boolean;
  richtext?: TypeText;
  string?: TypeText;
  uint?: TypeUint;
  uint32?: TypeUint;
  uint64?: TypeUint;
}

/**
 * INDEX [struct.fields].
 */
export interface DataIndex {
  /** A set of [struct.fields.id] to INDEX within [type] dataset. */
  fields?: string[];
  /** A set of [struct.fields.id] to INCLUDE beside the [fields] index. */
  include?: string[];
  /** Indicates whether set of [fields] MUST be UNIQUE within [type]. */
  unique?: boolean;
}

/**
 * INDEX fields.

Extension extension = 15;
 */
export type ProtodataStructIndexes = {[key: string]: DataIndex};

/**
 * Type of the Structure.

int64 dc = 0;
 */
export interface ProtodataStruct {
  /** Optional. Short description. */
  about?: string;
  administered?: boolean;
  createdAt?: string;
  createdBy?: DataLookupValue;
  /** Required. Display [fields.id] key.
Used as [lookup].name setting for this [struct] type. */
  display?: string;
  /** // Extension fields type.
 Extension extension = 23; */
  extendable?: boolean;
  /** Fields of the struct type. */
  fields?: DataField[];
  /** Deprecated. Use `repo` instead. The [type] name (singular form), e.g.: `country`. */
  id?: string;
  /** INDEX fields.

Extension extension = 15; */
  indexes?: ProtodataStructIndexes;
  /** A User-friendly [id] name ; lang: specific. */
  name?: string;
  /** Readonly. RbAC objclass identity. */
  objclass?: string;
  /** Readonly. Relative path to access the dataset APIs, e.g.: `dictionaries/countries`. */
  path?: string;
  /** Required. Primary [fields.id] key.
Used as [lookup].id setting for this [struct] type. */
  primary?: string;
  readonly?: boolean;
  /** Repository (dataset) name (plural form), e.g.: `countries`. */
  repo?: string;
  updatedAt?: string;
  updatedBy?: DataLookupValue;
}

/**
 * Dataset records page view.
 */
export interface DataDataset {
  /** List of the dataset page records. */
  data?: DataDatasetDataItem[];
  next?: boolean;
  /** Current page number. */
  page?: number;
  /** Type of the dataset record. */
  type?: ProtodataStruct;
}

/**
 * INDEX fields.
 */
export type DataInputDictionaryIndexes = {[key: string]: DataIndex};

export interface DataInputDictionary {
  about?: string;
  administered?: boolean;
  /** Required. Display [fields.id] key.
Used as [lookup].name setting for this [struct] type. */
  display?: string;
  fields?: DataField[];
  /** INDEX fields. */
  indexes?: DataInputDictionaryIndexes;
  /** A User-friendly [type.id] name ; lang: specific. */
  name?: string;
  /** Required. Primary [fields.id] key.
Used as [lookup].id setting for this [struct] type. */
  primary?: string;
  /** string id = 1; // The [type] name (singular form), e.g.: `country`.

Repository (dataset) name (plural form), e.g.: `countries`. */
  repo?: string;
}

export type DataInputExtensionIndices = {[key: string]: DataIndex};

export interface DataInputExtension {
  fields?: DataField[];
  indices?: DataInputExtensionIndices;
}

/**
 * Dataset of structured types.
 */
export interface DataStructList {
  /** List of `Struct` types. */
  data?: ProtodataStruct[];
  next?: boolean;
  /** Page number of results. */
  page?: number;
}

export interface EngineAcceptOfDay {
  day?: number;
  disabled?: boolean;
  endTimeOfDay?: number;
  startTimeOfDay?: number;
}

export type EngineActiveCallVariables = {[key: string]: string};

export interface EngineLookup {
  id?: string;
  name?: string;
}

export interface EngineEndpoint {
  id?: string;
  name?: string;
  number?: string;
  type?: string;
}

export interface EngineActiveCall {
  agent?: EngineLookup;
  answeredAt?: string;
  appId?: string;
  billSec?: number;
  blindTransfer?: string;
  bridgedAt?: string;
  bridgedId?: string;
  createdAt?: string;
  destination?: string;
  direction?: string;
  display?: string;
  duration?: number;
  extension?: string;
  from?: EngineEndpoint;
  gateway?: EngineLookup;
  holdSec?: number;
  id?: string;
  joinedAt?: string;
  leavingAt?: string;
  member?: EngineLookup;
  parentId?: string;
  queue?: EngineLookup;
  queueBridgedAt?: string;
  queueDurationSec?: number;
  queueWaitSec?: number;
  reportingAt?: string;
  reportingSec?: number;
  state?: string;
  supervisor?: EngineLookup[];
  team?: EngineLookup;
  timestamp?: string;
  to?: EngineEndpoint;
  type?: string;
  user?: EngineLookup;
  variables?: EngineActiveCallVariables;
  waitSec?: number;
}

export interface EngineActivityWorkspaceWidgetResponse {
  available?: number;
  avgHoldSec?: number;
  avgTalkSec?: number;
  callAbandoned?: number;
  callDialerQueue?: number;
  callHandled?: number;
  callInbound?: number;
  callInboundQueue?: number;
  callManual?: number;
  callMissed?: number;
  callQueueMissed?: number;
  chatAccepts?: number;
  chatAht?: number;
  occupancy?: number;
  online?: number;
  processing?: number;
  queueTalkSec?: number;
  scoreCount?: string;
  scoreOptionalAvg?: number;
  scoreOptionalSum?: number;
  scoreRequiredAvg?: number;
  scoreRequiredSum?: number;
  sumTalkSec?: string;
  taskAccepts?: number;
  utilization?: number;
  voiceMail?: number;
}

export interface EngineAgentChannel {
  channel?: string;
  joinedAt?: string;
  state?: string;
  timeout?: string;
}

export interface EngineAgentUserPresence {
  status?: string;
}

export interface EngineAgent {
  allowChannels?: string[];
  allowSetScreenControl?: boolean;
  auditor?: EngineLookup[];
  channel?: EngineAgentChannel[];
  chatCount?: number;
  description?: string;
  extension?: string;
  greetingMedia?: EngineLookup;
  id?: string;
  isSupervisor?: boolean;
  lastStatusChange?: string;
  name?: string;
  progressiveCount?: number;
  region?: EngineLookup;
  screenControl?: boolean;
  skills?: EngineLookup[];
  status?: string;
  statusDuration?: string;
  supervisor?: EngineLookup[];
  taskCount?: number;
  team?: EngineLookup;
  user?: EngineLookup;
  userPresenceStatus?: EngineAgentUserPresence;
}

export interface EngineAgentCallStatistics {
  abandoned?: number;
  avgHoldSec?: number;
  avgTalkSec?: number;
  chatAccepts?: number;
  chatAht?: number;
  count?: number;
  handles?: number;
  maxHoldSec?: number;
  maxTalkSec?: number;
  minHoldSec?: number;
  minTalkSec?: number;
  name?: string;
  occupancy?: number;
  sumHoldSec?: number;
  sumTalkSec?: number;
  utilization?: number;
}

export interface EngineAgentCallStatisticsList {
  items?: EngineAgentCallStatistics[];
  next?: boolean;
}

export interface EngineAgentInQueueAgentsInQueue {
  allowPause?: number;
  free?: number;
  offline?: number;
  online?: number;
  pause?: number;
  total?: number;
}

export interface EngineAgentInQueue {
  activeMembers?: number;
  agents?: EngineAgentInQueueAgentsInQueue;
  countMembers?: number;
  enabled?: boolean;
  maxMemberLimit?: number;
  priority?: number;
  queue?: EngineLookup;
  strategy?: string;
  type?: number;
  waitingMembers?: number;
}

export interface EngineAgentInQueueStatisticsAgentInQueueStatisticsItem {
  bucket?: EngineLookup;
  memberWaiting?: number;
  skill?: EngineLookup;
}

export interface EngineAgentInQueueStatistics {
  queue?: EngineLookup;
  statistics?: EngineAgentInQueueStatisticsAgentInQueueStatisticsItem[];
}

export interface EngineAgentInQueueStatisticsList {
  items?: EngineAgentInQueueStatistics[];
}

export interface EngineAgentInTeam {
  strategy?: string;
  team?: EngineLookup;
}

export interface EngineAgentPauseCause {
  allowAdmin?: boolean;
  allowAgent?: boolean;
  allowSupervisor?: boolean;
  createdAt?: string;
  createdBy?: EngineLookup;
  description?: string;
  id?: number;
  limitMin?: number;
  name?: string;
  updatedAt?: string;
  updatedBy?: EngineLookup;
}

export interface EngineAgentPauseCauseServicePatchAgentPauseCauseBody {
  allowAdmin?: boolean;
  allowAgent?: boolean;
  allowSupervisor?: boolean;
  description?: string;
  fields?: string[];
  limitMin?: number;
  name?: string;
}

export interface EngineAgentPauseCauseServiceUpdateAgentPauseCauseBody {
  allowAdmin?: boolean;
  allowAgent?: boolean;
  allowSupervisor?: boolean;
  description?: string;
  limitMin?: number;
  name?: string;
}

export interface EngineAgentServiceAgentSetStateBody { [key: string]: unknown }

export interface EngineAgentServicePatchAgentBody {
  allowChannels?: string[];
  auditor?: EngineLookup[];
  chatCount?: number;
  description?: string;
  fields?: string[];
  greetingMedia?: EngineLookup;
  isSupervisor?: boolean;
  progressiveCount?: number;
  region?: EngineLookup;
  screenControl?: boolean;
  supervisor?: EngineLookup[];
  team?: EngineLookup;
  user?: EngineLookup;
}

export interface EngineAgentServiceUpdateAgentBody {
  allowChannels?: string[];
  auditor?: EngineLookup[];
  chatCount?: number;
  description?: string;
  domainId?: string;
  greetingMedia?: EngineLookup;
  isSupervisor?: boolean;
  progressiveCount?: number;
  region?: EngineLookup;
  screenControl?: boolean;
  supervisor?: EngineLookup[];
  taskCount?: number;
  team?: EngineLookup;
  user?: EngineLookup;
}

export interface EngineAgentServiceUpdateAgentStatusBody {
  channels?: string[];
  domainId?: string;
  onDemand?: boolean;
  payload?: string;
  status?: string;
  statusComment?: string;
}

export interface EngineAgentSetStateResponse { [key: string]: unknown }

export interface EngineAgentSkill {
  agent?: EngineLookup;
  capacity?: number;
  createdAt?: string;
  createdBy?: EngineLookup;
  domainId?: string;
  enabled?: boolean;
  id?: string;
  skill?: EngineLookup;
  updatedAt?: string;
  updatedBy?: EngineLookup;
}

export interface EngineAgentSkillItem {
  capacity?: number;
  enabled?: boolean;
  id?: string;
  skill?: EngineLookup;
}

export interface EngineAgentSkillServiceCreateAgentSkillBody {
  capacity?: number;
  domainId?: string;
  enabled?: boolean;
  skill?: EngineLookup;
}

export interface EngineCreateAgentSkillBulkItem {
  capacity?: number;
  domainId?: string;
  enabled?: boolean;
  skill?: EngineLookup;
}

export interface EngineAgentSkillServiceCreateAgentSkillsBody {
  items?: EngineCreateAgentSkillBulkItem[];
}

export interface EngineAgentSkillServicePatchAgentSkillBody {
  capacity?: number;
  domainId?: string;
  enabled?: boolean;
  fields?: string[];
  skill?: EngineLookup;
}

export interface EngineAgentSkillServicePatchAgentSkillsBody {
  capacity?: number;
  enabled?: boolean;
  fields?: string[];
  id?: string[];
  skillId?: string[];
}

export interface EngineAgentSkillServiceUpdateAgentSkillBody {
  capacity?: number;
  domainId?: string;
  enabled?: boolean;
  skill?: EngineLookup;
}

export interface EngineAgentState {
  agent?: EngineLookup;
  channel?: string;
  duration?: string;
  id?: string;
  joinedAt?: string;
  leavedAt?: string;
  pauseCause?: string;
  payload?: string;
  queue?: EngineLookup;
  state?: string;
}

export interface EngineAgentStatsStatistic {
  activeCallId?: string;
  agentId?: number;
  auditor?: EngineLookup[];
  callTime?: string;
  chatCount?: number;
  chatTime?: string;
  descTrack?: boolean;
  extension?: string;
  handles?: number;
  maxBridgedAt?: string;
  maxOfferingAt?: string;
  missed?: number;
  name?: string;
  occupancy?: number;
  offline?: string;
  online?: string;
  pause?: string;
  pauseCause?: string;
  queues?: EngineLookup[];
  screenControl?: boolean;
  skills?: EngineLookup[];
  status?: string;
  statusComment?: string;
  statusDuration?: string;
  supervisor?: EngineLookup[];
  team?: EngineLookup;
  transferred?: number;
  user?: EngineLookup;
  utilization?: number;
}

export interface EngineAgentStatusStatisticItem {
  agentId?: number;
  auditor?: EngineLookup[];
  chatCount?: number;
  descTrack?: boolean;
  extension?: string;
  name?: string;
  offline?: string;
  online?: string;
  pause?: string;
  pauseCause?: string;
  progressiveCount?: number;
  region?: EngineLookup;
  scoreCount?: string;
  scoreOptionalAvg?: number;
  scoreRequiredAvg?: number;
  screenControl?: boolean;
  status?: string;
  statusComment?: string;
  statusDuration?: string;
  supervisor?: EngineLookup[];
  team?: EngineLookup;
  user?: EngineLookup;
}

export interface EngineAgentTeam {
  admin?: EngineLookup[];
  callTimeout?: number;
  description?: string;
  domainId?: string;
  forecastCalculation?: EngineLookup;
  id?: string;
  inviteChatTimeout?: number;
  maxNoAnswer?: number;
  name?: string;
  noAnswerDelayTime?: number;
  screenControl?: boolean;
  strategy?: string;
  taskAcceptTimeout?: number;
  updatedAt?: string;
  wrapUpTime?: number;
}

export interface EngineAgentTeamServiceUpdateAgentTeamBody {
  admin?: EngineLookup[];
  callTimeout?: number;
  description?: string;
  domainId?: string;
  forecastCalculation?: EngineLookup;
  inviteChatTimeout?: number;
  maxNoAnswer?: number;
  name?: string;
  noAnswerDelayTime?: number;
  screenControl?: boolean;
  strategy?: string;
  taskAcceptTimeout?: number;
  wrapUpTime?: number;
}

export interface EngineAgentTodayStatisticsResponse {
  available?: number;
  avgHoldSec?: number;
  avgTalkSec?: number;
  callAbandoned?: number;
  callDialerQueue?: number;
  callHandled?: number;
  callInbound?: number;
  callInboundQueue?: number;
  callManual?: number;
  callMissed?: number;
  callQueueMissed?: number;
  chatAccepts?: number;
  chatAht?: number;
  occupancy?: number;
  online?: number;
  processing?: number;
  queueTalkSec?: number;
  scoreCount?: string;
  scoreOptionalAvg?: number;
  scoreOptionalSum?: number;
  scoreRequiredAvg?: number;
  scoreRequiredSum?: number;
  sumTalkSec?: string;
  taskAccepts?: number;
  utilization?: number;
  voiceMail?: number;
}

export interface EngineAgentUser {
  id?: string;
  name?: string;
}

export type EngineAggregateHistoryCallRequestVariables = {[key: string]: string};

export interface EngineAggregateRequestGroup {
  aggregate?: string;
  desc?: boolean;
  field?: string;
  id?: string;
  interval?: string;
  top?: number;
}

export interface EngineAggregateRequest {
  avg?: string[];
  count?: string[];
  group?: EngineAggregateRequestGroup[];
  limit?: number;
  max?: string[];
  min?: string[];
  name?: string;
  sort?: string[];
  sum?: string[];
}

export interface EngineFilterBetween {
  from?: string;
  to?: string;
}

export interface EngineAggregateHistoryCallRequest {
  tags?: string[];
  agentDescription?: string;
  agentId?: string[];
  aggs?: EngineAggregateRequest[];
  amdResult?: string[];
  answeredAt?: EngineFilterBetween;
  cause?: string[];
  contactId?: string[];
  createdAt?: EngineFilterBetween;
  dependencyId?: string;
  direction?: string;
  directions?: string[];
  domainId?: string;
  duration?: EngineFilterBetween;
  fts?: string;
  gatewayId?: string[];
  hasFile?: boolean;
  hasTranscript?: boolean;
  id?: string[];
  memberId?: string[];
  missed?: boolean;
  number?: string;
  page?: number;
  parentId?: string;
  q?: string;
  queueId?: string[];
  size?: number;
  skipParent?: boolean;
  storedAt?: EngineFilterBetween;
  teamId?: string[];
  transferFrom?: string[];
  transferTo?: string[];
  userId?: string[];
  variables?: EngineAggregateHistoryCallRequestVariables;
}

export interface EngineAggregateResult {
  name?: string;
}

export type EngineAttemptVariables = {[key: string]: string};

export interface EngineMemberCommunication {
  attempts?: number;
  description?: string;
  destination?: string;
  display?: string;
  dtmf?: string;
  id?: string;
  lastActivityAt?: string;
  lastCause?: string;
  priority?: number;
  resource?: EngineLookup;
  state?: number;
  stopAt?: string;
  type?: EngineLookup;
}

export interface EngineAttempt {
  agent?: EngineLookup;
  agentCallId?: string;
  attempts?: number;
  bridgedAt?: string;
  bucket?: EngineLookup;
  channel?: string;
  destination?: EngineMemberCommunication;
  display?: string;
  id?: string;
  joinedAt?: string;
  lastStateChange?: string;
  leavingAt?: string;
  list?: EngineLookup;
  member?: EngineLookup;
  memberCallId?: string;
  offeringAt?: string;
  position?: number;
  queue?: EngineLookup;
  reportingAt?: string;
  resource?: EngineLookup;
  result?: string;
  state?: string;
  timeout?: string;
  variables?: EngineAttemptVariables;
}

export type EngineAttemptHistoryVariables = {[key: string]: string};

export interface EngineAttemptHistory {
  agent?: EngineLookup;
  agentCallId?: string;
  amdResult?: string;
  attempts?: number;
  bridgedAt?: string;
  bucket?: EngineLookup;
  channel?: string;
  destination?: EngineMemberCommunication;
  display?: string;
  id?: string;
  joinedAt?: string;
  leavingAt?: string;
  list?: EngineLookup;
  member?: EngineLookup;
  memberCallId?: string;
  offeredAgents?: EngineLookup[];
  offeringAt?: string;
  position?: number;
  queue?: EngineLookup;
  reportingAt?: string;
  resource?: EngineLookup;
  result?: string;
  variables?: EngineAttemptHistoryVariables;
}

export interface EngineAttemptRenewalResultResponse { [key: string]: unknown }

export interface EngineAttemptResultResponse {
  status?: string;
}

export interface EngineQuestionOption {
  name?: string;
  score?: number;
}

export type EngineAuditQuestionType = typeof EngineAuditQuestionType[keyof typeof EngineAuditQuestionType];


export const EngineAuditQuestionType = {
  QuestionDefault: 'question_default',
  QuestionScore: 'question_score',
  QuestionOption: 'question_option',
  QuestionYes: 'question_yes',
} as const;

export interface EngineQuestion {
  criticalViolation?: boolean;
  description?: string;
  max?: number;
  min?: number;
  options?: EngineQuestionOption[];
  question?: string;
  required?: boolean;
  type?: EngineAuditQuestionType;
}

export interface EngineAuditForm {
  createdAt?: string;
  createdBy?: EngineLookup;
  description?: string;
  editable?: boolean;
  enabled?: boolean;
  id?: number;
  name?: string;
  questions?: EngineQuestion[];
  teams?: EngineLookup[];
  updatedAt?: string;
  updatedBy?: EngineLookup;
}

export interface EngineAuditFormServicePatchAuditFormBody {
  description?: string;
  enabled?: boolean;
  fields?: string[];
  name?: string;
  questions?: EngineQuestion[];
  teams?: EngineLookup[];
}

export interface EngineAuditFormServiceUpdateAuditFormBody {
  description?: string;
  enabled?: boolean;
  name?: string;
  questions?: EngineQuestion[];
  teams?: EngineLookup[];
}

export interface EngineUpdateQuestionAnswerRequest {
  comment?: string;
  score?: number;
}

export interface EngineAuditFormServiceUpdateAuditRateBody {
  answers?: EngineUpdateQuestionAnswerRequest[];
  comment?: string;
}

export interface EngineQuestionAnswer {
  comment?: string;
  score?: number;
  updatedAt?: string;
  updatedBy?: EngineLookup;
}

export interface EngineAuditRate {
  answers?: EngineQuestionAnswer[];
  comment?: string;
  createdAt?: string;
  createdBy?: EngineLookup;
  criticalCount?: string;
  form?: EngineLookup;
  id?: string;
  questions?: EngineQuestion[];
  ratedUser?: EngineLookup;
  scoreOptional?: number;
  scoreRequired?: number;
  selectYesCount?: string;
  updatedAt?: string;
  updatedBy?: EngineLookup;
}

export interface EngineAvailableSystemSetting {
  name?: string;
}

export interface EngineBlindTransferCallResponse { [key: string]: unknown }

export interface EngineBucket {
  description?: string;
  id?: string;
  name?: string;
}

export interface EngineBucketServiceUpdateBucketBody {
  description?: string;
  domainId?: string;
  name?: string;
}

export interface EngineExceptDate {
  date?: string;
  disabled?: boolean;
  name?: string;
  repeat?: boolean;
  workStart?: number;
  workStop?: number;
  working?: boolean;
}

export interface EngineCalendar {
  accepts?: EngineAcceptOfDay[];
  createdAt?: string;
  createdBy?: EngineLookup;
  description?: string;
  domainId?: string;
  endAt?: string;
  excepts?: EngineExceptDate[];
  id?: string;
  name?: string;
  specials?: EngineAcceptOfDay[];
  startAt?: string;
  timezone?: EngineLookup;
  updatedAt?: string;
  updatedBy?: EngineLookup;
}

export interface EngineCalendarServiceUpdateCalendarBody {
  accepts?: EngineAcceptOfDay[];
  description?: string;
  domainId?: string;
  endAt?: string;
  excepts?: EngineExceptDate[];
  name?: string;
  specials?: EngineAcceptOfDay[];
  startAt?: string;
  timezone?: EngineLookup;
}

export interface EngineCallAnnotation {
  callId?: string;
  createdAt?: string;
  createdBy?: EngineLookup;
  endSec?: number;
  id?: string;
  note?: string;
  startSec?: number;
  updatedAt?: string;
  updatedBy?: EngineLookup;
}

export type EngineCallFileType = typeof EngineCallFileType[keyof typeof EngineCallFileType];


export const EngineCallFileType = {
  FileTypeEmpty: 'file_type_empty',
  FileTypeScreenshot: 'file_type_screenshot',
  FileTypeScreensharing: 'file_type_screensharing',
  FileTypeAudio: 'file_type_audio',
  FileTypeVideo: 'file_type_video',
  FileTypePdf: 'file_type_pdf',
} as const;

export interface EngineCallFile {
  channel?: string;
  id?: string;
  mimeType?: string;
  name?: string;
  size?: string;
  startAt?: string;
  startRecord?: string;
  stopAt?: string;
  type?: EngineCallFileType;
}

export interface EngineCallHold {
  sec?: number;
  start?: string;
  stop?: string;
}

export interface EngineCallServiceBlindTransferCallBody {
  appId?: string;
  destination?: string;
  domainId?: string;
}

export interface EngineCallServiceCreateCallAnnotationBody {
  endSec?: number;
  note?: string;
  startSec?: number;
}

export interface EngineCallServiceDtmfCallBody {
  appId?: string;
  digit?: string;
  domainId?: string;
}

export interface EngineEavesdropCallRequestEndpointRequest {
  appId?: string;
  extension?: string;
  id?: string;
  type?: string;
}

export interface EngineCallServiceEavesdropCallBody {
  appId?: string;
  control?: boolean;
  from?: EngineEavesdropCallRequestEndpointRequest;
  listenA?: boolean;
  listenB?: boolean;
  whisperA?: boolean;
  whisperB?: boolean;
}

export interface EngineCallServiceHangupCallBody {
  appId?: string;
  cause?: string;
  domainId?: string;
}

export interface EngineCallServiceHoldCallBody {
  appId?: string;
  domainId?: string;
}

export type EngineCallServicePatchHistoryCallBodyVariables = {[key: string]: string};

export interface EngineCallServicePatchHistoryCallBody {
  hideMissed?: boolean;
  variables?: EngineCallServicePatchHistoryCallBodyVariables;
}

export interface EngineCallServiceRedialCallBody { [key: string]: unknown }

export type EngineCallServiceSetVariablesCallBodyVariables = {[key: string]: string};

export interface EngineCallServiceSetVariablesCallBody {
  variables?: EngineCallServiceSetVariablesCallBodyVariables;
}

export interface EngineCallServiceUnHoldCallBody {
  appId?: string;
  domainId?: string;
}

export interface EngineCallServiceUpdateCallAnnotationBody {
  endSec?: number;
  note?: string;
  startSec?: number;
}

export interface EngineChatPlan {
  description?: string;
  enabled?: boolean;
  id?: number;
  name?: string;
  schema?: EngineLookup;
}

export type EngineCommunicationChannels = typeof EngineCommunicationChannels[keyof typeof EngineCommunicationChannels];


export const EngineCommunicationChannels = {
  Undefined: 'Undefined',
  Phone: 'Phone',
  Email: 'Email',
  Messaging: 'Messaging',
} as const;

export interface EngineCommunicationType {
  channel?: EngineCommunicationChannels;
  code?: string;
  default?: boolean;
  description?: string;
  domainId?: string;
  id?: string;
  name?: string;
}

export interface EngineCommunicationTypeRequest {
  channel?: EngineCommunicationChannels;
  code?: string;
  default?: boolean;
  description?: string;
  name?: string;
}

export interface EngineCommunicationTypeServicePatchCommunicationTypeBody {
  channel?: EngineCommunicationChannels;
  code?: string;
  default?: boolean;
  description?: string;
  fields?: string[];
  name?: string;
}

export interface EngineCommunicationTypeServiceUpdateCommunicationTypeBody {
  channel?: EngineCommunicationChannels;
  code?: string;
  default?: boolean;
  description?: string;
  name?: string;
}

export interface EngineConfirmPushResponse { [key: string]: unknown }

export interface EngineCreateAgentPauseCauseRequest {
  allowAdmin?: boolean;
  allowAgent?: boolean;
  allowSupervisor?: boolean;
  description?: string;
  limitMin?: number;
  name?: string;
}

export interface EngineCreateAgentRequest {
  allowChannels?: string[];
  auditor?: EngineLookup[];
  chatCount?: number;
  description?: string;
  domainId?: string;
  greetingMedia?: EngineLookup;
  isSupervisor?: boolean;
  progressiveCount?: number;
  region?: EngineLookup;
  screenControl?: boolean;
  supervisor?: EngineLookup[];
  taskCount?: number;
  team?: EngineLookup;
  user?: EngineLookup;
}

export interface EngineCreateAgentSkillsResponse {
  ids?: string[];
}

export interface EngineCreateAgentTeamRequest {
  admin?: EngineLookup[];
  callTimeout?: number;
  description?: string;
  domainId?: string;
  forecastCalculation?: EngineLookup;
  inviteChatTimeout?: number;
  maxNoAnswer?: number;
  name?: string;
  noAnswerDelayTime?: number;
  screenControl?: boolean;
  strategy?: string;
  taskAcceptTimeout?: number;
  wrapUpTime?: number;
}

export interface EngineCreateAttemptResponse {
  attemptId?: string;
}

export interface EngineCreateQuestionAnswerRequest {
  score?: number;
}

export interface EngineCreateAuditFormRateRequest {
  answers?: EngineCreateQuestionAnswerRequest[];
  callId?: string;
  comment?: string;
  form?: EngineLookup;
}

export interface EngineCreateAuditFormRequest {
  description?: string;
  enabled?: boolean;
  name?: string;
  questions?: EngineQuestion[];
  teams?: EngineLookup[];
}

export interface EngineCreateBucketRequest {
  description?: string;
  domainId?: string;
  name?: string;
}

export interface EngineCreateCalendarRequest {
  accepts?: EngineAcceptOfDay[];
  description?: string;
  domainId?: string;
  endAt?: string;
  excepts?: EngineExceptDate[];
  name?: string;
  specials?: EngineAcceptOfDay[];
  startAt?: string;
  timezone?: EngineLookup;
}

export interface EngineCreateCallRequestEndpointRequest {
  appId?: string;
  extension?: string;
  id?: string;
  type?: string;
}

export type EngineCreateCallRequestCallSettingsVariables = {[key: string]: string};

export interface EngineCreateCallRequestCallSettings {
  audio?: boolean;
  cancelDistribute?: boolean;
  contactId?: string;
  disableAutoAnswer?: boolean;
  disableStun?: boolean;
  display?: string;
  hideNumber?: boolean;
  isOnline?: boolean;
  record?: boolean;
  screen?: boolean;
  timeout?: number;
  variables?: EngineCreateCallRequestCallSettingsVariables;
  video?: boolean;
}

export interface EngineCreateCallRequest {
  destination?: string;
  domainId?: string;
  from?: EngineCreateCallRequestEndpointRequest;
  params?: EngineCreateCallRequestCallSettings;
  to?: EngineCreateCallRequestEndpointRequest;
}

export interface EngineCreateCallResponse {
  id?: string;
}

export interface EngineCreateChatPlanRequest {
  description?: string;
  enabled?: boolean;
  name?: string;
  schema?: EngineLookup;
}

export type EngineEmailAuthType = typeof EngineEmailAuthType[keyof typeof EngineEmailAuthType];


export const EngineEmailAuthType = {
  EmailAuthTypeUndefined: 'EmailAuthTypeUndefined',
  Plain: 'Plain',
  OAuth2: 'OAuth2',
} as const;

export interface EngineEmailProfileParamsOAuth2 {
  clientId?: string;
  clientSecret?: string;
  redirectUrl?: string;
}

export interface EngineEmailProfileParams {
  oauth2?: EngineEmailProfileParamsOAuth2;
}

export interface EngineCreateEmailProfileRequest {
  authType?: EngineEmailAuthType;
  description?: string;
  enabled?: boolean;
  fetchInterval?: number;
  imapHost?: string;
  imapPort?: number;
  listen?: boolean;
  login?: string;
  mailbox?: string;
  name?: string;
  params?: EngineEmailProfileParams;
  password?: string;
  schema?: EngineLookup;
  smtpHost?: string;
  smtpPort?: number;
}

export interface EngineCreateListRequest {
  description?: string;
  domainId?: string;
  name?: string;
}

export type EngineCreateMemberBulkItemVariables = {[key: string]: string};

export interface EngineMemberCommunicationCreateRequest {
  description?: string;
  destination?: string;
  display?: string;
  dtmf?: string;
  priority?: number;
  resource?: EngineLookup;
  stopAt?: string;
  type?: EngineLookup;
}

export interface EngineCreateMemberBulkItem {
  agent?: EngineLookup;
  bucket?: EngineLookup;
  communications?: EngineMemberCommunicationCreateRequest[];
  expireAt?: string;
  minOfferingAt?: string;
  name?: string;
  priority?: number;
  skill?: EngineLookup;
  timezone?: EngineLookup;
  variables?: EngineCreateMemberBulkItemVariables;
}

export interface EngineCreateOutboundResourceDisplayRequest {
  display?: string;
  domainId?: string;
  resourceId?: string;
}

export interface EngineOutboundResourceTimeRange {
  endTimeOfDay?: number;
  startTimeOfDay?: number;
}

export interface EngineCreateOutboundResourceGroupRequest {
  communication?: EngineLookup;
  description?: string;
  domainId?: string;
  name?: string;
  strategy?: string;
  time?: EngineOutboundResourceTimeRange[];
}

export type EngineCreateOutboundResourceRequestVariables = {[key: string]: string};

export interface EngineOutboundResourceParameters {
  cidType?: string;
  ignoreEarlyMedia?: string;
}

export interface EngineCreateOutboundResourceRequest {
  parameters?: EngineOutboundResourceParameters;
  description?: string;
  enabled?: boolean;
  errorIds?: string[];
  failureDialDelay?: number;
  gateway?: EngineLookup;
  limit?: number;
  maxSuccessivelyErrors?: number;
  name?: string;
  number?: string;
  patterns?: string[];
  reserve?: boolean;
  rps?: number;
  variables?: EngineCreateOutboundResourceRequestVariables;
}

export interface EngineCreatePresetQueryRequest {
  description?: string;
  name?: string;
  section?: string;
}

export type EngineCreateQueueRequestVariables = {[key: string]: string};

export interface EngineTag {
  name?: string;
}

export interface EngineTaskProcessingProlongationOptions {
  enabled?: boolean;
  isTimeoutRetry?: boolean;
  prolongationTimeSec?: number;
  repeatsNumber?: number;
}

export interface EngineTaskProcessing {
  enabled?: boolean;
  formSchema?: EngineLookup;
  prolongationOptions?: EngineTaskProcessingProlongationOptions;
  renewalSec?: number;
  sec?: number;
}

export interface EngineCreateQueueRequest {
  tags?: EngineTag[];
  afterSchema?: EngineLookup;
  calendar?: EngineLookup;
  description?: string;
  dncList?: EngineLookup;
  doSchema?: EngineLookup;
  domainId?: string;
  enabled?: boolean;
  formSchema?: EngineLookup;
  grantee?: EngineLookup;
  name?: string;
  priority?: number;
  processing?: boolean;
  processingRenewalSec?: number;
  processingSec?: number;
  ringtone?: EngineLookup;
  schema?: EngineLookup;
  secLocateAgent?: number;
  stickyAgent?: boolean;
  strategy?: string;
  taskProcessing?: EngineTaskProcessing;
  team?: EngineLookup;
  timeout?: number;
  type?: number;
  variables?: EngineCreateQueueRequestVariables;
}

export interface EngineCreateQuickReplyRequest {
  article?: EngineLookup;
  name?: string;
  queues?: EngineLookup[];
  teams?: EngineLookup[];
  text?: string;
}

export interface EngineCreateRegionRequest {
  description?: string;
  name?: string;
  timezone?: EngineLookup;
}

export interface EngineCreateRoutingOutboundCallRequest {
  description?: string;
  disabled?: boolean;
  domainId?: string;
  name?: string;
  pattern?: string;
  schema?: EngineLookup;
}

export interface EngineSchemaTag {
  name?: string;
}

export type EngineRoutingSchemaType = typeof EngineRoutingSchemaType[keyof typeof EngineRoutingSchemaType];


export const EngineRoutingSchemaType = {
  Default: 'default',
  Voice: 'voice',
  Chat: 'chat',
  Processing: 'processing',
  Service: 'service',
} as const;

export interface EngineCreateRoutingSchemaRequest {
  tags?: EngineSchemaTag[];
  debug?: boolean;
  description?: string;
  editor?: boolean;
  name?: string;
  type?: EngineRoutingSchemaType;
}

export interface EngineCreateRoutingVariableRequest {
  domainId?: string;
  key?: string;
  value?: string;
}

export interface EngineCreateSchemaVariableRequest {
  encrypt?: boolean;
  name?: string;
}

export interface EngineSkillAgentItem {
  agent?: EngineLookup;
  capacity?: number;
  enabled?: boolean;
  id?: string;
  skill?: EngineLookup;
  team?: EngineLookup;
}

export interface EngineCreateSkillAgentResponse {
  items?: EngineSkillAgentItem[];
}

export interface EngineCreateSkillRequest {
  description?: string;
  domainId?: string;
  name?: string;
}

export type EngineSystemSettingName = typeof EngineSystemSettingName[keyof typeof EngineSystemSettingName];


export const EngineSystemSettingName = {
  EmptySystemSettingsName: 'empty_system_settings_name',
  EnableOmnichannel: 'enable_omnichannel',
  MemberChunkSize: 'member_chunk_size',
  AmdCancelNotHuman: 'amd_cancel_not_human',
  SchemeVersionLimit: 'scheme_version_limit',
  Enable2fa: 'enable_2fa',
  ExportSettings: 'export_settings',
  SearchNumberLength: 'search_number_length',
  ChatAiConnection: 'chat_ai_connection',
  PasswordRegExp: 'password_reg_exp',
  PasswordValidationText: 'password_validation_text',
  AutolinkCallToContact: 'autolink_call_to_contact',
  PeriodToPlaybackRecords: 'period_to_playback_records',
  IsFulltextSearchEnabled: 'is_fulltext_search_enabled',
  WbtHideContact: 'wbt_hide_contact',
  ShowFullContact: 'show_full_contact',
  CallEndSoundNotification: 'call_end_sound_notification',
  CallEndPushNotification: 'call_end_push_notification',
  ChatEndSoundNotification: 'chat_end_sound_notification',
  ChatEndPushNotification: 'chat_end_push_notification',
  TaskEndSoundNotification: 'task_end_sound_notification',
  TaskEndPushNotification: 'task_end_push_notification',
  PushNotificationTimeout: 'push_notification_timeout',
  LabelsToLimitContacts: 'labels_to_limit_contacts',
  AutolinkMailToContact: 'autolink_mail_to_contact',
  NewMessageSoundNotification: 'new_message_sound_notification',
  NewChatSoundNotification: 'new_chat_sound_notification',
  ScreenshotInterval: 'screenshot_interval',
  PasswordExpiryDays: 'password_expiry_days',
  PasswordMinLength: 'password_min_length',
  PasswordCategories: 'password_categories',
  PasswordContainsLogin: 'password_contains_login',
  PasswordWarningDays: 'password_warning_days',
  DefaultPassword: 'default_password',
} as const;

export interface EngineCreateSystemSettingRequest {
  name?: EngineSystemSettingName;
}

export type EngineCreateTriggerRequestVariables = {[key: string]: string};

export type EngineTriggerEventType = typeof EngineTriggerEventType[keyof typeof EngineTriggerEventType];


export const EngineTriggerEventType = {
  EmptyTriggerEvent: 'empty_trigger_event',
  Create: 'create',
  Update: 'update',
  Remove: 'remove',
  ResolutionTime: 'resolution_time',
} as const;

export type EngineTriggerObjectType = typeof EngineTriggerObjectType[keyof typeof EngineTriggerObjectType];


export const EngineTriggerObjectType = {
  EmptyTriggerObject: 'empty_trigger_object',
  Cases: 'cases',
  CaseFiles: 'case_files',
  CaseComments: 'case_comments',
  CaseLinks: 'case_links',
  RelatedCases: 'related_cases',
} as const;

export type EngineTriggerType = typeof EngineTriggerType[keyof typeof EngineTriggerType];


export const EngineTriggerType = {
  DefaultTriggerType: 'default_trigger_type',
  Cron: 'cron',
  Event: 'event',
} as const;

export interface EngineCreateTriggerRequest {
  description?: string;
  enabled?: boolean;
  event?: EngineTriggerEventType;
  expression?: string;
  name?: string;
  object?: EngineTriggerObjectType;
  schema?: EngineLookup;
  timeout?: number;
  timezone?: EngineLookup;
  type?: EngineTriggerType;
  variables?: EngineCreateTriggerRequestVariables;
}

export interface EngineCreateWebHookRequest {
  authorization?: string;
  description?: string;
  enabled?: boolean;
  name?: string;
  origin?: string[];
  schema?: EngineLookup;
}

export interface EngineDefaultDeviceConfigResponseSipDeviceConfig {
  auth?: string;
  domain?: string;
  extension?: string;
  password?: string;
  proxy?: string;
}

export interface EngineDefaultDeviceConfigResponseWebRTCDeviceConfig {
  authorizationUser?: string;
  displayName?: string;
  extension?: string;
  ha1?: string;
  realm?: string;
  server?: string;
  uri?: string;
}

export interface EngineDefaultDeviceConfigResponse {
  sip?: EngineDefaultDeviceConfigResponseSipDeviceConfig;
  webrtc?: EngineDefaultDeviceConfigResponseWebRTCDeviceConfig;
}

export type EngineDeleteAllMembersRequestVariables = {[key: string]: string};

export interface EngineDeleteAllMembersRequest {
  agentId?: number[];
  attempts?: EngineFilterBetween;
  bucketId?: number[];
  createdAt?: EngineFilterBetween;
  destination?: string;
  id?: string[];
  name?: string;
  numbers?: string[];
  offeringAt?: EngineFilterBetween;
  priority?: EngineFilterBetween;
  q?: string;
  queueId?: string[];
  size?: number;
  sort?: string;
  stopCause?: string[];
  variables?: EngineDeleteAllMembersRequestVariables;
  withoutMembers?: boolean;
}

export interface EngineDeleteSkillAgentResponse {
  items?: EngineSkillAgentItem[];
}

export interface EngineDtmfCallResponse { [key: string]: unknown }

export interface EngineEmailProfile {
  activityAt?: string;
  authType?: EngineEmailAuthType;
  createdAt?: string;
  createdBy?: EngineLookup;
  description?: string;
  enabled?: boolean;
  fetchError?: string;
  fetchInterval?: number;
  id?: string;
  imapHost?: string;
  imapPort?: number;
  listen?: boolean;
  logged?: boolean;
  login?: string;
  mailbox?: string;
  name?: string;
  params?: EngineEmailProfileParams;
  password?: string;
  schema?: EngineLookup;
  smtpHost?: string;
  smtpPort?: number;
  state?: string;
  updatedAt?: string;
  updatedBy?: EngineLookup;
}

export interface EngineEmailProfileServicePatchEmailProfileBody {
  description?: string;
  enabled?: boolean;
  fetchInterval?: number;
  fields?: string[];
  imapHost?: string;
  imapPort?: number;
  listen?: boolean;
  login?: string;
  mailbox?: string;
  name?: string;
  password?: string;
  schema?: EngineLookup;
  smtpHost?: string;
  smtpPort?: number;
}

export interface EngineEmailProfileServiceUpdateEmailProfileBody {
  authType?: EngineEmailAuthType;
  description?: string;
  enabled?: boolean;
  fetchInterval?: number;
  imapHost?: string;
  imapPort?: number;
  listen?: boolean;
  login?: string;
  mailbox?: string;
  name?: string;
  params?: EngineEmailProfileParams;
  password?: string;
  schema?: EngineLookup;
  smtpHost?: string;
  smtpPort?: number;
}

export interface EngineEmptyResponse { [key: string]: unknown }

export type EngineFeedbackPayload = {[key: string]: string};

export interface EngineFeedback {
  createdAt?: string;
  description?: string;
  payload?: EngineFeedbackPayload;
  rating?: number;
}

export interface EngineForAgentPauseCause {
  durationMin?: number;
  id?: number;
  limitMin?: number;
  name?: string;
}

export interface EngineForAgentPauseCauseList {
  items?: EngineForAgentPauseCause[];
}

export interface EngineGenerateFeedbackResponse {
  key?: string;
}

export interface EngineGetQueuesGlobalStateResponse {
  isAllEnabled?: boolean;
  potentialRows?: number;
}

export interface EngineHangupCallResponse { [key: string]: unknown }

export type EngineHistoryCallVariables = {[key: string]: string};

export interface EngineHistoryCallBlindTransfer {
  number?: string;
  time?: string;
  user?: EngineLookup;
}

export type EngineHistoryFileJobHistoryFileJobAction = typeof EngineHistoryFileJobHistoryFileJobAction[keyof typeof EngineHistoryFileJobHistoryFileJobAction];


export const EngineHistoryFileJobHistoryFileJobAction = {
  Undefined: 'undefined',
  Stt: 'STT',
  Delete: 'delete',
} as const;

export type EngineHistoryFileJobHistoryFileJobState = typeof EngineHistoryFileJobHistoryFileJobState[keyof typeof EngineHistoryFileJobHistoryFileJobState];


export const EngineHistoryFileJobHistoryFileJobState = {
  Idle: 'idle',
  Active: 'active',
  Finished: 'finished',
  Error: 'error',
} as const;

export interface EngineHistoryFileJob {
  action?: EngineHistoryFileJobHistoryFileJobAction;
  createdAt?: string;
  errorDetail?: string;
  fileId?: string;
  id?: string;
  state?: EngineHistoryFileJobHistoryFileJobState;
}

export interface EngineHistoryCallCallForm {
  agent?: EngineLookup;
  reportingAt?: string;
}

export interface EngineTranscriptLookup {
  file?: EngineLookup;
  fileId?: string;
  id?: string;
  locale?: string;
}

export interface EngineHistoryCall {
  tags?: string[];
  agent?: EngineLookup;
  agentDescription?: string;
  allowEvaluation?: boolean;
  amdAiLogs?: string[];
  amdAiResult?: string;
  amdResult?: string;
  annotations?: EngineCallAnnotation[];
  answeredAt?: string;
  appId?: string;
  attemptId?: string;
  billSec?: number;
  blindTransfer?: string;
  blindTransfers?: EngineHistoryCallBlindTransfer[];
  bridgedAt?: string;
  bridgedId?: string;
  cause?: string;
  contact?: EngineLookup;
  conversationId?: string;
  createdAt?: string;
  destination?: string;
  destinationName?: string;
  direction?: string;
  display?: string;
  duration?: number;
  extension?: string;
  files?: EngineCallFile[];
  filesJob?: EngineHistoryFileJob[];
  forms?: EngineHistoryCallCallForm[];
  from?: EngineEndpoint;
  fromNumber?: string;
  gateway?: EngineLookup;
  grantee?: EngineLookup;
  hangupAt?: string;
  hangupBy?: string;
  hangupDisposition?: string;
  hangupPhrase?: string;
  hasChildren?: boolean;
  hold?: EngineCallHold[];
  holdSec?: number;
  id?: string;
  joinedAt?: string;
  leavingAt?: string;
  meetingId?: string;
  member?: EngineLookup;
  memberId?: string;
  parentId?: string;
  queue?: EngineLookup;
  queueBridgedAt?: string;
  queueDurationSec?: number;
  queueWaitSec?: number;
  rateId?: string;
  ratedBy?: EngineLookup;
  ratedUser?: EngineLookup;
  reportingAt?: string;
  reportingSec?: number;
  result?: string;
  schemas?: EngineLookup[];
  scoreOptional?: number;
  scoreRequired?: number;
  sipCode?: number;
  storedAt?: string;
  talkSec?: number;
  team?: EngineLookup;
  to?: EngineEndpoint;
  toNumber?: string;
  transcripts?: EngineTranscriptLookup[];
  transferFrom?: string;
  transferTo?: string;
  type?: string;
  user?: EngineLookup;
  variables?: EngineHistoryCallVariables;
  waitSec?: number;
}

export interface EngineHoldCallResponse {
  state?: string;
}

export interface EngineList {
  count?: string;
  createdAt?: string;
  createdBy?: EngineLookup;
  description?: string;
  domainId?: string;
  id?: string;
  name?: string;
  updatedAt?: string;
  updatedBy?: EngineLookup;
}

export interface EngineListAgent {
  items?: EngineAgent[];
  next?: boolean;
}

export interface EngineListAgentInQueue {
  items?: EngineAgentInQueue[];
  next?: boolean;
}

export interface EngineListAgentInTeam {
  items?: EngineAgentInTeam[];
  next?: boolean;
}

export interface EngineListAgentPauseCause {
  items?: EngineAgentPauseCause[];
  next?: boolean;
}

export interface EngineListAgentSkill {
  items?: EngineAgentSkillItem[];
  next?: boolean;
}

export interface EngineListAgentStateHistory {
  items?: EngineAgentState[];
  next?: boolean;
}

export interface EngineListAgentStatsStatistic {
  items?: EngineAgentStatsStatistic[];
  next?: boolean;
}

export interface EngineListAgentTeam {
  items?: EngineAgentTeam[];
  next?: boolean;
}

export interface EngineListAgentUser {
  items?: EngineAgentUser[];
  next?: boolean;
}

export interface EngineListAggregate {
  items?: EngineAggregateResult[];
}

export interface EngineListAttempt {
  items?: EngineAttempt[];
  next?: boolean;
}

export interface EngineListAuditForm {
  items?: EngineAuditForm[];
  next?: boolean;
}

export interface EngineListAuditRate {
  items?: EngineAuditRate[];
  next?: boolean;
}

export interface EngineListAvailableSystemSetting {
  items?: EngineAvailableSystemSetting[];
  next?: boolean;
}

export interface EngineListBucket {
  items?: EngineBucket[];
  next?: boolean;
}

export interface EngineListCalendar {
  items?: EngineCalendar[];
  next?: boolean;
}

export interface EngineListCall {
  items?: EngineActiveCall[];
  next?: boolean;
}

export interface EngineListChatPlan {
  items?: EngineChatPlan[];
  next?: boolean;
}

export interface EngineListCommunication {
  description?: string;
  expireAt?: string;
  id?: string;
  listId?: string;
  number?: string;
}

export interface EngineListCommunicationType {
  items?: EngineCommunicationType[];
  next?: boolean;
}

export interface EngineListEmailProfile {
  items?: EngineEmailProfile[];
  next?: boolean;
}

export interface EngineListHistoryAttempt {
  items?: EngineAttemptHistory[];
  next?: boolean;
}

export interface EngineListHistoryCall {
  items?: EngineHistoryCall[];
  next?: boolean;
}

export type EngineMemberInQueueVariables = {[key: string]: string};

export interface EngineMemberInQueue {
  agent?: EngineLookup;
  attempts?: number;
  bucket?: EngineLookup;
  communications?: EngineMemberCommunication[];
  createdAt?: string;
  expireAt?: string;
  id?: string;
  lastActivityAt?: string;
  minOfferingAt?: string;
  name?: string;
  priority?: number;
  queue?: EngineLookup;
  reserved?: boolean;
  skill?: EngineLookup;
  stopCause?: string;
  timezone?: EngineLookup;
  variables?: EngineMemberInQueueVariables;
}

export interface EngineListMember {
  items?: EngineMemberInQueue[];
  next?: boolean;
}

export interface EngineMemberAttempt {
  active?: boolean;
  agent?: EngineLookup;
  answeredAt?: string;
  attempts?: number;
  bridgedAt?: string;
  bucket?: EngineLookup;
  createdAt?: string;
  destination?: string;
  hangupAt?: string;
  id?: string;
  legAId?: string;
  legBId?: string;
  member?: EngineLookup;
  node?: string;
  originateAt?: string;
  resource?: EngineLookup;
  result?: string;
  weight?: number;
}

export interface EngineListMemberAttempt {
  items?: EngineMemberAttempt[];
  next?: boolean;
}

export interface EngineListOfList {
  items?: EngineList[];
  next?: boolean;
}

export interface EngineListOfListCommunication {
  items?: EngineListCommunication[];
  next?: boolean;
}

export interface EngineOpenedWebSocket {
  applicationName?: string;
  createdAt?: string;
  duration?: string;
  id?: string;
  ip?: string;
  pong?: string;
  updatedAt?: string;
  userAgent?: string;
  ver?: string;
}

export interface EngineListOpenedWebSocket {
  items?: EngineOpenedWebSocket[];
  next?: boolean;
}

export type EngineOutboundResourceVariables = {[key: string]: string};

export interface EngineOutboundResource {
  parameters?: EngineOutboundResourceParameters;
  createdAt?: string;
  createdBy?: EngineLookup;
  description?: string;
  domainId?: string;
  enabled?: boolean;
  errorIds?: string[];
  failureDialDelay?: number;
  gateway?: EngineLookup;
  id?: string;
  lastErrorAt?: string;
  lastErrorId?: string;
  limit?: number;
  maxSuccessivelyErrors?: number;
  name?: string;
  number?: string;
  patterns?: string[];
  reserve?: boolean;
  rps?: number;
  successivelyErrors?: number;
  updatedAt?: string;
  updatedBy?: EngineLookup;
  variables?: EngineOutboundResourceVariables;
}

export interface EngineListOutboundResource {
  items?: EngineOutboundResource[];
  next?: boolean;
}

export interface EngineResourceDisplay {
  display?: string;
  id?: string;
}

export interface EngineListOutboundResourceDisplay {
  items?: EngineResourceDisplay[];
  next?: boolean;
}

export interface EngineOutboundResourceViewGroup {
  communication?: EngineLookup;
  description?: string;
  id?: string;
  name?: string;
  strategy?: string;
}

export interface EngineListOutboundResourceGroup {
  items?: EngineOutboundResourceViewGroup[];
  next?: boolean;
}

export interface EngineOutboundResourceInGroup {
  groupId?: string;
  id?: string;
  priority?: number;
  reserveResource?: EngineLookup;
  resource?: EngineLookup;
}

export interface EngineListOutboundResourceInGroup {
  items?: EngineOutboundResourceInGroup[];
  next?: boolean;
}

export interface EnginePresetQuery {
  createdAt?: string;
  description?: string;
  id?: number;
  name?: string;
  section?: string;
  updatedAt?: string;
}

export interface EngineListPresetQuery {
  items?: EnginePresetQuery[];
  next?: boolean;
}

export interface EngineResourceGroup {
  id?: string;
  name?: string;
}

export interface EngineResource {
  id?: string;
  name?: string;
}

export type EngineQueueVariables = {[key: string]: string};

export interface EngineQueue {
  tags?: EngineTag[];
  active?: number;
  afterSchema?: EngineLookup;
  calendar?: EngineLookup;
  count?: number;
  createdAt?: string;
  createdBy?: EngineLookup;
  description?: string;
  dncList?: EngineLookup;
  doSchema?: EngineLookup;
  domainId?: string;
  enabled?: boolean;
  formSchema?: EngineLookup;
  grantee?: EngineLookup;
  id?: string;
  name?: string;
  priority?: number;
  processing?: boolean;
  processingRenewalSec?: number;
  processingSec?: number;
  resourceGroups?: EngineResourceGroup[];
  resources?: EngineResource[];
  ringtone?: EngineLookup;
  schema?: EngineLookup;
  secLocateAgent?: number;
  stickyAgent?: boolean;
  strategy?: string;
  taskProcessing?: EngineTaskProcessing;
  team?: EngineLookup;
  timeout?: number;
  type?: number;
  updatedAt?: string;
  updatedBy?: EngineLookup;
  variables?: EngineQueueVariables;
  waiting?: number;
}

export interface EngineListQueue {
  items?: EngineQueue[];
  next?: boolean;
}

export interface EngineQueueBucket {
  bucket?: EngineLookup;
  disabled?: boolean;
  id?: string;
  priority?: number;
  ratio?: number;
}

export interface EngineListQueueBucket {
  items?: EngineQueueBucket[];
  next?: boolean;
}

export interface EngineQueueHook {
  enabled?: boolean;
  event?: string;
  id?: number;
  properties?: string[];
  schema?: EngineLookup;
}

export interface EngineListQueueHook {
  items?: EngineQueueHook[];
  next?: boolean;
}

export interface EngineQueueResourceGroup {
  communication?: EngineLookup;
  id?: string;
  resourceGroup?: EngineLookup;
}

export interface EngineListQueueResourceGroup {
  items?: EngineQueueResourceGroup[];
  next?: boolean;
}

export interface EngineQueueSkill {
  buckets?: EngineLookup[];
  enabled?: boolean;
  id?: number;
  lvl?: number;
  maxCapacity?: number;
  minCapacity?: number;
  skill?: EngineLookup;
}

export interface EngineListQueueSkill {
  items?: EngineQueueSkill[];
  next?: boolean;
}

export interface EngineQuickReply {
  article?: EngineLookup;
  createdAt?: string;
  createdBy?: EngineLookup;
  id?: number;
  name?: string;
  queues?: EngineLookup[];
  teams?: EngineLookup[];
  text?: string;
  updatedAt?: string;
  updatedBy?: EngineLookup;
}

export interface EngineListQuickReplies {
  items?: EngineQuickReply[];
  next?: boolean;
}

export interface EngineRegion {
  description?: string;
  id?: string;
  name?: string;
  timezone?: EngineLookup;
}

export interface EngineListRegion {
  items?: EngineRegion[];
  next?: boolean;
}

export interface EngineQueueReportGeneralAgentStatus {
  free?: number;
  offline?: number;
  online?: number;
  pause?: number;
  total?: number;
}

export interface EngineQueueReportGeneral {
  abandoned?: number;
  agentStatus?: EngineQueueReportGeneralAgentStatus;
  attempts?: number;
  avgAhtSec?: number;
  avgAsaSec?: number;
  avgAwtSec?: number;
  avgWrapSec?: number;
  bridged?: number;
  count?: string;
  missed?: number;
  processed?: number;
  queue?: EngineLookup;
  sl20?: number;
  sl30?: number;
  sumBillSec?: number;
  team?: EngineLookup;
  transferred?: number;
  waiting?: number;
}

export interface EngineListReportGeneral {
  aggs?: EngineQueueReportGeneralAgentStatus;
  items?: EngineQueueReportGeneral[];
  next?: boolean;
}

export interface EngineListResourceDisplay {
  id?: string[];
}

export interface EngineRoutingOutboundCallCompact {
  description?: string;
  disabled?: boolean;
  domainId?: string;
  id?: string;
  name?: string;
  pattern?: string;
  position?: number;
  schema?: EngineLookup;
}

export interface EngineListRoutingOutboundCall {
  items?: EngineRoutingOutboundCallCompact[];
  next?: boolean;
}

export interface EngineRoutingSchema {
  tags?: EngineSchemaTag[];
  createdAt?: string;
  createdBy?: EngineLookup;
  debug?: boolean;
  description?: string;
  editor?: boolean;
  id?: string;
  name?: string;
  type?: EngineRoutingSchemaType;
  updatedAt?: string;
  updatedBy?: EngineLookup;
}

export interface EngineListRoutingSchema {
  items?: EngineRoutingSchema[];
  next?: boolean;
}

export interface EngineRoutingSchemaTag {
  count?: number;
  name?: string;
}

export interface EngineListRoutingSchemaTags {
  items?: EngineRoutingSchemaTag[];
  next?: boolean;
}

export interface EngineRoutingVariable {
  domainId?: string;
  id?: string;
  key?: string;
  value?: string;
}

export interface EngineListRoutingVariable {
  items?: EngineRoutingVariable[];
}

export interface EngineSchemaVariable {
  encrypt?: boolean;
  id?: number;
  name?: string;
}

export interface EngineListSchemaVariable {
  items?: EngineSchemaVariable[];
  next?: boolean;
}

export interface EngineListServiceCreateListCommunicationBody {
  description?: string;
  expireAt?: string;
  number?: string;
}

export interface EngineListServiceUpdateListBody {
  description?: string;
  domainId?: string;
  name?: string;
}

export interface EngineListServiceUpdateListCommunicationBody {
  description?: string;
  expireAt?: string;
  number?: string;
}

export interface EngineSkill {
  activeAgents?: number;
  createdAt?: string;
  createdBy?: EngineLookup;
  description?: string;
  domainId?: string;
  id?: string;
  name?: string;
  totalAgents?: number;
  updatedAt?: string;
  updatedBy?: EngineLookup;
}

export interface EngineListSkill {
  items?: EngineSkill[];
  next?: boolean;
}

export interface EngineListSkillAgentListSkillAgg {
  enabled?: boolean;
  potentialRows?: number;
}

export interface EngineListSkillAgent {
  aggs?: EngineListSkillAgentListSkillAgg;
  items?: EngineSkillAgentItem[];
  next?: boolean;
}

export interface EngineSystemSetting {
  id?: number;
  name?: EngineSystemSettingName;
}

export interface EngineListSystemSetting {
  items?: EngineSystemSetting[];
  next?: boolean;
}

export interface EngineListTags {
  items?: EngineTag[];
  next?: boolean;
}

export type EngineTeamHookEvent = typeof EngineTeamHookEvent[keyof typeof EngineTeamHookEvent];


export const EngineTeamHookEvent = {
  TeamHookEventUndefined: 'teamHookEventUndefined',
  AgentStatus: 'agent_status',
} as const;

export interface EngineTeamHook {
  enabled?: boolean;
  event?: EngineTeamHookEvent;
  id?: number;
  properties?: string[];
  schema?: EngineLookup;
}

export interface EngineListTeamHook {
  items?: EngineTeamHook[];
  next?: boolean;
}

export interface EngineTeamTrigger {
  description?: string;
  enabled?: boolean;
  id?: number;
  name?: string;
  schema?: EngineLookup;
}

export interface EngineListTeamTrigger {
  items?: EngineTeamTrigger[];
  next?: boolean;
}

export interface EngineTimezone {
  id?: string;
  name?: string;
  offset?: string;
}

export interface EngineListTimezoneResponse {
  items?: EngineTimezone[];
  next?: boolean;
}

export type EngineTriggerVariables = {[key: string]: string};

export interface EngineTrigger {
  description?: string;
  enabled?: boolean;
  event?: EngineTriggerEventType;
  expression?: string;
  id?: number;
  name?: string;
  object?: EngineTriggerObjectType;
  schema?: EngineLookup;
  timeout?: number;
  timezone?: EngineLookup;
  type?: EngineTriggerType;
  variables?: EngineTriggerVariables;
}

export interface EngineListTrigger {
  items?: EngineTrigger[];
  next?: boolean;
}

export type EngineTriggerJobState = typeof EngineTriggerJobState[keyof typeof EngineTriggerJobState];


export const EngineTriggerJobState = {
  Idle: 'idle',
  Active: 'active',
  Done: 'done',
  Error: 'error',
} as const;

export interface EngineTriggerJob {
  createdAt?: string;
  error?: string;
  id?: string;
  startedAt?: string;
  state?: EngineTriggerJobState;
  stoppedAt?: string;
  trigger?: EngineLookup;
}

export interface EngineListTriggerJob {
  items?: EngineTriggerJob[];
  next?: boolean;
}

export interface EngineUserStatusUserPresence {
  status?: string;
}

export interface EngineUserStatus {
  extension?: string;
  id?: string;
  name?: string;
  presence?: EngineUserStatusUserPresence;
  status?: string;
}

export interface EngineListUserStatus {
  items?: EngineUserStatus[];
  next?: boolean;
}

export interface EngineWebHook {
  authorization?: string;
  createdAt?: string;
  createdBy?: EngineLookup;
  description?: string;
  enabled?: boolean;
  id?: number;
  key?: string;
  name?: string;
  origin?: string[];
  schema?: EngineLookup;
  updatedAt?: string;
  updatedBy?: EngineLookup;
}

export interface EngineListWebHook {
  items?: EngineWebHook[];
  next?: boolean;
}

export type EngineLoginEmailProfileResponseCookie = {[key: string]: string};

export interface EngineLoginEmailProfileResponse {
  authType?: EngineEmailAuthType;
  cookie?: EngineLoginEmailProfileResponseCookie;
  redirectUrl?: string;
}

export interface EngineLogoutEmailProfileResponse { [key: string]: unknown }

export interface EngineMemberBulkResponse {
  ids?: string[];
}

export type EngineMemberServiceAttemptCallbackBodyVariables = {[key: string]: string};

export interface EngineMemberServiceAttemptCallbackBody {
  agentId?: number;
  description?: string;
  display?: boolean;
  excludeCurrentCommunication?: boolean;
  expireAt?: string;
  minOfferingAt?: string;
  onlyCurrentCommunication?: boolean;
  status?: string;
  variables?: EngineMemberServiceAttemptCallbackBodyVariables;
  waitBetweenRetries?: number;
}

export type EngineMemberServiceAttemptResultBodyVariables = {[key: string]: string};

export interface EngineMemberServiceAttemptResultBody {
  agentId?: number;
  description?: string;
  display?: boolean;
  excludeCurrentCommunication?: boolean;
  expireAt?: string;
  minOfferingAt?: string;
  nextMemberId?: string;
  onlyCurrentCommunication?: boolean;
  status?: string;
  transferQueueId?: string;
  variables?: EngineMemberServiceAttemptResultBodyVariables;
  waitBetweenRetries?: number;
}

export interface EngineMemberServiceAttemptsRenewalResultBody {
  renewal?: number;
}

export interface EngineMemberServiceCreateAttemptBody {
  agentId?: string;
  domainId?: string;
}

export type EngineMemberServiceCreateMemberBodyVariables = {[key: string]: string};

export interface EngineMemberServiceCreateMemberBody {
  agent?: EngineLookup;
  bucket?: EngineLookup;
  communications?: EngineMemberCommunicationCreateRequest[];
  domainId?: string;
  expireAt?: string;
  minOfferingAt?: string;
  name?: string;
  priority?: number;
  skill?: EngineLookup;
  timezone?: EngineLookup;
  variables?: EngineMemberServiceCreateMemberBodyVariables;
}

export interface EngineMemberServiceCreateMemberBulkBody {
  fileName?: string;
  items?: EngineCreateMemberBulkItem[];
}

export type EngineMemberServiceDeleteMembersBodyVariables = {[key: string]: string};

export interface EngineMemberServiceDeleteMembersBody {
  agentId?: number[];
  attempts?: EngineFilterBetween;
  bucketId?: number[];
  createdAt?: EngineFilterBetween;
  destination?: string;
  id?: string[];
  ids?: string[];
  name?: string;
  numbers?: string[];
  offeringAt?: EngineFilterBetween;
  priority?: EngineFilterBetween;
  q?: string;
  size?: number;
  sort?: string;
  stopCause?: string[];
  variables?: EngineMemberServiceDeleteMembersBodyVariables;
  withoutMembers?: boolean;
}

export type EngineMemberServicePatchMemberBodyVariables = {[key: string]: string};

export interface EngineMemberServicePatchMemberBody {
  agent?: EngineLookup;
  attempts?: number;
  bucket?: EngineLookup;
  communications?: EngineMemberCommunicationCreateRequest[];
  domainId?: string;
  expireAt?: string;
  fields?: string[];
  minOfferingAt?: string;
  name?: string;
  priority?: number;
  skill?: EngineLookup;
  stopCause?: string;
  timezone?: EngineLookup;
  variables?: EngineMemberServicePatchMemberBodyVariables;
}

export type EngineMemberServicePatchMemberOneBodyVariables = {[key: string]: string};

export interface EngineMemberServicePatchMemberOneBody {
  agent?: EngineLookup;
  attempts?: number;
  bucket?: EngineLookup;
  communications?: EngineMemberCommunicationCreateRequest[];
  domainId?: string;
  expireAt?: string;
  fields?: string[];
  minOfferingAt?: string;
  name?: string;
  priority?: number;
  skill?: EngineLookup;
  stopCause?: string;
  timezone?: EngineLookup;
  variables?: EngineMemberServicePatchMemberOneBodyVariables;
}

export type EngineMemberServiceResetMembersBodyVariables = {[key: string]: string};

export interface EngineMemberServiceResetMembersBody {
  agentId?: number[];
  bucketId?: string[];
  createdAt?: EngineFilterBetween;
  id?: string[];
  ids?: string[];
  numbers?: string[];
  priority?: EngineFilterBetween;
  stopCause?: string[];
  variables?: EngineMemberServiceResetMembersBodyVariables;
}

export type EngineMemberServiceUpdateMemberBodyVariables = {[key: string]: string};

export interface EngineMemberServiceUpdateMemberBody {
  agent?: EngineLookup;
  bucket?: EngineLookup;
  communications?: EngineMemberCommunicationCreateRequest[];
  domainId?: string;
  expireAt?: string;
  minOfferingAt?: string;
  name?: string;
  priority?: number;
  skill?: EngineLookup;
  stopCause?: string;
  timezone?: EngineLookup;
  variables?: EngineMemberServiceUpdateMemberBodyVariables;
}

export interface EngineMovePositionRoutingOutboundCallResponse {
  success?: boolean;
}

export interface EngineOutboundResourceGroup {
  communication?: EngineLookup;
  createdAt?: string;
  createdBy?: EngineLookup;
  description?: string;
  domainId?: string;
  id?: string;
  name?: string;
  strategy?: string;
  time?: EngineOutboundResourceTimeRange[];
  updatedAt?: string;
  updatedBy?: EngineLookup;
}

export interface EngineOutboundResourceGroupServiceCreateOutboundResourceInGroupBody {
  priority?: number;
  reserveResource?: EngineLookup;
  resource?: EngineLookup;
}

export interface EngineOutboundResourceGroupServiceUpdateOutboundResourceGroupBody {
  communication?: EngineLookup;
  description?: string;
  domainId?: string;
  name?: string;
  strategy?: string;
  time?: EngineOutboundResourceTimeRange[];
}

export interface EngineOutboundResourceGroupServiceUpdateOutboundResourceInGroupBody {
  priority?: number;
  reserveResource?: EngineLookup;
  resource?: EngineLookup;
}

export interface EngineOutboundResourceServiceCreateOutboundResourceDisplayBody {
  display?: string;
  domainId?: string;
}

export interface EngineOutboundResourceServiceCreateOutboundResourceDisplayBulkBody {
  items?: EngineCreateOutboundResourceDisplayRequest[];
}

export type EngineOutboundResourceServicePatchOutboundResourceBodyVariables = {[key: string]: string};

export interface EngineOutboundResourceServicePatchOutboundResourceBody {
  parameters?: EngineOutboundResourceParameters;
  description?: string;
  enabled?: boolean;
  errorIds?: string[];
  failureDialDelay?: number;
  fields?: string[];
  gateway?: EngineLookup;
  limit?: number;
  maxSuccessivelyErrors?: number;
  name?: string;
  number?: string;
  patterns?: string[];
  reserve?: boolean;
  rps?: number;
  variables?: EngineOutboundResourceServicePatchOutboundResourceBodyVariables;
}

export type EngineOutboundResourceServiceUpdateOutboundResourceBodyVariables = {[key: string]: string};

export interface EngineOutboundResourceServiceUpdateOutboundResourceBody {
  parameters?: EngineOutboundResourceParameters;
  description?: string;
  enabled?: boolean;
  errorIds?: string[];
  failureDialDelay?: number;
  gateway?: EngineLookup;
  limit?: number;
  maxSuccessivelyErrors?: number;
  name?: string;
  number?: string;
  patterns?: string[];
  reserve?: boolean;
  rps?: number;
  variables?: EngineOutboundResourceServiceUpdateOutboundResourceBodyVariables;
}

export interface EngineOutboundResourceServiceUpdateOutboundResourceDisplayBody {
  display?: string;
  domainId?: string;
}

export interface EnginePatchSkillAgentResponse {
  items?: EngineSkillAgentItem[];
}

export interface EnginePresetQueryServicePatchPresetQueryBody {
  description?: string;
  fields?: string[];
  name?: string;
  section?: string;
}

export interface EnginePresetQueryServiceUpdatePresetQueryBody {
  description?: string;
  name?: string;
  section?: string;
}

export interface EngineQueueBucketServiceCreateQueueBucketBody {
  bucket?: EngineLookup;
  disabled?: boolean;
  priority?: number;
  ratio?: number;
}

export interface EngineQueueBucketServicePatchQueueBucketBody {
  bucket?: EngineLookup;
  disabled?: boolean;
  fields?: string[];
  priority?: number;
  ratio?: number;
}

export interface EngineQueueBucketServiceUpdateQueueBucketBody {
  bucket?: EngineLookup;
  disabled?: boolean;
  priority?: number;
  ratio?: number;
}

export interface EngineQueueHookServiceCreateQueueHookBody {
  enabled?: boolean;
  event?: string;
  properties?: string[];
  schema?: EngineLookup;
}

export interface EngineQueueHookServicePatchQueueHookBody {
  enabled?: boolean;
  event?: string;
  fields?: string[];
  properties?: string[];
  schema?: EngineLookup;
}

export interface EngineQueueHookServiceUpdateQueueHookBody {
  enabled?: boolean;
  event?: string;
  properties?: string[];
  schema?: EngineLookup;
}

export interface EngineQueueResourcesServiceCreateQueueResourceGroupBody {
  domainId?: string;
  resourceGroup?: EngineLookup;
}

export interface EngineQueueResourcesServiceUpdateQueueResourceGroupBody {
  domainId?: string;
  resourceGroup?: EngineLookup;
}

export type EngineQueueServicePatchQueueBodyVariables = {[key: string]: string};

export interface EngineQueueServicePatchQueueBody {
  tags?: EngineTag[];
  afterSchema?: EngineLookup;
  calendar?: EngineLookup;
  description?: string;
  dncList?: EngineLookup;
  doSchema?: EngineLookup;
  domainId?: string;
  enabled?: boolean;
  fields?: string[];
  formSchema?: EngineLookup;
  grantee?: EngineLookup;
  name?: string;
  priority?: number;
  processing?: boolean;
  processingRenewalSec?: number;
  processingSec?: number;
  ringtone?: EngineLookup;
  schema?: EngineLookup;
  secLocateAgent?: number;
  stickyAgent?: boolean;
  strategy?: string;
  taskProcessing?: EngineTaskProcessing;
  team?: EngineLookup;
  timeout?: number;
  type?: number;
  variables?: EngineQueueServicePatchQueueBodyVariables;
}

export type EngineQueueServiceUpdateQueueBodyVariables = {[key: string]: string};

export interface EngineQueueServiceUpdateQueueBody {
  tags?: EngineTag[];
  afterSchema?: EngineLookup;
  calendar?: EngineLookup;
  description?: string;
  dncList?: EngineLookup;
  doSchema?: EngineLookup;
  domainId?: string;
  enabled?: boolean;
  formSchema?: EngineLookup;
  grantee?: EngineLookup;
  name?: string;
  priority?: number;
  processing?: boolean;
  processingRenewalSec?: number;
  processingSec?: number;
  ringtone?: EngineLookup;
  schema?: EngineLookup;
  secLocateAgent?: number;
  stickyAgent?: boolean;
  strategy?: string;
  taskProcessing?: EngineTaskProcessing;
  team?: EngineLookup;
  timeout?: number;
  type?: number;
  variables?: EngineQueueServiceUpdateQueueBodyVariables;
}

export interface EngineQueueSkillServiceCreateQueueSkillBody {
  buckets?: EngineLookup[];
  enabled?: boolean;
  lvl?: number;
  maxCapacity?: number;
  minCapacity?: number;
  skill?: EngineLookup;
}

export interface EngineQueueSkillServicePatchQueueSkillBody {
  buckets?: EngineLookup[];
  enabled?: boolean;
  fields?: string[];
  lvl?: number;
  maxCapacity?: number;
  minCapacity?: number;
  skill?: EngineLookup;
}

export interface EngineQueueSkillServiceUpdateQueueSkillBody {
  buckets?: EngineLookup[];
  enabled?: boolean;
  lvl?: number;
  maxCapacity?: number;
  minCapacity?: number;
  skill?: EngineLookup;
}

export interface EngineQuickRepliesServicePatchQuickReplyBody {
  article?: EngineLookup;
  fields?: string[];
  name?: string;
  queues?: EngineLookup[];
  teams?: EngineLookup[];
  text?: string;
}

export interface EngineQuickRepliesServiceUpdateQuickReplyBody {
  article?: EngineLookup;
  name?: string;
  queues?: EngineLookup[];
  teams?: EngineLookup[];
  text?: string;
}

export interface EngineRegionServicePatchRegionBody {
  description?: string;
  fields?: string[];
  name?: string;
  timezone?: EngineLookup;
}

export interface EngineRegionServiceUpdateRegionBody {
  description?: string;
  name?: string;
  timezone?: EngineLookup;
}

export interface EngineResetActiveAttemptsRequest {
  attemptType?: string[];
  idleForMinutes?: string;
  result?: string;
}

export interface EngineResetActiveAttemptsResponse { [key: string]: unknown }

export interface EngineResetMembersResponse {
  count?: string;
}

export interface EngineResponse {
  status?: string;
}

export interface EngineRoutingChatPlanServicePatchChatPlanBody {
  description?: string;
  enabled?: boolean;
  fields?: string[];
  name?: string;
  schema?: EngineLookup;
}

export interface EngineRoutingChatPlanServiceUpdateChatPlanBody {
  description?: string;
  enabled?: boolean;
  name?: string;
  schema?: EngineLookup;
}

export interface EngineRoutingOutboundCall {
  createdAt?: string;
  createdBy?: EngineLookup;
  description?: string;
  disabled?: boolean;
  domainId?: string;
  id?: string;
  name?: string;
  pattern?: string;
  schema?: EngineLookup;
  updatedAt?: string;
  updatedBy?: EngineLookup;
}

export interface EngineRoutingOutboundCallServiceMovePositionRoutingOutboundCallBody {
  domainId?: string;
}

export interface EngineRoutingOutboundCallServicePatchRoutingOutboundCallBody {
  description?: string;
  disabled?: boolean;
  domainId?: string;
  fields?: string[];
  name?: string;
  pattern?: string;
  schema?: EngineLookup;
}

export interface EngineRoutingOutboundCallServiceUpdateRoutingOutboundCallBody {
  description?: string;
  disabled?: boolean;
  domainId?: string;
  name?: string;
  pattern?: string;
  schema?: EngineLookup;
}

export interface EngineRoutingSchemaServicePatchRoutingSchemaBody {
  tags?: EngineSchemaTag[];
  debug?: boolean;
  description?: string;
  editor?: boolean;
  fields?: string[];
  name?: string;
  note?: string;
  type?: EngineRoutingSchemaType;
}

export interface EngineRoutingSchemaServiceUpdateRoutingSchemaBody {
  tags?: EngineSchemaTag[];
  debug?: boolean;
  description?: string;
  editor?: boolean;
  name?: string;
  note?: string;
  type?: EngineRoutingSchemaType;
}

export interface EngineRoutingVariableServiceUpdateRoutingVariableBody {
  domainId?: string;
  key?: string;
  value?: string;
}

export interface EngineRunTeamTriggerResponse {
  jobId?: string;
}

export interface EngineSchemaVariablesServicePatchSchemaVariableBody {
  encrypt?: boolean;
  fields?: string[];
  name?: string;
}

export interface EngineSchemaVariablesServiceUpdateSchemaVariableBody {
  encrypt?: boolean;
  name?: string;
}

export interface EngineSchemaVersion {
  createdAt?: string;
  createdBy?: EngineLookup;
  id?: string;
  note?: string;
  schemaId?: string;
  version?: string;
}

export type EngineSearchHistoryCallRequestVariablesString = {[key: string]: string};

export interface EngineSearchHistoryCallRequest {
  tags?: string[];
  agentDescription?: string;
  agentId?: string[];
  amdAiResult?: string[];
  amdResult?: string[];
  answeredAt?: EngineFilterBetween;
  cause?: string[];
  contactId?: string[];
  createdAt?: EngineFilterBetween;
  dependencyId?: string;
  direction?: string;
  directions?: string[];
  domainId?: string;
  duration?: EngineFilterBetween;
  fields?: string[];
  fts?: string;
  gatewayId?: string[];
  granteeId?: string[];
  hasFile?: boolean;
  hasTranscript?: boolean;
  hasTransfer?: boolean;
  id?: string[];
  memberId?: string[];
  missed?: boolean;
  number?: string;
  ownerId?: string[];
  page?: number;
  parentId?: string;
  q?: string;
  queueId?: string[];
  rated?: boolean;
  ratedBy?: string[];
  ratedUser?: string[];
  schemaId?: number[];
  scoreOptional?: EngineFilterBetween;
  scoreRequired?: EngineFilterBetween;
  size?: number;
  skipParent?: boolean;
  sort?: string;
  storedAt?: EngineFilterBetween;
  talk?: EngineFilterBetween;
  teamId?: string[];
  timeline?: boolean;
  transferFrom?: string[];
  transferTo?: string[];
  userId?: string[];
  variablesString?: EngineSearchHistoryCallRequestVariablesString;
}

export interface EngineSearchSchemaVersionResponse {
  items?: EngineSchemaVersion[];
  next?: boolean;
}

export interface EngineSendPushResponse {
  send?: number;
}

export interface EngineSetQueuesGlobalStateRequest {
  tags?: string[];
  enabled?: boolean;
  id?: string[];
  q?: string;
  teamId?: number[];
  type?: number[];
}

export interface EngineSetQueuesGlobalStateResponse {
  count?: number;
}

export interface EngineSetVariablesCallResponse { [key: string]: unknown }

export interface EngineSkillServiceCreateSkillAgentBody {
  agent?: EngineLookup[];
  capacity?: number;
  enabled?: boolean;
}

export interface EngineSkillServiceDeleteSkillAgentBody {
  agentId?: string[];
  id?: string[];
}

export interface EngineSkillServicePatchSkillAgentBody {
  agentId?: string[];
  capacity?: number;
  enabled?: boolean;
  fields?: string[];
  id?: string[];
  q?: string;
  skill?: EngineLookup;
}

export interface EngineSkillServiceUpdateSkillBody {
  description?: string;
  domainId?: string;
  name?: string;
}

export interface EngineSystemSettingServicePatchSystemSettingBody {
  fields?: string[];
}

export interface EngineSystemSettingServiceUpdateSystemSettingBody { [key: string]: unknown }

export interface EngineTeamHookServiceCreateTeamHookBody {
  enabled?: boolean;
  event?: EngineTeamHookEvent;
  properties?: string[];
  schema?: EngineLookup;
}

export interface EngineTeamHookServicePatchTeamHookBody {
  enabled?: boolean;
  event?: EngineTeamHookEvent;
  fields?: string[];
  properties?: string[];
  schema?: EngineLookup;
}

export interface EngineTeamHookServiceUpdateTeamHookBody {
  enabled?: boolean;
  event?: EngineTeamHookEvent;
  properties?: string[];
  schema?: EngineLookup;
}

export interface EngineTeamTriggerServiceCreateTeamTriggerBody {
  description?: string;
  enabled?: boolean;
  name?: string;
  schema?: EngineLookup;
}

export interface EngineTeamTriggerServicePatchTeamTriggerBody {
  description?: string;
  enabled?: boolean;
  fields?: string[];
  name?: string;
  schema?: EngineLookup;
}

export type EngineTeamTriggerServiceRunTeamTriggerBodyVariables = {[key: string]: string};

export interface EngineTeamTriggerServiceRunTeamTriggerBody {
  variables?: EngineTeamTriggerServiceRunTeamTriggerBodyVariables;
}

export interface EngineTeamTriggerServiceUpdateTeamTriggerBody {
  description?: string;
  enabled?: boolean;
  name?: string;
  schema?: EngineLookup;
}

export interface EngineTestEmailProfileResponse {
  error?: string;
}

export type EngineTriggerServiceCreateTriggerJobBodyVariables = {[key: string]: string};

export interface EngineTriggerServiceCreateTriggerJobBody {
  variables?: EngineTriggerServiceCreateTriggerJobBodyVariables;
}

export type EngineTriggerServicePatchTriggerBodyVariables = {[key: string]: string};

export interface EngineTriggerServicePatchTriggerBody {
  description?: string;
  enabled?: boolean;
  event?: EngineTriggerEventType;
  expression?: string;
  fields?: string[];
  name?: string;
  object?: EngineTriggerObjectType;
  schema?: EngineLookup;
  timeout?: number;
  timezone?: EngineLookup;
  type?: EngineTriggerType;
  variables?: EngineTriggerServicePatchTriggerBodyVariables;
}

export type EngineTriggerServiceUpdateTriggerBodyVariables = {[key: string]: string};

export interface EngineTriggerServiceUpdateTriggerBody {
  description?: string;
  enabled?: boolean;
  event?: EngineTriggerEventType;
  expression?: string;
  name?: string;
  object?: EngineTriggerObjectType;
  schema?: EngineLookup;
  timeout?: number;
  timezone?: EngineLookup;
  type?: EngineTriggerType;
  variables?: EngineTriggerServiceUpdateTriggerBodyVariables;
}

export interface EngineWebHookServicePatchWebHookBody {
  authorization?: string;
  description?: string;
  enabled?: boolean;
  fields?: string[];
  name?: string;
  origin?: string[];
  schema?: EngineLookup;
}

export interface EngineWebHookServiceUpdateWebHookBody {
  authorization?: string;
  description?: string;
  enabled?: boolean;
  name?: string;
  origin?: string[];
  schema?: EngineLookup;
}

export interface FtsSearchData {
  id?: string;
  objectName?: string;
  text?: string;
}

export interface FtsSearchResponse {
  items?: FtsSearchData[];
  next?: boolean;
}

export interface GeneralExtendedLookup {
  id?: string;
  name?: string;
  type?: string;
}

export interface GeneralLookup {
  id?: string;
  name?: string;
}

export interface GoogleProtobufAny {
  '@type'?: string;
}

/**
 * `NullValue` is a singleton enumeration to represent the null value for the
`Value` type union.

The JSON representation for `NullValue` is JSON `null`.

 - NULL_VALUE: Null value.
 */
export type GoogleProtobufNullValue = typeof GoogleProtobufNullValue[keyof typeof GoogleProtobufNullValue];


export const GoogleProtobufNullValue = {
  NullValue: 'NULL_VALUE',
} as const;

export interface GoogleRpcStatus {
  code?: number;
  details?: GoogleProtobufAny[];
  message?: string;
}

/**
 * Lookup reference information.
Simplified search filter to uniquely identify related object.
 */
export interface WebitelknowledgebaseLookup {
  /** Reference Object unique ID. */
  id?: string;
  /** Reference Object display name. */
  name?: string;
  /** Reference Object well-known type. */
  type?: string;
}

export interface KnowledgebaseArticle {
  /** Tags associated with the article. */
  tags?: string[];
  /** The user who created this Field. */
  createdAt?: string;
  /** Timestamp(milli) of the Field creation. */
  createdBy?: WebitelknowledgebaseLookup;
  /** Unique ID of the latest version of the update.
This ID changes after any update to the underlying value(s). */
  etag?: string;
  /** Indicates that the article has children. */
  hasChildren?: boolean;
  /** The unique ID of the association. Never changes. */
  id?: string;
  /** The parent article ID. */
  parentArticle?: string;
  /** Indicates that the article is pinned on the top of list. */
  pinned?: boolean;
  /** Space ID associated with. */
  spaceId?: string;
  /** Indicates the state of the article. */
  state?: boolean;
  /** The text content of the article. */
  text?: string;
  /** The title of the article. */
  title?: string;
  /** Timestamp(milli) of the last Field update.
Take part in Etag generation. */
  updatedAt?: string;
  /** The user who performed last Update. */
  updatedBy?: WebitelknowledgebaseLookup;
  /** READONLY. Operational attributes
Version of the latest update. Numeric sequence. */
  ver?: number;
}

/**
 * Article dataset.
NOTE: Edge represents connection between two nodes.
So this spaceArticles.data are always subordinate to some space.id.
 */
export interface KnowledgebaseArticleList {
  /** Article dataset page. */
  data?: KnowledgebaseArticle[];
  next?: boolean;
  /** The page number of the partial result. */
  page?: number;
}

export interface KnowledgebaseArticleVersion {
  /** Tags associated with the article. */
  tags?: string[];
  /** The unique ID of the association. Never changes. */
  id?: string;
  /** The parent article ID. */
  parentArticle?: string;
  /** Space ID associated with. */
  spaceId?: string;
  /** The text content of the article. */
  text?: string;
  /** The title of the article. */
  title?: string;
  /** Timestamp(milli) of the last Field update. */
  updatedAt?: string;
  /** The user who loaded this attachment. */
  updatedBy?: WebitelknowledgebaseLookup;
  /** Version of the latest update. Numeric sequence. */
  ver?: number;
}

export interface KnowledgebaseArticleVersionList {
  data?: KnowledgebaseArticleVersion[];
  next?: boolean;
  /** The page number of the partial result. */
  page?: number;
}

export interface WebitelknowledgebaseAttachment {
  /** The unique ID of the association. Never changes. */
  id?: string;
  /** The size of the attachment. */
  size?: number;
  /** The title of the article. */
  title?: string;
  /** The user who loaded this attachment. */
  uploadedBy?: WebitelknowledgebaseLookup;
}

export interface KnowledgebaseAttachmentList {
  /** Attachment dataset page. */
  data?: WebitelknowledgebaseAttachment[];
  next?: boolean;
  /** The page number of the partial result. */
  page?: number;
}

export interface KnowledgebaseCombined {
  id?: string;
  name?: string;
  type?: string;
}

export interface KnowledgebaseCombinedList {
  data?: KnowledgebaseCombined[];
  next?: boolean;
  /** The page number of the partial result. */
  page?: number;
}

/**
 * An input of the Space's Articles.
 */
export interface KnowledgebaseInputArticle {
  /** Tags associated with the article. */
  tags?: string[];
  /** Unique ID of the latest version of an existing resource. */
  etag: string;
  /** The parent article ID. */
  parentArticle?: string;
  /** Indicates that the article is pinned on the top of list. */
  pinned?: boolean;
  /** [VALUE]: --------------------------------------
Space ID associated with. */
  spaceId?: string;
  /** Indicates if article is active and actual. */
  state?: boolean;
  /** The text content of the article. */
  text?: string;
  /** The title of the article. */
  title?: string;
}

/**
 * The Space principal input.
 */
export interface KnowledgebaseInputSpace {
  /** Unique ID of the latest version of an existing resorce. */
  etag?: string;
  /** BIO. Short description about the space.
OPTIONAL. Multi-lined text. */
  homePage?: string;
  /** Represents the name of the knowledge base space. */
  name?: string;
  /** The state of the space. */
  state?: boolean;
}

export interface KnowledgebaseSpace {
  /** The timestamp when the space was created (in Unix time). */
  createdAt?: string;
  /** The user who created the space. */
  createdBy?: WebitelknowledgebaseLookup;
  /** READONLY. The space's metadata. */
  domain?: WebitelknowledgebaseLookup;
  /** Unique ID of the latest version of the update.
This ID changes after any update to the underlying value(s). */
  etag?: string;
  /** Indicates if the space has children. */
  hasChildren?: boolean;
  /** BIO. Short description about the space. */
  homePage?: string;
  /** The unique ID of the association. Never changes. */
  id?: string;
  /** [R]ecord[b]ased[A]ccess[C]ontrol mode granted. */
  mode?: string;
  /** The name of the space. */
  name?: string;
  /** The state of the space. */
  state?: boolean;
  /** The timestamp when the space was last updated (in Unix time). */
  updatedAt?: string;
  /** The user who last updated the space. */
  updatedBy?: WebitelknowledgebaseLookup;
  /** READONLY. Operational attributes
Version of the latest update. Numeric sequence. */
  ver?: number;
}

export interface KnowledgebaseSpaceList {
  /** Space(s) dataset page. */
  data?: KnowledgebaseSpace[];
  next?: boolean;
  /** The page number of the partial result. */
  page?: number;
}

export interface WebitelknowledgebaseTag {
  /** The name of the tag. */
  name?: string;
}

export interface KnowledgebaseTagsList {
  data?: WebitelknowledgebaseTag[];
  next?: boolean;
  page?: number;
}

export type LoggerAction = typeof LoggerAction[keyof typeof LoggerAction];


export const LoggerAction = {
  DefaultNoAction: 'default_no_action',
  Create: 'create',
  Update: 'update',
  Read: 'read',
  Delete: 'delete',
} as const;

export type LoggerAvailableSystemObjects = typeof LoggerAvailableSystemObjects[keyof typeof LoggerAvailableSystemObjects];


export const LoggerAvailableSystemObjects = {
  CcQueue: 'cc_queue',
  Schema: 'schema',
  Users: 'users',
  Devices: 'devices',
  Calendars: 'calendars',
  CcList: 'cc_list',
  CcTeam: 'cc_team',
  CcAgent: 'cc_agent',
  CcResource: 'cc_resource',
  CcResourceGroup: 'cc_resource_group',
  ChatBots: 'chat_bots',
  Cases: 'cases',
  Contacts: 'contacts',
  CcListNumber: 'cc_list_number',
  CaseComments: 'case_comments',
  RecordFile: 'record_file',
} as const;

export interface LoggerLookup {
  id?: number;
  name?: string;
}

export interface LoggerConfig {
  daysToStore?: number;
  description?: string;
  enabled?: boolean;
  id?: number;
  logsCount?: string;
  logsSize?: string;
  object?: LoggerLookup;
  period?: number;
  storage?: LoggerLookup;
}

export interface LoggerConfigStatus {
  isEnabled?: boolean;
}

export interface LoggerConfigs {
  items?: LoggerConfig[];
  next?: boolean;
  page?: number;
}

export interface LoggerCreateConfigRequest {
  daysToStore?: number;
  description?: string;
  enabled?: boolean;
  object?: LoggerLookup;
  period?: number;
  storage?: LoggerLookup;
}

export interface LoggerEmpty { [key: string]: unknown }

export interface LoggerRecord {
  id?: string;
  name?: string;
}

export interface LoggerLog {
  action?: string;
  configId?: number;
  date?: string;
  id?: number;
  newState?: string;
  object?: LoggerLookup;
  record?: LoggerRecord;
  user?: LoggerLookup;
  userIp?: string;
}

export interface LoggerLogs {
  items?: LoggerLog[];
  next?: boolean;
  page?: number;
}

export interface LoggerSystemObjects {
  items?: LoggerLookup[];
}

export interface ProtobufAny {
  '@type'?: string;
}

/**
 * `NullValue` is a singleton enumeration to represent the null value for the
`Value` type union.

The JSON representation for `NullValue` is JSON `null`.

 - NULL_VALUE: Null value.
 */
export type ProtobufNullValue = typeof ProtobufNullValue[keyof typeof ProtobufNullValue];


export const ProtobufNullValue = {
  NullValue: 'NULL_VALUE',
} as const;

export interface RpcStatus {
  code?: number;
  details?: ProtobufAny[];
  message?: string;
}

export type StorageBackendProfileProperties = {[key: string]: string};

export interface StorageBackendProfile {
  createdAt?: string;
  createdBy?: EngineLookup;
  dataCount?: string;
  dataSize?: string;
  description?: string;
  disabled?: boolean;
  expireDays?: number;
  id?: string;
  maxSize?: string;
  name?: string;
  priority?: number;
  properties?: StorageBackendProfileProperties;
  type?: string;
  updatedAt?: string;
  updatedBy?: EngineLookup;
}

export type StorageBackendProfileServicePatchBackendProfileBodyProperties = {[key: string]: string};

export interface StorageBackendProfileServicePatchBackendProfileBody {
  description?: string;
  disabled?: boolean;
  domainId?: string;
  expireDays?: number;
  fields?: string[];
  maxSize?: string;
  name?: string;
  priority?: number;
  properties?: StorageBackendProfileServicePatchBackendProfileBodyProperties;
}

export type StorageBackendProfileServiceUpdateBackendProfileBodyProperties = {[key: string]: string};

export interface StorageBackendProfileServiceUpdateBackendProfileBody {
  description?: string;
  disabled?: boolean;
  domainId?: string;
  expireDays?: number;
  maxSize?: string;
  name?: string;
  priority?: number;
  properties?: StorageBackendProfileServiceUpdateBackendProfileBodyProperties;
}

export interface StorageGenerateFileLinkResponseMetadata {
  id?: string;
  mimeType?: string;
  name?: string;
  size?: string;
  uuid?: string;
}

export interface StorageGenerateFileLinkResponse {
  baseUrl?: string;
  metadata?: StorageGenerateFileLinkResponseMetadata;
  url?: string;
}

export interface StorageBulkGenerateFileLinkResponse {
  links?: StorageGenerateFileLinkResponse[];
}

export type StorageProviderType = typeof StorageProviderType[keyof typeof StorageProviderType];


export const StorageProviderType = {
  DefaultProvider: 'DefaultProvider',
  Microsoft: 'Microsoft',
  Google: 'Google',
  ElevenLabs: 'ElevenLabs',
} as const;

export type StorageServiceType = typeof StorageServiceType[keyof typeof StorageServiceType];


export const StorageServiceType = {
  DefaultService: 'DefaultService',
  Stt: 'STT',
  Tts: 'TTS',
} as const;

export interface StorageCognitiveProfile {
  createdAt?: string;
  createdBy?: EngineLookup;
  default?: boolean;
  description?: string;
  enabled?: boolean;
  id?: string;
  name?: string;
  provider?: StorageProviderType;
  service?: StorageServiceType;
  updatedAt?: string;
  updatedBy?: EngineLookup;
}

export interface StorageCognitiveProfileServicePatchCognitiveProfileBody {
  default?: boolean;
  description?: string;
  enabled?: boolean;
  fields?: string[];
  name?: string;
  provider?: StorageProviderType;
  service?: StorageServiceType;
}

export interface StorageCognitiveProfileServiceUpdateCognitiveProfileBody {
  default?: boolean;
  description?: string;
  enabled?: boolean;
  name?: string;
  provider?: StorageProviderType;
  service?: StorageServiceType;
}

export interface StorageCognitiveProfileVoice {
  id?: string;
  name?: string;
}

export type StorageCreateBackendProfileRequestProperties = {[key: string]: string};

export interface StorageCreateBackendProfileRequest {
  description?: string;
  disabled?: boolean;
  domainId?: string;
  expireDays?: number;
  maxSize?: string;
  name?: string;
  priority?: number;
  properties?: StorageCreateBackendProfileRequestProperties;
  type?: string;
}

/**
 * Create cognitive profile request body for TTS and TTS
 */
export interface StorageCreateCognitiveProfileRequest {
  default?: boolean;
  description?: string;
  enabled?: boolean;
  name: string;
  provider: StorageProviderType;
  service: StorageServiceType;
}

export type StorageUploadFileChannel = typeof StorageUploadFileChannel[keyof typeof StorageUploadFileChannel];


export const StorageUploadFileChannel = {
  UnknownChannel: 'UnknownChannel',
  ChatChannel: 'ChatChannel',
  MailChannel: 'MailChannel',
  CallChannel: 'CallChannel',
  LogChannel: 'LogChannel',
  MediaChannel: 'MediaChannel',
  KnowledgebaseChannel: 'KnowledgebaseChannel',
  CasesChannel: 'CasesChannel',
  ScreenRecordingChannel: 'ScreenRecordingChannel',
} as const;

export interface StorageCreateFilePolicyRequest {
  channels?: StorageUploadFileChannel[];
  description?: string;
  enabled?: boolean;
  encrypt?: boolean;
  maxUploadSize?: string;
  mimeTypes?: string[];
  name?: string;
  retentionDays?: number;
  speedDownload?: string;
  speedUpload?: string;
}

export type StorageCreateImportTemplateRequestParameters = { [key: string]: unknown };

export type StorageImportSourceType = typeof StorageImportSourceType[keyof typeof StorageImportSourceType];


export const StorageImportSourceType = {
  DefaultSourceType: 'DefaultSourceType',
  Dialer: 'Dialer',
} as const;

/**
 * Create import template for CSV
 */
export interface StorageCreateImportTemplateRequest {
  parameters: StorageCreateImportTemplateRequestParameters;
  description?: string;
  name: string;
  source?: EngineLookup;
  sourceId: string;
  sourceType?: StorageImportSourceType;
}

export interface StorageCustomFileProperties {
  endTime?: string;
  height?: string;
  startTime?: string;
  width?: string;
}

export interface StorageDeleteFileTranscriptRequest {
  id?: string[];
  uuid?: string[];
}

export interface StorageDeleteFileTranscriptResponse {
  items?: string[];
}

export interface StorageDeleteFilesRequest {
  id?: string[];
}

export interface StorageDeleteFilesResponse { [key: string]: unknown }

export interface StorageDeleteQuarantineFilesRequest {
  id?: string[];
}

export interface StorageThumbnail {
  mimeType?: string;
  scale?: string;
  size?: string;
}

export interface StorageFile {
  channel?: StorageUploadFileChannel;
  id?: string;
  mimeType?: string;
  name?: string;
  properties?: StorageCustomFileProperties;
  referenceId?: string;
  retentionUntil?: string;
  sha256Sum?: string;
  size?: string;
  thumbnail?: StorageThumbnail;
  uploadedAt?: string;
  uploadedBy?: EngineLookup;
  uuid?: string;
  viewName?: string;
}

export interface StorageFileMalwareScan {
  description?: string;
  found?: boolean;
  status?: string;
}

export interface StorageFilePoliciesServiceFilePolicyApplyBody {
  applyToNullChannel?: boolean;
}

export interface StorageFilePoliciesServiceMovePositionFilePolicyBody { [key: string]: unknown }

export interface StorageFilePoliciesServicePatchFilePolicyBody {
  channels?: StorageUploadFileChannel[];
  description?: string;
  enabled?: boolean;
  encrypt?: boolean;
  fields?: string[];
  maxUploadSize?: string;
  mimeTypes?: string[];
  name?: string;
  retentionDays?: number;
  speedDownload?: string;
  speedUpload?: string;
}

export interface StorageFilePoliciesServiceUpdateFilePolicyBody {
  channels?: StorageUploadFileChannel[];
  description?: string;
  enabled?: boolean;
  encrypt?: boolean;
  maxUploadSize?: string;
  mimeTypes?: string[];
  name?: string;
  retentionDays?: number;
  speedDownload?: string;
  speedUpload?: string;
}

export interface StorageFilePolicy {
  channels?: StorageUploadFileChannel[];
  createdAt?: string;
  createdBy?: EngineLookup;
  description?: string;
  enabled?: boolean;
  encrypt?: boolean;
  id?: number;
  maxUploadSize?: string;
  mimeTypes?: string[];
  name?: string;
  position?: number;
  retentionDays?: number;
  speedDownload?: string;
  speedUpload?: string;
  updatedAt?: string;
  updatedBy?: EngineLookup;
}

export interface StorageFilePolicyApplyResponse {
  count?: string;
}

export interface StorageFileServiceDeleteScreenRecordingsBody { [key: string]: unknown }

export interface StorageFileServiceDeleteScreenRecordingsByAgentBody { [key: string]: unknown }

export interface StorageFileTranscriptSafeResponse {
  createdAt?: string;
  file?: EngineLookup;
  id?: string;
  locale?: string;
  profile?: EngineLookup;
  transcript?: string;
}

export type StorageGenerateFileLinkRequestQuery = {[key: string]: string};

export interface StorageGenerateFileLinkRequest {
  action?: string;
  domainId?: string;
  fileId?: string;
  metadata?: boolean;
  query?: StorageGenerateFileLinkRequestQuery;
  source?: string;
}

export type StorageImportTemplateParameters = { [key: string]: unknown };

export interface StorageImportTemplate {
  parameters?: StorageImportTemplateParameters;
  description?: string;
  id?: number;
  name?: string;
  source?: EngineLookup;
  sourceId?: string;
  sourceType?: StorageImportSourceType;
}

export type StorageImportTemplateServicePatchImportTemplateBodyParameters = { [key: string]: unknown };

/**
 * Patch import template for CSV
 */
export interface StorageImportTemplateServicePatchImportTemplateBody {
  parameters?: StorageImportTemplateServicePatchImportTemplateBodyParameters;
  description?: string;
  fields?: string[];
  name?: string;
}

export type StorageImportTemplateServiceUpdateImportTemplateBodyParameters = { [key: string]: unknown };

/**
 * Update import template for CSV
 */
export interface StorageImportTemplateServiceUpdateImportTemplateBody {
  parameters?: StorageImportTemplateServiceUpdateImportTemplateBodyParameters;
  description?: string;
  name: string;
  source?: EngineLookup;
}

export interface StorageListBackendProfile {
  items?: StorageBackendProfile[];
  next?: boolean;
}

export interface StorageListCognitiveProfile {
  items?: StorageCognitiveProfile[];
  next?: boolean;
}

export interface StorageListCognitiveProfileVoices {
  items?: StorageCognitiveProfileVoice[];
}

export interface StorageListFile {
  items?: StorageFile[];
  next?: boolean;
}

export interface StorageListFilePolicies {
  items?: StorageFilePolicy[];
  next?: boolean;
}

export interface StorageListImportTemplate {
  items?: StorageImportTemplate[];
  next?: boolean;
}

export interface StorageMediaFile {
  createdAt?: string;
  createdBy?: EngineLookup;
  id?: string;
  mimeType?: string;
  name?: string;
  size?: string;
  updatedAt?: string;
  updatedBy?: EngineLookup;
}

export interface StorageListMedia {
  items?: StorageMediaFile[];
  next?: boolean;
}

export interface StorageTranscriptPhrase {
  channel?: number;
  endSec?: number;
  phrase?: string;
  startSec?: number;
}

export interface StorageListPhrases {
  items?: StorageTranscriptPhrase[];
  next?: boolean;
}

export interface StorageMovePositionFilePolicyResponse {
  success?: boolean;
}

export interface StoragePutFileTranscriptRequest {
  fileId?: string;
  locale?: string;
  phrases?: StorageTranscriptPhrase[];
  text?: string;
  uuid?: string;
}

export interface StoragePutFileTranscriptResponse {
  id?: string;
}

export interface StorageRestoreFilesRequest {
  id?: string[];
}

export interface StorageRestoreFilesResponse { [key: string]: unknown }

export interface StorageSafeUploadFileRequestMetadata {
  channel?: StorageUploadFileChannel;
  domainId?: string;
  generateThumbnail?: boolean;
  mimeType?: string;
  name?: string;
  profileId?: string;
  progress?: boolean;
  properties?: StorageCustomFileProperties;
  streamResponse?: boolean;
  uuid?: string;
}

export type StorageUploadStatusCode = typeof StorageUploadStatusCode[keyof typeof StorageUploadStatusCode];


export const StorageUploadStatusCode = {
  Unknown: 'Unknown',
  Ok: 'Ok',
  Failed: 'Failed',
} as const;

export interface StorageSafeUploadFileResponseMetadata {
  code?: StorageUploadStatusCode;
  fileId?: string;
  fileUrl?: string;
  malware?: StorageFileMalwareScan;
  mimeType?: string;
  name?: string;
  server?: string;
  sha256Sum?: string;
  size?: string;
  thumbnail?: StorageThumbnail;
  uuid?: string;
}

export interface StorageSafeUploadFileResponsePart {
  size?: string;
  uploadId?: string;
}

export interface StorageSafeUploadFileResponseProgress {
  uploaded?: string;
}

export interface StorageSafeUploadFileResponse {
  metadata?: StorageSafeUploadFileResponseMetadata;
  part?: StorageSafeUploadFileResponsePart;
  progress?: StorageSafeUploadFileResponseProgress;
}

export type StorageScreenrecordingChannel = typeof StorageScreenrecordingChannel[keyof typeof StorageScreenrecordingChannel];


export const StorageScreenrecordingChannel = {
  Screenrecording: 'SCREENRECORDING',
  Call: 'CALL',
} as const;

export type StorageScreenrecordingType = typeof StorageScreenrecordingType[keyof typeof StorageScreenrecordingType];


export const StorageScreenrecordingType = {
  Pdf: 'PDF',
  Screenshot: 'SCREENSHOT',
  Screensharing: 'SCREENSHARING',
} as const;

export interface StorageStartFileTranscriptRequest {
  fileId?: string[];
  locale?: string;
  profile?: EngineLookup;
  uuid?: string[];
}

export interface StorageStartFileTranscriptResponseTranscriptJob {
  action?: string;
  createdAt?: string;
  fileId?: string;
  id?: string;
  state?: string;
}

export interface StorageStartFileTranscriptResponse {
  items?: StorageStartFileTranscriptResponseTranscriptJob[];
}

export interface StorageStreamFileMetadata {
  id?: string;
  mimeType?: string;
  name?: string;
  sha256Sum?: string;
  size?: string;
  thumbnail?: StorageThumbnail;
  uuid?: string;
}

export interface StorageStreamFile {
  chunk?: string;
  metadata?: StorageStreamFileMetadata;
}

export interface StorageUploadFileRequestMetadata {
  channel?: StorageUploadFileChannel;
  createdAt?: string;
  domainId?: string;
  generateThumbnail?: boolean;
  mimeType?: string;
  name?: string;
  profileId?: string;
  properties?: StorageCustomFileProperties;
  streamResponse?: boolean;
  uploadedBy?: string;
  uuid?: string;
}

export interface StorageUploadFileResponse {
  code?: StorageUploadStatusCode;
  fileId?: string;
  fileUrl?: string;
  malware?: StorageFileMalwareScan;
  server?: string;
  sha256Sum?: string;
  size?: string;
  thumbnail?: StorageThumbnail;
}

export interface StorageUploadFileUrlResponse {
  code?: StorageUploadStatusCode;
  id?: string;
  malware?: StorageFileMalwareScan;
  mime?: string;
  server?: string;
  sha256Sum?: string;
  size?: string;
  thumbnail?: StorageThumbnail;
  url?: string;
}

export interface WebMeetingBackendCreateMeetingResponse {
  id?: string;
  url?: string;
}

export interface WebMeetingBackendDeleteMeetingResponse { [key: string]: unknown }

export type WebMeetingBackendMeetingVariables = {[key: string]: string};

export interface WebMeetingBackendMeeting {
  allowSatisfaction?: boolean;
  createdAt?: string;
  expiresAt?: string;
  id?: string;
  satisfaction?: string;
  title?: string;
  url?: string;
  variables?: WebMeetingBackendMeetingVariables;
}

export interface WebMeetingBackendMeetingServiceSatisfactionMeetingBody {
  satisfaction?: string;
}

export interface WebMeetingBackendMeetingView {
  allowSatisfaction?: boolean;
  createdAt?: string;
  expiresAt?: string;
  satisfaction?: string;
  title?: string;
}

export interface WebMeetingBackendSatisfactionMeetingResponse { [key: string]: unknown }

export interface WebitelCasesAttachment {
  id?: string;
  mime?: string;
  name?: string;
  size?: string;
  url?: string;
}

export interface WebitelCasesCallFile {
  id?: string;
  mimeType?: string;
  name?: string;
  size?: string;
  startAt?: string;
  stopAt?: string;
}

export interface WebitelCasesTranscriptLookup {
  file?: GeneralLookup;
  id?: string;
  locale?: string;
}

export interface WebitelCasesCallEvent {
  closedAt?: string;
  duration?: string;
  files?: WebitelCasesCallFile[];
  flowScheme?: GeneralLookup;
  gateway?: GeneralLookup;
  id?: string;
  isDetailed?: boolean;
  isInbound?: boolean;
  isMissed?: boolean;
  participants?: GeneralLookup[];
  queue?: GeneralLookup;
  totalDuration?: string;
  transcripts?: WebitelCasesTranscriptLookup[];
}

/**
 * Custom data extension fields ..
 */
export type WebitelCasesCaseCustom = { [key: string]: unknown };

/**
 * Represents a comment associated with a case.
 */
export interface WebitelCasesCaseComment {
  /** Contact-author of the comment. */
  author?: GeneralLookup;
  /** Indicates if the comment can be edited by current user. */
  canEdit?: boolean;
  /** Optional relation to the associated case. */
  caseId?: string;
  /** Timestamp (in milliseconds) of when the comment was created. */
  createdAt?: string;
  /** User who created the comment. */
  createdBy?: GeneralLookup;
  /** Indicates if the comment was edited; true if created_at < updated_at. */
  edited?: boolean;
  etag?: string;
  /** Main identifier for read, update, and delete operations. */
  id?: string;
  roleIds?: string[];
  /** The content of the comment. */
  text?: string;
  /** Timestamp (in milliseconds) of the last update. */
  updatedAt?: string;
  /** User who last updated the comment. */
  updatedBy?: GeneralLookup;
  /** Version number of the comment, used for concurrency control. */
  ver?: number;
}

/**
 * Contains a paginated list of comments.
 */
export interface WebitelCasesCaseCommentList {
  /** List of comments on the current page. */
  items?: WebitelCasesCaseComment[];
  /** Flag to indicate if more pages are available. */
  next?: boolean;
  /** Current page number. */
  page?: string;
}

/**
 * Metadata for a file associated with a case.
 */
export interface WebitelCasesFile {
  /** Creation timestamp in Unix milliseconds. */
  createdAt?: string;
  /** Creator of the file. */
  createdBy?: GeneralExtendedLookup;
  /** Storage file ID. */
  id?: string;
  /** MIME type of the file. */
  mime?: string;
  /** File name. */
  name?: string;
  /** File size in bytes. */
  size?: string;
  source?: string;
  url?: string;
}

/**
 * Contains a list of case files with pagination.
 */
export interface WebitelCasesCaseFileList {
  /** List of case files. */
  items?: WebitelCasesFile[];
  /** Indicator if there is a next page. */
  next?: boolean;
  /** Current page number. */
  page?: string;
}

export interface WebitelCasesCaseLink {
  author?: GeneralLookup;
  createdAt?: string;
  createdBy?: GeneralLookup;
  etag?: string;
  id?: string;
  name?: string;
  updatedAt?: string;
  updatedBy?: GeneralLookup;
  url?: string;
  ver?: number;
}

export interface WebitelCasesCaseLinkList {
  items?: WebitelCasesCaseLink[];
  next?: boolean;
  page?: string;
}

export interface WebitelCasesPriority {
  color?: string;
  createdAt?: string;
  createdBy?: GeneralLookup;
  description?: string;
  id?: string;
  name?: string;
  updatedAt?: string;
  updatedBy?: GeneralLookup;
}

/**
 * RelatedCaseLookup is created specifically to include the subject field.
 */
export interface WebitelCasesRelatedCaseLookup {
  color?: string;
  etag?: string;
  id?: string;
  name?: string;
  subject?: string;
  ver?: number;
}

/**
 * Enum for relation types between cases.
 */
export type WebitelCasesRelationType = typeof WebitelCasesRelationType[keyof typeof WebitelCasesRelationType];


export const WebitelCasesRelationType = {
  RelationTypeUnspecified: 'RELATION_TYPE_UNSPECIFIED',
  Duplicates: 'DUPLICATES',
  IsDuplicatedBy: 'IS_DUPLICATED_BY',
  Blocks: 'BLOCKS',
  IsBlockedBy: 'IS_BLOCKED_BY',
  Causes: 'CAUSES',
  IsCausedBy: 'IS_CAUSED_BY',
  IsChildOf: 'IS_CHILD_OF',
  IsParentOf: 'IS_PARENT_OF',
  RelatesTo: 'RELATES_TO',
} as const;

/**
 * Represents a related case with its relationship details.
 */
export interface WebitelCasesRelatedCase {
  /** Timestamp (in milliseconds) of when the relation was created. */
  createdAt?: string;
  /** User who created the relation. */
  createdBy?: GeneralLookup;
  /** Etag for the related case entity. */
  etag?: string;
  /** Unique identifier for the related case. */
  id?: string;
  /** Primary case details. */
  primaryCase?: WebitelCasesRelatedCaseLookup;
  /** Related case details. */
  relatedCase?: WebitelCasesRelatedCaseLookup;
  /** Relation type between cases. */
  relationType?: WebitelCasesRelationType;
  /** Timestamp (in milliseconds) of the last update. */
  updatedAt?: string;
  /** User who last updated the relation. */
  updatedBy?: GeneralLookup;
  /** Version number of the related case, used for concurrency control. */
  ver?: number;
}

/**
 * Paginated list of related cases.
 */
export interface WebitelCasesRelatedCaseList {
  /** List of related cases on the current page. */
  data?: WebitelCasesRelatedCase[];
  /** Flag to indicate if more pages are available. */
  next?: boolean;
  /** Current page number. */
  page?: string;
}

export interface WebitelCasesService {
  assignee?: GeneralLookup;
  catalogId?: string;
  code?: string;
  createdAt?: string;
  createdBy?: GeneralLookup;
  description?: string;
  group?: GeneralExtendedLookup;
  id?: string;
  name?: string;
  rootId?: string;
  searched?: boolean;
  service?: WebitelCasesService[];
  sla?: GeneralLookup;
  state?: boolean;
  updatedAt?: string;
  updatedBy?: GeneralLookup;
}

/**
 * Represents a source type for the source entity.

 - TYPE_UNSPECIFIED: Unspecified source type.
 - CALL: Phone call source type.
 - CHAT: Chat source type.
 - SOCIAL_MEDIA: Social media source type.
 - EMAIL: Email source type.
 - API: API source type.
 - MANUAL: Manual source type.
 */
export type WebitelCasesSourceType = typeof WebitelCasesSourceType[keyof typeof WebitelCasesSourceType];


export const WebitelCasesSourceType = {
  TypeUnspecified: 'TYPE_UNSPECIFIED',
  Call: 'CALL',
  Chat: 'CHAT',
  SocialMedia: 'SOCIAL_MEDIA',
  Email: 'EMAIL',
  Api: 'API',
  Manual: 'MANUAL',
} as const;

export interface WebitelCasesSourceTypeLookup {
  id?: string;
  name?: string;
  type?: WebitelCasesSourceType;
}

export interface WebitelCasesStatusCondition {
  createdAt?: string;
  createdBy?: GeneralLookup;
  description?: string;
  final?: boolean;
  id?: string;
  initial?: boolean;
  name?: string;
  statusId?: string;
  updatedAt?: string;
  updatedBy?: GeneralLookup;
}

/**
 * Message representing a case.
 */
export interface WebitelCasesCase {
  /** Assignee responsible for resolving the case. */
  assignee?: GeneralLookup;
  /** Author or reporter of the case. */
  author?: GeneralLookup;
  closeReason?: GeneralLookup;
  /** Close reason group, immutable once set. */
  closeReasonGroup?: GeneralLookup;
  closeResult?: string;
  /** List of comments on the case. */
  comments?: WebitelCasesCaseCommentList;
  /** Contact information for the case. */
  contactInfo?: string;
  /** Creation timestamp (in milliseconds since Unix epoch). */
  createdAt?: string;
  /** Creator of the case. */
  createdBy?: GeneralLookup;
  /** Custom data extension fields .. */
  custom?: WebitelCasesCaseCustom;
  dc?: string;
  /** Detailed description of the case. */
  description?: string;
  differenceInReaction?: string;
  differenceInResolve?: string;
  /** Unique etag identifier. */
  etag?: string;
  /** List of attached files. */
  files?: WebitelCasesCaseFileList;
  /** Group associated with the case. */
  group?: GeneralExtendedLookup;
  /** Unique case ID. */
  id?: string;
  /** Impacted contact (defaults to reporter if null). */
  impacted?: GeneralLookup;
  /** List of attached links. */
  links?: WebitelCasesCaseLinkList;
  /** Name of the case (may serve as an ID in docs). */
  name?: string;
  /** Planned reaction time (in milliseconds). */
  plannedReactionAt?: string;
  /** Planned resolution time (in milliseconds). */
  plannedResolveAt?: string;
  /** Priority level of the case. */
  priority?: WebitelCasesPriority;
  rating?: string;
  ratingComment?: string;
  reactedAt?: string;
  /** List of related cases. */
  related?: WebitelCasesRelatedCaseList;
  /** Reporter of the issue (null if anonymous). */
  reporter?: GeneralLookup;
  resolvedAt?: string;
  roleIds?: string[];
  /** Service associated with the case. */
  service?: WebitelCasesService;
  /** SLA associated with the case. */
  sla?: GeneralLookup;
  /** List of SLA conditions. */
  slaCondition?: GeneralLookup;
  /** Source of the case. */
  source?: WebitelCasesSourceTypeLookup;
  /** Current status of the case. */
  status?: GeneralLookup;
  /** Status condition from status lookup. */
  statusCondition?: WebitelCasesStatusCondition;
  /** Subject of the case. */
  subject?: string;
  /** Last update timestamp (in milliseconds since Unix epoch). */
  updatedAt?: string;
  /** Last updater of the case. */
  updatedBy?: GeneralLookup;
  /** Version number of the case. */
  ver?: number;
}

/**
 * Represents a single case communication.
 */
export interface WebitelCasesCaseCommunication {
  /** External communication ID. */
  communicationId?: string;
  /** Type of the communication (e.g., Chat, Call). */
  communicationType?: GeneralLookup;
  /** Version of the communication record. */
  etag?: string;
  /** Database ID of the communication. */
  id?: string;
  /** Version of the communication record. */
  ver?: number;
}

/**
 * Response message containing a list of cases.
 */
export interface WebitelCasesCaseList {
  /** List of cases. */
  items?: WebitelCasesCase[];
  /** Flag indicating if there are more pages. */
  next?: boolean;
  /** Current page number. */
  page?: string;
}

export type WebitelCasesCaseTimelineEventType = typeof WebitelCasesCaseTimelineEventType[keyof typeof WebitelCasesCaseTimelineEventType];


export const WebitelCasesCaseTimelineEventType = {
  Chat: 'chat',
  Call: 'call',
  Email: 'email',
} as const;

export interface WebitelCasesCatalog {
  closeReasonGroup?: GeneralLookup;
  code?: string;
  createdAt?: string;
  createdBy?: GeneralLookup;
  description?: string;
  id?: string;
  name?: string;
  prefix?: string;
  searched?: boolean;
  service?: WebitelCasesService[];
  skills?: GeneralLookup[];
  sla?: GeneralLookup;
  state?: boolean;
  status?: GeneralLookup;
  teams?: GeneralLookup[];
  updatedAt?: string;
  updatedBy?: GeneralLookup;
}

export interface WebitelCasesCatalogList {
  items?: WebitelCasesCatalog[];
  next?: boolean;
  page?: number;
}

export interface WebitelCasesChatEvent {
  closedAt?: string;
  duration?: string;
  flowScheme?: GeneralLookup;
  gateway?: GeneralExtendedLookup;
  id?: string;
  isDetailed?: boolean;
  isInbound?: boolean;
  isMissed?: boolean;
  participants?: GeneralLookup[];
  queue?: GeneralLookup;
}

export interface WebitelCasesCloseReason {
  closeReasonGroupId?: string;
  createdAt?: string;
  createdBy?: GeneralLookup;
  description?: string;
  id?: string;
  name?: string;
  updatedAt?: string;
  updatedBy?: GeneralLookup;
}

export interface WebitelCasesCloseReasonGroup {
  createdAt?: string;
  createdBy?: GeneralLookup;
  description?: string;
  id?: string;
  name?: string;
  updatedAt?: string;
  updatedBy?: GeneralLookup;
}

export interface WebitelCasesCloseReasonGroupList {
  items?: WebitelCasesCloseReasonGroup[];
  next?: boolean;
  page?: number;
}

export interface WebitelCasesCloseReasonList {
  items?: WebitelCasesCloseReason[];
  next?: boolean;
  page?: number;
}

/**
 * Structure for related cases input when creating a case.
 */
export interface WebitelCasesCreateCaseRelatedCaseInput {
  /** Etag of the related case. */
  etag?: string;
  /** Identifier of the related case. */
  relatedTo?: string;
  /** Type of relation (e.g., duplicate, linked). */
  relationType?: WebitelCasesRelationType;
}

/**
 * Input for creating a related case.
 */
export interface WebitelCasesCreateInputRelatedCase {
  /** Related case details. */
  relatedCase?: GeneralLookup;
  /** Relation type between the cases. */
  relationType?: WebitelCasesRelationType;
  /** Optional creator / updater ID. Use this to explicitly set the case creator / updater instead of deriving it from the auth token. */
  userId?: GeneralLookup;
}

export interface WebitelCasesEmailEvent {
  attachments?: WebitelCasesAttachment[];
  body?: string;
  cc?: string[];
  from?: string[];
  html?: string;
  id?: string;
  isDetailed?: boolean;
  isInbound?: boolean;
  owner?: GeneralLookup;
  profile?: GeneralLookup;
  sender?: string[];
  subject?: string;
  to?: string[];
}

export interface WebitelCasesEvent {
  call?: WebitelCasesCallEvent;
  chat?: WebitelCasesChatEvent;
  createdAt?: string;
  email?: WebitelCasesEmailEvent;
  type?: WebitelCasesCaseTimelineEventType;
}

export interface WebitelCasesDayTimeline {
  callsCount?: string;
  chatsCount?: string;
  dayTimestamp?: string;
  emailsCount?: string;
  items?: WebitelCasesEvent[];
}

export interface WebitelCasesFieldChange {
  field?: string;
  newValue?: unknown;
  oldValue?: unknown;
}

export interface WebitelCasesGetTimelineCounterResponse {
  callsCount?: string;
  chatsCount?: string;
  dateFrom?: string;
  dateTo?: string;
  emailsCount?: string;
}

export interface WebitelCasesGetTimelineResponse {
  days?: WebitelCasesDayTimeline[];
  next?: boolean;
  page?: number;
}

/**
 * Custom data extension fields ..
 */
export type WebitelCasesInputCaseCustom = { [key: string]: unknown };

export interface WebitelCasesInputCase {
  assignee?: GeneralLookup;
  closeReason?: GeneralLookup;
  closeResult?: string;
  contactInfo?: string;
  /** Custom data extension fields .. */
  custom?: WebitelCasesInputCaseCustom;
  description?: string;
  etag?: string;
  group?: GeneralLookup;
  impacted?: GeneralLookup;
  priority?: GeneralLookup;
  rating?: string;
  ratingComment?: string;
  reporter?: GeneralLookup;
  service?: GeneralLookup;
  source?: GeneralLookup;
  status?: GeneralLookup;
  statusCondition?: WebitelCasesStatusCondition;
  subject?: string;
  /** Optional creator / updater ID. Use this to explicitly set the case creator / updater instead of deriving it from the auth token. */
  userId?: GeneralLookup;
}

/**
 * Input structure for creating or updating a case comment.
 */
export interface WebitelCasesInputCaseComment {
  /** Identifier for the comment. */
  etag?: string;
  /** Content of the comment. */
  text?: string;
  /** Optional creator / updater ID. Use this to explicitly set the case creator / updater instead of deriving it from the auth token. */
  userId?: GeneralLookup;
}

/**
 * Represents input data for creating or linking a communication.
 */
export interface WebitelCasesInputCaseCommunication {
  /** External communication ID. */
  communicationId?: string;
  /** Type of the communication. */
  communicationType?: GeneralLookup;
}

export interface WebitelCasesInputCaseLink {
  etag?: string;
  name?: string;
  url?: string;
  /** Optional creator / updater ID. Use this to explicitly set the case creator / updater instead of deriving it from the auth token. */
  userId?: GeneralLookup;
}

export interface WebitelCasesInputCatalog {
  closeReasonGroup?: GeneralLookup;
  code?: string;
  description?: string;
  name?: string;
  prefix?: string;
  skills?: GeneralLookup[];
  sla?: GeneralLookup;
  state?: boolean;
  status?: GeneralLookup;
  teams?: GeneralLookup[];
}

export interface WebitelCasesInputCloseReason {
  description?: string;
  name?: string;
}

export interface WebitelCasesInputCloseReasonGroup {
  description?: string;
  name?: string;
}

/**
 * Custom data extension fields ..
 */
export type WebitelCasesInputCreateCaseCustom = { [key: string]: unknown };

/**
 * Input structure for creating a new case.
 */
export interface WebitelCasesInputCreateCase {
  /** Optional assignee ID. */
  assignee?: GeneralLookup;
  /** Optional close information. */
  closeReason?: GeneralLookup;
  /** Optional close reason. */
  closeReasonGroup?: GeneralLookup;
  /** Optional close information. */
  closeResult?: string;
  /** Optional contact information. */
  contactInfo?: string;
  /** Custom data extension fields .. */
  custom?: WebitelCasesInputCreateCaseCustom;
  /** Optional description of the case. */
  description?: string;
  /** Optional group ID. */
  group?: GeneralLookup;
  /** Required impacted user ID (default: reporter). */
  impacted?: GeneralLookup;
  /** List of links attached to the case. */
  links?: WebitelCasesInputCaseLink[];
  /** Optional priority level. */
  priority?: GeneralLookup;
  /** API-only rating information. */
  rating?: string;
  /** API-only rating information. */
  ratingComment?: string;
  /** List of related cases. */
  related?: WebitelCasesCreateCaseRelatedCaseInput[];
  /** Required reporter ID (if empty, anonymous contact). */
  reporter?: GeneralLookup;
  /** Service ID (affects many other readonly fields). */
  service?: GeneralLookup;
  /** Source of the case. */
  source?: GeneralLookup;
  /** Initial case status (default from lookup or UI). */
  status?: GeneralLookup;
  statusCondition?: GeneralLookup;
  /** Required subject of the case. */
  subject?: string;
  /** Optional creator / updater ID. Use this to explicitly set the case creator / updater instead of deriving it from the auth token. */
  userId?: GeneralLookup;
}

export interface WebitelCasesInputCreateService {
  assignee?: GeneralLookup;
  catalogId?: string;
  code?: string;
  description?: string;
  group?: GeneralExtendedLookup;
  name?: string;
  rootId?: string;
  sla?: GeneralLookup;
  state?: boolean;
}

export interface WebitelCasesInputCreateStatusCondition {
  description?: string;
  name?: string;
}

export interface WebitelCasesInputPriority {
  color?: string;
  description?: string;
  name?: string;
}

/**
 * Input for creating or updating a related case.
 */
export interface WebitelCasesInputRelatedCase {
  /** Primary case details. */
  primaryCase?: GeneralLookup;
  /** Related case details. */
  relatedCase?: GeneralLookup;
  /** Relation type. */
  relationType?: WebitelCasesRelationType;
  /** Optional creator / updater ID. Use this to explicitly set the case creator / updater instead of deriving it from the auth token. */
  userId?: GeneralLookup;
}

export interface WebitelCasesInputSLA {
  calendar?: GeneralLookup;
  description?: string;
  name?: string;
  reactionTime?: string;
  resolutionTime?: string;
  validFrom?: string;
  validTo?: string;
}

export interface WebitelCasesInputSLACondition {
  name?: string;
  priorities?: GeneralLookup[];
  reactionTime?: string;
  resolutionTime?: string;
}

export interface WebitelCasesInputService {
  assignee?: GeneralLookup;
  catalogId?: string;
  code?: string;
  description?: string;
  group?: GeneralExtendedLookup;
  name?: string;
  rootId?: string;
  sla?: GeneralLookup;
  state?: boolean;
}

/**
 * The data structure representing a source
 */
export interface WebitelCasesInputSource {
  /**
   * A short description of the source
   * @maxLength 500
   */
  description?: string;
  /**
   * The name of the source
   * @minLength 2
   * @maxLength 100
   */
  name: string;
  /** The type of the source */
  type: WebitelCasesSourceType;
}

export interface WebitelCasesInputStatus {
  description?: string;
  name?: string;
}

export interface WebitelCasesInputStatusCondition {
  description?: string;
  final?: boolean;
  initial?: boolean;
  name?: string;
}

/**
 * Response message after linking communications to a case.
 */
export interface WebitelCasesLinkCommunicationResponse {
  /** List of linked communications. */
  data?: WebitelCasesCaseCommunication[];
}

/**
 * Response message for listing communications linked to a case.
 */
export interface WebitelCasesListCommunicationsResponse {
  /** List of communications. */
  data?: WebitelCasesCaseCommunication[];
  next?: boolean;
  /** Current page number. */
  page?: number;
}

export interface WebitelCasesLocateCatalogResponse {
  catalog?: WebitelCasesCatalog;
}

export interface WebitelCasesLocateCloseReasonGroupResponse {
  closeReasonGroup?: WebitelCasesCloseReasonGroup;
}

export interface WebitelCasesLocateCloseReasonResponse {
  closeReason?: WebitelCasesCloseReason;
}

export interface WebitelCasesLocatePriorityResponse {
  priority?: WebitelCasesPriority;
}

export interface WebitelCasesSLACondition {
  createdAt?: string;
  createdBy?: GeneralLookup;
  id?: string;
  name?: string;
  priorities?: GeneralLookup[];
  reactionTime?: string;
  resolutionTime?: string;
  slaId?: string;
  updatedAt?: string;
  updatedBy?: GeneralLookup;
}

export interface WebitelCasesLocateSLAConditionResponse {
  slaCondition?: WebitelCasesSLACondition;
}

export interface WebitelCasesSLA {
  calendar?: GeneralLookup;
  createdAt?: string;
  createdBy?: GeneralLookup;
  description?: string;
  id?: string;
  name?: string;
  reactionTime?: string;
  resolutionTime?: string;
  updatedAt?: string;
  updatedBy?: GeneralLookup;
  validFrom?: string;
  validTo?: string;
}

export interface WebitelCasesLocateSLAResponse {
  sla?: WebitelCasesSLA;
}

export interface WebitelCasesLocateServiceResponse {
  service?: WebitelCasesService;
}

/**
 * Represents a data source in the contact management system.
 */
export interface WebitelCasesSource {
  /** Unix timestamp representing when the source was created. */
  createdAt: string;
  /** Reference to the user who originally created this source. */
  createdBy: GeneralLookup;
  /**
   * An optional longer explanation of the source's purpose.
   * @maxLength 500
   */
  description?: string;
  /** Unique identifier for the source, generated automatically. */
  id: string;
  /**
   * A unique, descriptive name for the source.
   * @minLength 3
   * @maxLength 100
   */
  name: string;
  /** The type of data source represented by this entry. */
  type: WebitelCasesSourceType;
  /** Unix timestamp representing the most recent update. */
  updatedAt: string;
  /** Reference to the user who most recently modified this source. */
  updatedBy: GeneralLookup;
}

/**
 * Response message for locating a source.
 */
export interface WebitelCasesLocateSourceResponse {
  /** The located source. */
  source?: WebitelCasesSource;
}

export interface WebitelCasesLocateStatusConditionResponse {
  status?: WebitelCasesStatusCondition;
}

export interface WebitelCasesStatus {
  createdAt?: string;
  createdBy?: GeneralLookup;
  description?: string;
  id?: string;
  name?: string;
  updatedAt?: string;
  updatedBy?: GeneralLookup;
}

export interface WebitelCasesLocateStatusResponse {
  status?: WebitelCasesStatus;
}

export interface WebitelCasesPriorityList {
  items?: WebitelCasesPriority[];
  next?: boolean;
  page?: number;
}

export interface WebitelCasesSLAConditionList {
  items?: WebitelCasesSLACondition[];
  next?: boolean;
  page?: number;
}

export interface WebitelCasesSLAList {
  items?: WebitelCasesSLA[];
  next?: boolean;
  page?: number;
}

export interface WebitelCasesServiceList {
  items?: WebitelCasesService[];
  next?: boolean;
  page?: number;
}

/**
 * A list of sources.
 */
export interface WebitelCasesSourceList {
  /** List of sources. */
  items?: WebitelCasesSource[];
  /** Have more records. */
  next?: boolean;
  /** Page number of the partial result. */
  page?: number;
}

export interface WebitelCasesStatusConditionList {
  items?: WebitelCasesStatusCondition[];
  next?: boolean;
  page?: number;
}

export interface WebitelCasesStatusList {
  items?: WebitelCasesStatus[];
  next?: boolean;
  page?: number;
}

/**
 * Response message after unlinking a communication from a case.
 */
export interface WebitelCasesUnlinkCommunicationResponse {
  /** Affected rows. */
  affected?: string;
}

export interface WebitelCasesUpdateCaseResponse {
  case?: WebitelCasesCase;
  changes?: WebitelCasesFieldChange[];
}

/**
 * Peer contact.
 */
export interface WebitelChatPeer {
  /** Contact unique **ID**entifier.
Contact **type**-specific string. */
  id?: string;
  /** Contact display **name**. */
  name?: string;
  /** Contact **type** provider. */
  type?: string;
}

export interface WebitelChatChatInvite {
  date?: string;
  from?: string;
}

/**
 * Context. Variables.
 */
export type WebitelChatChatContext = {[key: string]: string};

/**
 * The Chat info.
Alias: participant, subscriber, member, peer, leg.
 */
export interface WebitelChatChat {
  /** Context. Variables. */
  context?: WebitelChatChatContext;
  /** [D]omain[C]omponent primary ID. */
  dc?: string;
  /** Unique identifier for this chat.
[FROM] Member / Channel ID.

// [TO] Group. Conversation ID.
 string chat_id = 2; */
  id?: string;
  /** OPTIONAL. Invite[d] BY member info. */
  invite?: WebitelChatChatInvite;
  /** OPTIONAL. A non-zero value indicates that
the participant has joined the chat. */
  join?: string;
  left?: string;
  /** [FROM]: User identity. Seed. */
  peer?: WebitelChatPeer;
  queue?: WebitelChatPeer;
  /** [TO]: Chat title. */
  title?: string;
  /** [FROM] VIA text gateway profile. */
  via?: WebitelChatPeer;
}

/**
 * Media File.
 */
export interface WebitelChatFile {
  id?: string;
  name?: string;
  size?: string;
  type?: string;
  url?: string;
}

/**
 * - phone: Phone Number
 - email: Email Address
 - contact: General Form
 - location: Current Location
 */
export type WebitelChatButtonRequest = typeof WebitelChatButtonRequest[keyof typeof WebitelChatButtonRequest];


export const WebitelChatButtonRequest = {
  Phone: 'phone',
  Email: 'email',
  Contact: 'contact',
  Location: 'location',
} as const;

export interface WebitelChatButton {
  /** Postback/Callback data. */
  code?: string;
  /** Request to share contact info. */
  share?: WebitelChatButtonRequest;
  /** Caption to display. */
  text?: string;
  /** URL to navigate to .. */
  url?: string;
}

export interface WebitelChatButtonRow {
  row?: WebitelChatButton[];
}

export interface WebitelChatReplyMarkup {
  buttons?: WebitelChatButtonRow[];
  /** An option used to block input to force
the user to respond with one of the buttons. */
  noInput?: boolean;
}

/**
 * Postback. Reply Button Click[ed].
 */
export interface WebitelChatPostback {
  /** Data associated with the Button. */
  code?: string;
  /** Message ID of the button. */
  mid?: string;
  /** Button's display caption. */
  text?: string;
}

/**
 * Context. Variables. Environment.
 */
export type WebitelChatMessageContext = {[key: string]: string};

/**
 * Chat Message.
 */
export interface WebitelChatMessage {
  /** Conversation the message belongs to .. */
  chat?: WebitelChatChat;
  /** Context. Variables. Environment. */
  context?: WebitelChatMessageContext;
  /** Timestamp when this message was sent (published). */
  date?: string;
  /** Timestamp when this message was last edited. */
  edit?: string;
  /** Message Media. Attachment. */
  file?: WebitelChatFile;
  /** Sender of the message. */
  from?: WebitelChatPeer;
  /** Unique message identifier inside this chat. */
  id?: string;
  /** Keyboard. Buttons. Quick Replies. */
  keyboard?: WebitelChatReplyMarkup;
  kind?: string;
  /** Postback. Reply Button Click[ed]. */
  postback?: WebitelChatPostback;
  /** Chat Sender of the message, sent on behalf of a chat (member). */
  sender?: WebitelChatChat;
  /** Message Text. */
  text?: string;
}

export interface WebitelChatAgentChat {
  closeReason?: string;
  closedAt?: string;
  contact?: WebitelChatPeer;
  gateway?: WebitelChatPeer;
  id?: string;
  lastMessage?: WebitelChatMessage;
  queue?: WebitelChatPeer;
  startedAt?: string;
  title?: string;
  unprocessedClose?: boolean;
}

export interface WebitelChatBroadcastError {
  error?: GoogleRpcStatus;
  peerId?: string;
}

export type WebitelChatBroadcastMessageRequestVariables = {[key: string]: string};

export interface WebitelChatInputFile {
  id?: string;
  source?: string;
  url?: string;
}

export interface WebitelChatInputButton {
  caption?: string;
  code?: string;
  text?: string;
  type?: string;
  url?: string;
}

export interface WebitelChatInputButtonRow {
  buttons?: WebitelChatInputButton[];
}

export interface WebitelChatInputKeyboard {
  rows?: WebitelChatInputButtonRow[];
}

export interface WebitelChatInputMessage {
  file?: WebitelChatInputFile;
  keyboard?: WebitelChatInputKeyboard;
  text?: string;
}

/**
 * InputPeer identity.
 */
export interface WebitelChatInputPeer {
  id?: string;
  type?: string;
  via?: string;
}

export interface WebitelChatBroadcastMessageRequest {
  message?: WebitelChatInputMessage;
  peers?: WebitelChatInputPeer[];
  timeout?: string;
  variables?: WebitelChatBroadcastMessageRequestVariables;
}

export type WebitelChatBroadcastMessageResponseVariables = {[key: string]: string};

export interface WebitelChatBroadcastMessageResponse {
  failure?: WebitelChatBroadcastError[];
  variables?: WebitelChatBroadcastMessageResponseVariables;
}

/**
 * Customer is external chat contact.
 */
export interface WebitelChatCustomer {
  /** Customer unique **ID**entifier.
Account **type**-specific string. */
  id?: string;
  /** Customer account **name**. */
  name?: string;
  /** Customer account **type**. */
  type?: string;
  /** [VIA] Text gateway associations. */
  via?: WebitelChatPeer[];
}

export interface WebitelChatChatCustomers {
  next?: boolean;
  /** Page number of results. */
  page?: number;
  /** Dataset page of Customer(s). */
  peers?: WebitelChatCustomer[];
  vias?: WebitelChatPeer[];
}

/**
 * Context. Variables. Environment.
 */
export type WebitelChatDialogContext = {[key: string]: string};

/**
 * Chat Dialog. Conversation info.
 */
export interface WebitelChatDialog {
  closed?: string;
  closedCause?: string;
  /** Context. Variables. Environment. */
  context?: WebitelChatDialogContext;
  /** Timestamp of the latest activity. */
  date?: string;
  /** [D]omain[C]omponent primary ID. */
  dc?: string;
  /** [FROM]: Originator.
Leg[A]. Contact / User. */
  from?: WebitelChatPeer;
  /** The Conversation thread unique ID. */
  id?: string;
  /** [TO]: Participants.
Leg[A+]. Schema / Agent. */
  members?: WebitelChatChat[];
  /** The latest (top) message. */
  message?: WebitelChatMessage;
  queue?: WebitelChatPeer;
  /** Timestamp when dialog started. */
  started?: string;
  /** Title of the dialog. */
  title?: string;
  /** [VIA] Text gateway [FROM] originated thru ... */
  via?: WebitelChatPeer;
}

export interface WebitelChatChatDialogs {
  /** Dataset page of Dialog(s). */
  data?: WebitelChatDialog[];
  next?: boolean;
  /** Page number of results. */
  page?: number;
}

export interface WebitelChatChatMembers {
  /** Page of the chat participants. */
  data?: WebitelChatChat[];
  next?: boolean;
  /** Page number of results. */
  page?: number;
}

/**
 * Context. Variables. Environment.
 */
export type WebitelChatChatMessageContext = {[key: string]: string};

export interface WebitelChatContactChatInvite {
  date?: string;
  from?: string;
}

/**
 * Peer contact.
 */
export interface WebitelChatChatPeer {
  /** Contact unique **ID**entifier.
Contact **type**-specific string. */
  id?: string;
  /** Contact display **name**. */
  name?: string;
  /** Contact **type** provider. */
  type?: string;
}

/**
 * Context. Variables.
 */
export type WebitelChatContactChatContext = {[key: string]: string};

/**
 * The Chat info.
Alias: participant, subscriber, member, peer, leg.
 */
export interface WebitelChatContactChat {
  /** Context. Variables. */
  context?: WebitelChatContactChatContext;
  /** [D]omain[C]omponent primary ID. */
  dc?: string;
  /** Unique identifier for this chat.
[FROM] Member / Channel ID.

// [TO] Group. Conversation ID.
 string chat_id = 2; */
  id?: string;
  /** OPTIONAL. Invite[d] BY member info. */
  invite?: WebitelChatContactChatInvite;
  /** OPTIONAL. A non-zero value indicates that
the participant has joined the chat. */
  join?: string;
  left?: string;
  /** [FROM]: User identity. Seed. */
  peer?: WebitelChatChatPeer;
  /** [TO]: Chat title. */
  title?: string;
  /** [FROM] VIA text gateway profile. */
  via?: WebitelChatChatPeer;
}

/**
 * Media File.
 */
export interface WebitelChatMessageFile {
  id?: string;
  name?: string;
  size?: string;
  type?: string;
  url?: string;
}

/**
 * - phone: Phone Number
 - email: Email Address
 - contact: General Form
 - location: Current Location
 */
export type WebitelChatMessageButtonRequest = typeof WebitelChatMessageButtonRequest[keyof typeof WebitelChatMessageButtonRequest];


export const WebitelChatMessageButtonRequest = {
  Phone: 'phone',
  Email: 'email',
  Contact: 'contact',
  Location: 'location',
} as const;

export interface WebitelChatMessageButton {
  /** Postback/Callback data. */
  code?: string;
  /** Request to share contact info. */
  share?: WebitelChatMessageButtonRequest;
  /** Caption to display. */
  text?: string;
  /** URL to navigate to .. */
  url?: string;
}

export interface WebitelChatMessageButtonRow {
  row?: WebitelChatMessageButton[];
}

export interface WebitelChatMessageReplyMarkup {
  buttons?: WebitelChatMessageButtonRow[];
  /** An option used to block input to force
the user to respond with one of the buttons. */
  noInput?: boolean;
}

/**
 * Postback. Reply Button Click[ed].
 */
export interface WebitelChatMessagePostback {
  /** Data associated with the Button. */
  code?: string;
  /** Message ID of the button. */
  mid?: string;
  /** Button's display caption. */
  text?: string;
}

/**
 * Chat Message.
 */
export interface WebitelChatChatMessage {
  /** Conversation the message belongs to .. */
  chat?: WebitelChatContactChat;
  /** Context. Variables. Environment. */
  context?: WebitelChatChatMessageContext;
  /** Timestamp when this message was sent (published). */
  date?: string;
  /** Timestamp when this message was last edited. */
  edit?: string;
  /** Message Media. Attachment. */
  file?: WebitelChatMessageFile;
  /** Sender of the message. */
  from?: WebitelChatChatPeer;
  /** Unique message identifier inside this chat. */
  id?: string;
  /** Keyboard. Buttons. Quick Replies. */
  keyboard?: WebitelChatMessageReplyMarkup;
  /** Postback. Reply Button Click[ed]. */
  postback?: WebitelChatMessagePostback;
  /** Chat Sender of the message, sent on behalf of a chat (member). */
  sender?: WebitelChatContactChat;
  /** Message Text. */
  text?: string;
}

export interface WebitelChatChatMessages {
  chats?: WebitelChatChat[];
  /** Dataset page of messages. */
  messages?: WebitelChatMessage[];
  next?: boolean;
  /** Dataset page number. */
  page?: number;
  peers?: WebitelChatPeer[];
}

export interface WebitelChatChatMessagesRequestOffset {
  /** Messages ONLY been sent before the specified epochtime(milli). */
  date?: string;
  id?: string;
}

export interface WebitelChatEmptyResponse { [key: string]: unknown }

export interface WebitelChatGetAgentChatsCounterResponse {
  count?: number;
}

export interface WebitelChatGetAgentChatsResponse {
  items?: WebitelChatAgentChat[];
  next?: boolean;
  page?: number;
}

export interface WebitelChatGetCaseChatHistoryRequestOffset {
  /** Messages ONLY been sent before the specified epochtime(milli). */
  date?: string;
  id?: string;
}

export interface WebitelChatGetContactChatHistoryRequestOffset {
  /** Messages ONLY been sent before the specified epochtime(milli). */
  date?: string;
  id?: string;
}

export interface WebitelChatGetContactChatHistoryResponse {
  chats?: WebitelChatContactChat[];
  /** Dataset page of messages. */
  messages?: WebitelChatChatMessage[];
  next?: boolean;
  /** Dataset page number. */
  page?: number;
  peers?: WebitelChatChatPeer[];
}

export interface WebitelChatLinkContactToClientNAResponse { [key: string]: unknown }

export interface WebitelChatLookup {
  id?: string;
  name?: string;
}

export interface WebitelChatMarkChatProcessedResponse { [key: string]: unknown }

/**
 * Timerange filter value.
 */
export interface WebitelChatTimerange {
  /** Since epochtime (milli).
**Match**: greater than .. */
  since?: string;
  /** Until epochtime (milli).
**Match**: less or equal .. */
  until?: string;
}

export interface WebitelChatServerAccount {
  /** e.g.: bot, user, phone, telegram, facebook, viber, skype ... */
  channel?: string;
  /** optional: channel specific contact string */
  contact?: string;
  firstName?: string;
  id?: string;
  lastName?: string;
  username?: string;
}

export interface WebitelChatServerButton {
  caption?: string;
  code?: string;
  text?: string;
  type?: string;
  url?: string;
}

export interface WebitelChatServerButtons {
  button?: WebitelChatServerButton[];
}

export interface WebitelChatServerChannel {
  closedAt?: string;
  connection?: string;
  createdAt?: string;
  domainId?: string;
  id?: string;
  internal?: boolean;
  props?: string;
  type?: string;
  userId?: string;
}

export interface WebitelChatServerChatTransferResponse { [key: string]: unknown }

/**
 * Result Chat Channel's Variables SET.
 */
export type WebitelChatServerChatVariablesResponseVariables = {[key: string]: string};

export interface WebitelChatServerChatVariablesResponse {
  /** Unique Chat Channel IDentifier. */
  channelId?: string;
  /** Result Chat Channel's Variables SET. */
  variables?: WebitelChatServerChatVariablesResponseVariables;
}

/**
 * optional: extra context
 */
export type WebitelChatServerCheckSessionResponseProperties = {[key: string]: string};

export interface WebitelChatServerCheckSessionResponse {
  account?: WebitelChatServerAccount;
  channelId?: string;
  clientId?: string;
  exists?: boolean;
  /** optional: extra context */
  properties?: WebitelChatServerCheckSessionResponseProperties;
}

export type WebitelChatServerCloseConversationCause = typeof WebitelChatServerCloseConversationCause[keyof typeof WebitelChatServerCloseConversationCause];


export const WebitelChatServerCloseConversationCause = {
  NoCause: 'no_cause',
  FlowEnd: 'flow_end',
  ClientLeave: 'client_leave',
  FlowErr: 'flow_err',
  BroadcastEnd: 'broadcast_end',
} as const;

export interface WebitelChatServerCloseConversationResponse { [key: string]: unknown }

export interface WebitelChatServerGateway {
  id?: string;
  name?: string;
  type?: string;
}

export interface WebitelChatServerMember {
  channelId?: string;
  externalId?: string;
  internal?: boolean;
  type?: string;
  updatedAt?: string;
  userId?: string;
  username?: string;
  via?: WebitelChatServerGateway;
}

export interface WebitelChatServerFile {
  id?: string;
  mime?: string;
  name?: string;
  size?: string;
  url?: string;
}

export interface WebitelChatServerHistoryMessage {
  channelId?: string;
  createdAt?: string;
  file?: WebitelChatServerFile;
  id?: string;
  kind?: string;
  text?: string;
  type?: string;
  updatedAt?: string;
}

export interface WebitelChatServerConversation {
  closedAt?: string;
  createdAt?: string;
  domainId?: string;
  id?: string;
  members?: WebitelChatServerMember[];
  messages?: WebitelChatServerHistoryMessage[];
  title?: string;
  updatedAt?: string;
}

export interface WebitelChatServerDeclineInvitationResponse { [key: string]: unknown }

export interface WebitelChatServerGetConversationByIDResponse {
  item?: WebitelChatServerConversation;
}

export interface WebitelChatServerGetConversationsResponse {
  items?: WebitelChatServerConversation[];
  next?: boolean;
  page?: number;
}

export interface WebitelChatServerGetHistoryMessagesResponse {
  items?: WebitelChatServerHistoryMessage[];
  next?: boolean;
  page?: number;
}

export interface WebitelChatServerInviteToConversationResponse {
  inviteId?: string;
}

export interface WebitelChatServerJoinConversationResponse {
  channelId?: string;
}

export type WebitelChatServerLeaveConversationCause = typeof WebitelChatServerLeaveConversationCause[keyof typeof WebitelChatServerLeaveConversationCause];


export const WebitelChatServerLeaveConversationCause = {
  DefaultCause: 'default_cause',
  AgentTimeout: 'agent_timeout',
  ClientTimeout: 'client_timeout',
  AgentLeave: 'agent_leave',
  Transfer: 'transfer',
  SilenceTimeout: 'silence_timeout',
} as const;

export interface WebitelChatServerLeaveConversationResponse { [key: string]: unknown }

export type WebitelChatServerMessageForwardFromVariables = {[key: string]: string};

export type WebitelChatServerMessageReplyToVariables = {[key: string]: string};

export type WebitelChatServerMessageVariables = {[key: string]: string};

/**
 * Postback. Reply Button Click[ed].
 */
export interface WebitelChatServerPostback {
  /** Button's callback data associated. */
  code?: string;
  /** Message ID of the button. */
  mid?: string;
  /** Button's caption. Text to display. */
  text?: string;
}

export interface WebitelChatServerMessage {
  buttons?: WebitelChatServerButtons[];
  contact?: WebitelChatServerAccount;
  /** Optional. Send message date (epochtime ms) Generates by the service. */
  createdAt?: string;
  file?: WebitelChatServerFile;
  forwardFromChatId?: string;
  forwardFromMessageId?: string;
  forwardFromVariables?: WebitelChatServerMessageForwardFromVariables;
  from?: WebitelChatServerAccount;
  id?: string;
  inline?: WebitelChatServerButtons[];
  kind?: string;
  leftChatMember?: WebitelChatServerAccount;
  newChatMembers?: WebitelChatServerAccount[];
  /** An option used to block input to force the user
to respond with one of the `Buttons`.
Instructs client agents to disable input capabilities.
Can only be used with a set of `Buttons`. */
  noInput?: boolean;
  /** Postback. Reply Button Click[ed]. */
  postback?: WebitelChatServerPostback;
  replyToMessageId?: string;
  replyToVariables?: WebitelChatServerMessageReplyToVariables;
  text?: string;
  /** Type of this Message to notify e.g.: text, file, read, status etc. */
  type?: string;
  updatedAt?: string;
  variables?: WebitelChatServerMessageVariables;
}

export interface WebitelChatServerSendMessageResponse {
  message?: WebitelChatServerMessage;
}

export interface WebitelChatServerSendServiceMessageResponse { [key: string]: unknown }

export interface WebitelChatServerSendUserActionResponse {
  ok?: boolean;
}

export interface WebitelChatServerStartConversationResponse {
  channelId?: string;
  conversationId?: string;
  message?: WebitelChatServerMessage;
}

export interface WebitelChatServerUpdateChannelResponse { [key: string]: unknown }

export interface WebitelChatServerUser {
  connection?: string;
  internal?: boolean;
  type?: string;
  userId?: string;
}

/**
 * User actions. Use this to provide users with detailed info
about their chat partner's actions: typing or sending attachments of all kinds.

 - Typing: User is typing.
 - Cancel: Invalidate all previous action updates.
E.g. when user deletes entered text or aborts a video upload.
 */
export type WebitelChatServerUserAction = typeof WebitelChatServerUserAction[keyof typeof WebitelChatServerUserAction];


export const WebitelChatServerUserAction = {
  Typing: 'Typing',
  Cancel: 'Cancel',
} as const;

export interface WebitelChatServerWaitMessageResponse {
  messages?: WebitelChatServerMessage[];
  timeoutSec?: string;
}

/**
 * Response confirming the deletion of a record.
 */
export interface WebitelMediaExporterDeleteExportResponse {
  /** ID of the deleted record. */
  id?: string;
}

/**
 * Status of the PDF generation process.

 - PENDING: Task is queued and waiting for a worker.
 - PROCESSING: PDF is currently being rendered.
 - DONE: Export finished successfully.
 - FAILED: Export failed during generation.
 */
export type WebitelMediaExporterExportStatus = typeof WebitelMediaExporterExportStatus[keyof typeof WebitelMediaExporterExportStatus];


export const WebitelMediaExporterExportStatus = {
  ExportStatusUnspecified: 'EXPORT_STATUS_UNSPECIFIED',
  Pending: 'PENDING',
  Processing: 'PROCESSING',
  Done: 'DONE',
  Failed: 'FAILED',
} as const;

/**
 * Represents a persisted record of a PDF export.
 */
export interface WebitelMediaExporterExportRecord {
  /** Creation timestamp (Unix millis). */
  createdAt?: string;
  /** User ID who initiated the export. */
  createdBy?: string;
  /** Reference to the file in the storage system. */
  fileId?: string;
  /** Internal database record ID. */
  id?: string;
  /** MIME type of the generated file. */
  mimeType?: string;
  /** Display name of the export. */
  name?: string;
  /** Final status of the export process. */
  status?: WebitelMediaExporterExportStatus;
  /** Last update timestamp (Unix millis). */
  updatedAt?: string;
  /** User ID who last modified the record. */
  updatedBy?: string;
}

/**
 * Metadata about an export task immediately after creation.
 */
export interface WebitelMediaExporterExportTask {
  /** Target name of the PDF file. */
  fileName?: string;
  /** MIME type (usually application/pdf). */
  mimeType?: string;
  /** File size in bytes (0 if not yet generated). */
  size?: string;
  /** Current lifecycle status of the task. */
  status?: WebitelMediaExporterExportStatus;
  /** Unique ID to track the background task. */
  taskId?: string;
}

/**
 * Response containing a page of export history records.
 */
export interface WebitelMediaExporterListExportsResponse {
  /** List of export records. */
  items?: WebitelMediaExporterExportRecord[];
  /** Indicates if there are more records available. */
  next?: boolean;
  /** Current page number. */
  page?: number;
}

/**
 * Request for generating a call media PDF.
 */
export interface WebitelMediaExporterPdfServiceCreateCallExportBody {
  /** Optional: specific file IDs to include in the PDF. */
  fileIds?: string[];
  /** Start timestamp of the range (Unix millis). */
  from?: string;
  /** End timestamp of the range (Unix millis). */
  to?: string;
}

/**
 * Request for generating a screen recording PDF.
 */
export interface WebitelMediaExporterPdfServiceCreateScreenrecordingExportBody {
  /** Optional: specific file IDs to include in the PDF. */
  fileIds?: string[];
  /** Start timestamp of the range (Unix millis). */
  from?: string;
  /** End timestamp of the range (Unix millis). */
  to?: string;
}

export interface WfmLookupEntity {
  id?: string;
  name?: string;
}

export interface WfmAbsence {
  absentAt?: string;
  createdAt?: string;
  createdBy?: WfmLookupEntity;
  domainId?: string;
  id?: string;
  typeId?: WfmAbsenceType;
  updatedAt?: string;
  updatedBy?: WfmLookupEntity;
}

export interface WfmAgentAbsences {
  absences?: WfmAbsence[];
  agent?: WfmLookupEntity;
}

export interface WfmAgentScheduleShiftPause {
  cause?: WfmLookupEntity;
  createdAt?: string;
  createdBy?: WfmLookupEntity;
  domainId?: string;
  end?: string;
  id?: string;
  start?: string;
  updatedAt?: string;
  updatedBy?: WfmLookupEntity;
}

export interface WfmAgentScheduleShiftSkill {
  capacity?: string;
  enabled?: boolean;
  skill?: WfmLookupEntity;
}

export interface WfmAgentScheduleShift {
  createdAt?: string;
  createdBy?: WfmLookupEntity;
  domainId?: string;
  end?: string;
  id?: string;
  pauses?: WfmAgentScheduleShiftPause[];
  skills?: WfmAgentScheduleShiftSkill[];
  start?: string;
  updatedAt?: string;
  updatedBy?: WfmLookupEntity;
}

export interface WfmAgentSchedule {
  absence?: WfmAbsenceType;
  date?: string;
  locked?: boolean;
  shift?: WfmAgentScheduleShift;
}

export interface WfmAgentWorkingConditions {
  pauseTemplate?: WfmLookupEntity;
  workingCondition?: WfmLookupEntity;
}

export interface WfmAgentWorkingSchedule {
  agent?: WfmLookupEntity;
  schedule?: WfmAgentSchedule[];
}

export interface WfmCreateAgentAbsenceResponse {
  item?: WfmAbsence;
}

export interface WfmCreateAgentsAbsencesRequest {
  agentIds?: string[];
  items?: CreateAgentsAbsencesRequestabsentType[];
}

export interface WfmCreateAgentsAbsencesResponse {
  items?: WfmAgentAbsences[];
}

export interface WfmCreateAgentsWorkingScheduleShiftsResponse {
  items?: WfmAgentWorkingSchedule[];
}

export interface WfmForecastCalculation {
  args?: string[];
  createdAt?: string;
  createdBy?: WfmLookupEntity;
  description?: string;
  domainId?: string;
  id?: string;
  name?: string;
  procedure?: string;
  updatedAt?: string;
  updatedBy?: WfmLookupEntity;
}

export interface WfmCreateForecastCalculationRequest {
  item?: WfmForecastCalculation;
}

export interface WfmCreateForecastCalculationResponse {
  item?: WfmForecastCalculation;
}

export interface WfmPauseTemplateCause {
  cause?: WfmLookupEntity;
  duration?: string;
}

export interface WfmPauseTemplate {
  causes?: WfmPauseTemplateCause[];
  createdAt?: string;
  createdBy?: WfmLookupEntity;
  description?: string;
  domainId?: string;
  id?: string;
  name?: string;
  updatedAt?: string;
  updatedBy?: WfmLookupEntity;
}

export interface WfmCreatePauseTemplateRequest {
  item?: WfmPauseTemplate;
}

export interface WfmCreatePauseTemplateResponse {
  item?: WfmPauseTemplate;
}

export interface WfmShiftTemplateTime {
  end?: number;
  start?: number;
}

export interface WfmShiftTemplate {
  createdAt?: string;
  createdBy?: WfmLookupEntity;
  description?: string;
  domainId?: string;
  id?: string;
  name?: string;
  times?: WfmShiftTemplateTime[];
  updatedAt?: string;
  updatedBy?: WfmLookupEntity;
}

export interface WfmCreateShiftTemplateRequest {
  item?: WfmShiftTemplate;
}

export interface WfmCreateShiftTemplateResponse {
  item?: WfmShiftTemplate;
}

export interface WfmWorkingCondition {
  createdAt?: string;
  createdBy?: WfmLookupEntity;
  daysOff?: number;
  description?: string;
  domainId?: string;
  id?: string;
  name?: string;
  pauseDuration?: number;
  pauseTemplate?: WfmLookupEntity;
  shiftTemplate?: WfmLookupEntity;
  sickLeaves?: number;
  updatedAt?: string;
  updatedBy?: WfmLookupEntity;
  vacation?: number;
  workdayHours?: number;
  workdaysPerMonth?: number;
}

export interface WfmCreateWorkingConditionRequest {
  item?: WfmWorkingCondition;
}

export interface WfmCreateWorkingConditionResponse {
  item?: WfmWorkingCondition;
}

export type WfmWorkingScheduleState = typeof WfmWorkingScheduleState[keyof typeof WfmWorkingScheduleState];


export const WfmWorkingScheduleState = {
  WorkingScheduleStateUnspecified: 'WORKING_SCHEDULE_STATE_UNSPECIFIED',
  WorkingScheduleStateActive: 'WORKING_SCHEDULE_STATE_ACTIVE',
  WorkingScheduleStatePending: 'WORKING_SCHEDULE_STATE_PENDING',
  WorkingScheduleStateDraft: 'WORKING_SCHEDULE_STATE_DRAFT',
  WorkingScheduleStateArchived: 'WORKING_SCHEDULE_STATE_ARCHIVED',
} as const;

export interface WfmWorkingSchedule {
  agents?: WfmLookupEntity[];
  blockOutsideActivity?: boolean;
  calendar?: WfmLookupEntity;
  createdAt?: string;
  createdBy?: WfmLookupEntity;
  domainId?: string;
  endDateAt?: string;
  endTimeAt?: string;
  extraSkills?: WfmLookupEntity[];
  id?: string;
  name?: string;
  startDateAt?: string;
  startTimeAt?: string;
  state?: WfmWorkingScheduleState;
  team?: WfmLookupEntity;
  totalAgents?: string;
  updatedAt?: string;
  updatedBy?: WfmLookupEntity;
}

export interface WfmCreateWorkingScheduleRequest {
  item?: WfmWorkingSchedule;
}

export interface WfmCreateWorkingScheduleResponse {
  item?: WfmWorkingSchedule;
}

export interface WfmDeleteAgentAbsenceResponse {
  id?: string;
}

export interface WfmDeleteForecastCalculationResponse {
  id?: string;
}

export interface WfmDeletePauseTemplateResponse {
  id?: string;
}

export interface WfmDeleteShiftTemplateResponse {
  id?: string;
}

export interface WfmDeleteWorkingConditionResponse {
  id?: string;
}

export interface WfmDeleteWorkingScheduleResponse {
  id?: string;
}

export interface WfmExecuteForecastCalculationResponseForecast {
  agents?: string;
  timestamp?: string;
}

export interface WfmExecuteForecastCalculationResponse {
  items?: WfmExecuteForecastCalculationResponseForecast[];
}

export interface WfmFilterBetween {
  from?: string;
  to?: string;
}

export interface WfmHoliday {
  date?: string;
  name?: string;
}

export interface WfmReadAgentAbsenceResponse {
  item?: WfmAbsence;
}

export interface WfmReadAgentWorkingConditionsResponse {
  item?: WfmAgentWorkingConditions;
}

export interface WfmReadForecastCalculationResponse {
  item?: WfmForecastCalculation;
}

export interface WfmReadPauseTemplateResponse {
  item?: WfmPauseTemplate;
}

export interface WfmReadShiftTemplateResponse {
  item?: WfmShiftTemplate;
}

export interface WfmReadWorkingConditionResponse {
  item?: WfmWorkingCondition;
}

export interface WfmWorkingScheduleForecastForecast {
  agents?: string;
  hour?: string;
}

export interface WfmWorkingScheduleForecast {
  forecast?: WfmWorkingScheduleForecastForecast[];
}

export type WfmReadWorkingScheduleForecastResponseItems = {[key: string]: WfmWorkingScheduleForecast};

export interface WfmReadWorkingScheduleForecastResponse {
  items?: WfmReadWorkingScheduleForecastResponseItems;
}

export interface WfmReadWorkingScheduleResponse {
  item?: WfmWorkingSchedule;
}

export interface WfmSearchAgentAbsenceResponse {
  items?: WfmAbsence[];
}

export interface WfmSearchAgentsAbsencesResponse {
  items?: WfmAgentAbsences[];
  next?: boolean;
}

export interface WfmSearchAgentsWorkingScheduleResponse {
  holidays?: WfmHoliday[];
  items?: WfmAgentWorkingSchedule[];
  total?: string;
}

export interface WfmSearchForecastCalculationResponse {
  items?: WfmForecastCalculation[];
  next?: boolean;
}

export interface WfmSearchPauseTemplateResponse {
  items?: WfmPauseTemplate[];
  next?: boolean;
}

export interface WfmSearchShiftTemplateResponse {
  items?: WfmShiftTemplate[];
  next?: boolean;
}

export interface WfmSearchWorkingConditionResponse {
  items?: WfmWorkingCondition[];
  next?: boolean;
}

export interface WfmSearchWorkingScheduleResponse {
  items?: WfmWorkingSchedule[];
  next?: boolean;
}

export interface WfmUpdateAgentAbsenceResponse {
  item?: WfmAbsence;
}

export interface WfmUpdateAgentWorkingConditionsResponse {
  item?: WfmAgentWorkingConditions;
}

export interface WfmUpdateForecastCalculationResponse {
  item?: WfmForecastCalculation;
}

export interface WfmUpdatePauseTemplateResponse {
  item?: WfmPauseTemplate;
}

export interface WfmUpdateShiftTemplateResponse {
  item?: WfmShiftTemplate;
}

export interface WfmUpdateWorkingConditionResponse {
  item?: WfmWorkingCondition;
}

export interface WfmUpdateWorkingScheduleAddAgentsResponse {
  agents?: WfmLookupEntity[];
}

export interface WfmUpdateWorkingScheduleRemoveAgentResponse {
  id?: string;
}

export interface WfmUpdateWorkingScheduleResponse {
  item?: WfmWorkingSchedule;
}

export type ClassesUpdateClassBodyBody = ClassesUpdateClassBody;

export type CreateDataRecordBody = { [key: string]: unknown };

export type DomainsUpdateDomainBodyBody = DomainsUpdateDomainBody;

export type LDAPDeleteLDAPTemplateBodyBody = LDAPDeleteLDAPTemplateBody;

export type LDAPUpdateLDAPCatalogBodyBody = LDAPUpdateLDAPCatalogBody;

export type LDAPUpdateLDAPTemplateBodyBody = LDAPUpdateLDAPTemplateBody;

export type OAuth2FederationUpdateOAuthServiceBodyBody = OAuth2FederationUpdateOAuthServiceBody;

export type RolesUpdateRoleBodyBody = RolesUpdateRoleBody;

export type SetContactLanguageInputBody = {
  /** Indicates whether this association must be default
among others of the same type. */
  primary?: boolean;
  tag?: string;
};

/**
 * Custom data extension fields ..
 */
export type UpdateCaseInputBodyCustom = { [key: string]: unknown };

export type UpdateCaseInputBody = {
  assignee?: GeneralLookup;
  close_reason?: GeneralLookup;
  close_result?: string;
  contact_info?: string;
  /** Custom data extension fields .. */
  custom?: UpdateCaseInputBodyCustom;
  description?: string;
  group?: GeneralLookup;
  impacted?: GeneralLookup;
  priority?: GeneralLookup;
  rating?: string;
  rating_comment?: string;
  reporter?: GeneralLookup;
  service?: GeneralLookup;
  source?: GeneralLookup;
  status?: GeneralLookup;
  status_condition?: WebitelCasesStatusCondition;
  subject?: string;
  /** Optional creator / updater ID. Use this to explicitly set the case creator / updater instead of deriving it from the auth token. */
  userID?: GeneralLookup;
};

export type UpdateCommentInputBody = {
  /** Content of the comment. */
  text?: string;
  /** Optional creator / updater ID. Use this to explicitly set the case creator / updater instead of deriving it from the auth token. */
  userID?: GeneralLookup;
};

export type UpdateContactGroupInputBody = {
  /** Group of contacts associated. */
  group?: WebitelcontactsLookup;
};

export type UpdateData2RecordBody = { [key: string]: unknown };

export type UpdateDeviceDeviceBodyProvision = {[key: string]: string};

export type UpdateDeviceDeviceBody = {
  /** username */
  account?: string;
  /** vendor brand name */
  brand?: string;
  created_at?: string;
  created_by?: ApiUserId;
  deleted_at?: string;
  deleted_by?: ApiUserId;
  /** act as a hotdesk */
  hotdesk?: boolean;
  hotdesks?: string[];
  ip?: string;
  logged_in?: string;
  mac?: string;
  model?: string;
  /** display name */
  name?: string;
  password?: string;
  provision?: UpdateDeviceDeviceBodyProvision;
  reged?: boolean;
  updated_at?: string;
  updated_by?: ApiUserId;
  user?: ApiUserId;
};

export type UpdateEmailInputBody = {
  /** The email address. */
  email: string;
  /** Indicates whether this phone number is default within other channels of the same type(phone). */
  primary?: boolean;
  type?: WebitelcontactsLookup;
  verified?: boolean;
};

export type UpdateLinkInputBody = {
  name?: string;
  url?: string;
  /** Optional creator / updater ID. Use this to explicitly set the case creator / updater instead of deriving it from the auth token. */
  userID?: GeneralLookup;
};

export type UpdateManagerInputBody = {
  /** Indicates whether this association must be default among others. */
  primary?: boolean;
  /** Responsible User. */
  user?: WebitelcontactsLookup;
};

export type UpdatePhoneInputBody = {
  /** The phone number. */
  number: string;
  /** Indicates whether this phone number is default within other channels of the same type(phone). */
  primary?: boolean;
  type?: WebitelcontactsLookup;
  verified?: boolean;
};

export type UpdatePhotoInputBody = {
  photo_id?: string;
  photo_url?: string;
  /** True if the photo is a default photo; false if the photo is a user-provided photo. */
  primary?: boolean;
};

/**
 * Primary case details.
 */
export type UpdateRelatedCaseInputBodyPrimaryCase = {
  name?: string;
};

export type UpdateRelatedCaseInputBody = {
  /** Primary case details. */
  primary_case?: UpdateRelatedCaseInputBodyPrimaryCase;
  /** Related case details. */
  related_case?: GeneralLookup;
  /** Relation type. */
  relation_type?: WebitelCasesRelationType;
  /** Optional creator / updater ID. Use this to explicitly set the case creator / updater instead of deriving it from the auth token. */
  userID?: GeneralLookup;
};

export type UpdateTimezoneInputBody = {
  /** Indicates whether this association must be default among others. */
  primary?: boolean;
  /** Timezone dictionary reference value associated. */
  timezone?: WebitelcontactsLookup;
};

export type UpdateUserAccessTokenUpdateBodyUser = {
  name?: string;
};

export type UpdateUserAccessTokenUpdateBody = {
  created_at?: string;
  created_by?: ApiObjectId;
  deleted_at?: string;
  deleted_by?: ApiObjectId;
  token?: string;
  updated_at?: string;
  updated_by?: ApiObjectId;
  usage?: string;
  user?: UpdateUserAccessTokenUpdateBodyUser;
};

export type UpdateUserUserBodyProfile = {[key: string]: string};

export type UpdateUserUserBody = {
  /** The "chat_name" field is used to store the name displayed externally on the platform.
For example, "chat_name" is shown when an agent connects to chats with clients. */
  chat_name?: string;
  /** [optional] contact connected to this user */
  contact?: ApiObjectId;
  created_at?: string;
  created_by?: ApiUserId;
  deleted_at?: string;
  deleted_by?: ApiUserId;
  device?: ApiObjectId;
  /** [editable] list of unique `regular` devices, attached to this user */
  devices?: ApiObjectId[];
  email?: string;
  extension?: string;
  /** When set to true, the user will be required to change their password on next login. */
  force_password_change?: boolean;
  hotdesks?: ApiObjectId[];
  license?: ApiLicenseUser[];
  name?: string;
  password?: string;
  permissions?: ApiPermission[];
  /** string presence = 7; // unique set of <user> presentity <status:basic> tuples open[ed]
 string status = 8; // short display status (short description) */
  presence?: ApiUserPresence;
  profile?: UpdateUserUserBodyProfile;
  roles?: ApiObjectId[];
  totp_url?: string;
  updated_at?: string;
  updated_by?: ApiUserId;
  username?: string;
};

export type UpdateVariableInputBody = {
  /**
   * NEW Key.
   * @pattern ^\w+$
   */
  key: string;
  /** NEW Value. */
  value?: unknown;
};

/**
 * Input details for the dynamic group.
 */
export type ContactsDynamicGroupInputBody = ContactsDynamicGroupInput;

/**
 * Input details for the condition.
 */
export type ContactsInputConditionBody = ContactsInputCondition;

export type ContactsInputGroupBody = ContactsInputGroup;

/**
 * Input data for updating the catalog
 */
export type WebitelCasesInputCatalogBody = WebitelCasesInputCatalog;

export type WebitelCasesInputCloseReasonBody = WebitelCasesInputCloseReason;

export type WebitelCasesInputCloseReasonGroupBody = WebitelCasesInputCloseReasonGroup;

export type WebitelCasesInputPriorityBody = WebitelCasesInputPriority;

export type WebitelCasesInputSLABody = WebitelCasesInputSLA;

export type WebitelCasesInputSLAConditionBody = WebitelCasesInputSLACondition;

/**
 * Input data for updating the service
 */
export type WebitelCasesInputServiceBody = WebitelCasesInputService;

export type WebitelCasesInputSourceBody = WebitelCasesInputSource;

export type WebitelCasesInputStatusBody = WebitelCasesInputStatus;

export type WebitelCasesInputStatusConditionBody = WebitelCasesInputStatusCondition;

export type ListDefaultAccessParams = {
/**
 * --- filters ---

[optional] [FROM] each rule owner is any of role(s) id; user -or- role
 */
grantor?: string[];
/**
 * [optional] [TO] subject role(s) id; user -or- role
 */
grantee?: string[];
/**
 * [xrwdxrwd] [R]ecord-[b]ased-[A]ccess-[C]ontrol level check(!)
 */
granted?: string[];
/**
 * [optional] [TO] subject.name ILIKE ?q=; user -or- role
 */
q?: string;
/**
 * ----- Select Options -------------------------

attributes list
 */
fields?: string[];
/**
 * e.g.: "updated_at" - ASC; "!updated_at" - DESC;
 */
sort?: string[];
/**
 * pagedResultsControl

default: 16
 */
size?: number;
/**
 * default: 1
 */
page?: number;
};

export type AgentChatServiceGetAgentChatsParams = {
/**
 * default
 */
size?: number;
page?: number;
q?: string;
fields?: string[];
sort?: string;
/**
 * filter
 */
onlyClosed?: boolean;
onlyUnprocessed?: boolean;
};

export type AgentChatServiceGetAgentChatsCounterParams = {
onlyClosed?: boolean;
onlyUnprocessed?: boolean;
};

export type ListScreenrecordingExportsParams = {
/**
 * Page number (1-based).
 */
page?: number;
/**
 * Number of items per page.
 */
size?: number;
/**
 * sorting criteria, e.g. "+created_at" or "-name"
 */
sort?: string;
};

export type SearchCalendarParams = {
page?: number;
size?: number;
q?: string;
sort?: string;
fields?: string[];
id?: number[];
};

export type SearchTimezonesParams = {
page?: number;
size?: number;
q?: string;
sort?: string;
fields?: string[];
id?: number[];
};

export type DeleteCalendarParams = {
domainId?: string;
};

export type ReadCalendarParams = {
domainId?: string;
};

export type SearchAgentParams = {
page?: number;
size?: number;
q?: string;
sort?: string;
fields?: string[];
id?: string[];
allowChannels?: string[];
supervisorId?: number[];
teamId?: number[];
regionId?: number[];
auditorId?: number[];
isSupervisor?: boolean;
skillId?: number[];
queueId?: number[];
notSupervisor?: boolean;
userId?: string[];
extension?: string[];
notTeamId?: number[];
notSkillId?: number[];
notUserId?: string[];
};

export type SearchAgentCallStatisticsParams = {
page?: number;
size?: number;
timeFrom?: string;
timeTo?: string;
agentId?: number[];
domainId?: string;
q?: string;
fields?: string[];
sort?: string;
};

export type SearchAgentStatusStatisticParams = {
page?: number;
size?: number;
q?: string;
sort?: string;
fields?: string[];
agentId?: string[];
timeFrom?: string;
timeTo?: string;
status?: string[];
queueId?: number[];
teamId?: number[];
utilizationFrom?: string;
utilizationTo?: string;
hasCall?: boolean;
skillId?: number[];
regionId?: number[];
supervisorId?: number[];
auditorId?: string[];
};

export type SearchAgentStatusStatisticItemParams = {
timeFrom?: string;
timeTo?: string;
};

export type SearchAgentStateHistoryParams = {
page?: number;
size?: number;
joinedAtFrom?: string;
joinedAtTo?: string;
agentId?: string[];
sort?: string;
domainId?: string;
fromId?: string;
};

export type SearchPauseCauseForAgentParams = {
allowChange?: boolean;
};

export type DeleteAgentSkillsParams = {
id?: string[];
skillId?: string[];
};

export type SearchAgentSkillParams = {
page?: number;
size?: number;
q?: string;
sort?: string;
fields?: string[];
id?: string[];
skillId?: string[];
};

export type DeleteAgentSkillParams = {
domainId?: string;
};

export type ReadAgentSkillParams = {
domainId?: string;
};

export type AgentStateHistoryParams = {
page?: number;
size?: number;
timeFrom?: string;
timeTo?: string;
q?: string;
domainId?: string;
};

export type SearchAgentInQueueStatisticsParams = {
domainId?: string;
};

export type AgentTodayStatisticsParams = {
fields?: string[];
};

export type DeleteAgentParams = {
domainId?: string;
};

export type ReadAgentParams = {
domainId?: string;
};

export type SearchAgentInQueueParams = {
page?: number;
size?: number;
q?: string;
sort?: string;
fields?: string[];
};

export type SearchAgentInTeamParams = {
page?: number;
size?: number;
q?: string;
domainId?: string;
};

export type SearchAuditFormParams = {
page?: number;
size?: number;
q?: string;
sort?: string;
fields?: string[];
id?: number[];
teamId?: number[];
enabled?: boolean;
/**
 * bool archive = 9;

bool active = 11; // not archive
 */
editable?: boolean;
question?: string;
/**
 * expects userID to filter by user's team
 */
teamFilter?: number;
};

export type SearchAuditRateParams = {
page?: number;
size?: number;
q?: string;
sort?: string;
fields?: string[];
createdAtFrom?: string;
createdAtTo?: string;
id?: number[];
callId?: string[];
ratedUser?: string[];
};

export type SearchBucketParams = {
page?: number;
size?: number;
q?: string;
sort?: string;
fields?: string[];
id?: number[];
};

export type DeleteBucketParams = {
domainId?: string;
};

export type ReadBucketParams = {
domainId?: string;
};

export type SearchCommunicationTypeParams = {
page?: number;
size?: number;
q?: string;
sort?: string;
fields?: string[];
id?: number[];
channel?: SearchCommunicationTypeChannelItem[];
default?: boolean;
};

export type SearchCommunicationTypeChannelItem = typeof SearchCommunicationTypeChannelItem[keyof typeof SearchCommunicationTypeChannelItem];


export const SearchCommunicationTypeChannelItem = {
  Undefined: 'Undefined',
  Phone: 'Phone',
  Email: 'Email',
  Messaging: 'Messaging',
} as const;

export type DeleteCommunicationTypeParams = {
domainId?: string;
};

export type ReadCommunicationTypeParams = {
domainId?: string;
};

export type SearchListParams = {
page?: number;
size?: number;
q?: string;
sort?: string;
fields?: string[];
id?: number[];
};

export type DeleteListParams = {
domainId?: string;
};

export type ReadListParams = {
domainId?: string;
};

export type SearchListCommunicationParams = {
page?: number;
size?: number;
q?: string;
sort?: string;
fields?: string[];
id?: number[];
expireAtFrom?: string;
expireAtTo?: string;
};

export type DeleteListCommunicationParams = {
domainId?: string;
};

export type ReadListCommunicationParams = {
domainId?: string;
};

export type SearchLookupAgentNotExistsSkillParams = {
page?: number;
size?: number;
q?: string;
domainId?: string;
};

export type SearchLookupUsersAgentNotExistsParams = {
page?: number;
size?: number;
q?: string;
domainId?: string;
};

export type SearchMembersParams = {
page?: number;
size?: number;
q?: string;
sort?: string;
fields?: string[];
id?: string[];
queueId?: number[];
bucketId?: number[];
destination?: string;
createdAtFrom?: string;
createdAtTo?: string;
offeringAtFrom?: string;
offeringAtTo?: string;
stopCause?: string[];
priorityFrom?: string;
priorityTo?: string;
name?: string;
attemptsFrom?: string;
attemptsTo?: string;
agentId?: number[];
};

export type SearchAgentPauseCauseParams = {
page?: number;
size?: number;
q?: string;
sort?: string;
fields?: string[];
id?: number[];
};

export type SearchPresetQueryParams = {
page?: number;
size?: number;
q?: string;
sort?: string;
fields?: string[];
id?: number[];
section?: string[];
};

export type SearchQueueParams = {
page?: number;
size?: number;
q?: string;
sort?: string;
fields?: string[];
id?: string[];
type?: number[];
teamId?: number[];
tags?: string[];
enabled?: boolean;
};

export type SearchAttemptsParams = {
page?: number;
size?: number;
q?: string;
sort?: string;
fields?: string[];
joinedAtFrom?: string;
joinedAtTo?: string;
id?: string[];
queueId?: string[];
bucketId?: string[];
memberId?: string[];
agentId?: string[];
result?: string[];
leavingAtFrom?: string;
leavingAtTo?: string;
offeringAtFrom?: string;
offeringAtTo?: string;
durationFrom?: string;
durationTo?: string;
offeredAgentId?: string[];
};

export type SearchAttemptsHistoryParams = {
page?: number;
size?: number;
q?: string;
sort?: string;
fields?: string[];
joinedAtFrom?: string;
joinedAtTo?: string;
id?: string[];
queueId?: string[];
bucketId?: string[];
memberId?: string[];
agentId?: string[];
result?: string[];
leavingAtFrom?: string;
leavingAtTo?: string;
offeringAtFrom?: string;
offeringAtTo?: string;
durationFrom?: string;
durationTo?: string;
offeredAgentId?: string[];
};

export type SearchQueueReportGeneralParams = {
page?: number;
size?: number;
joinedAtFrom?: string;
joinedAtTo?: string;
domainId?: string;
fields?: string[];
sort?: string;
q?: string;
queueId?: number[];
teamId?: number[];
type?: number[];
};

export type GetQueuesGlobalStateParams = {
q?: string;
type?: number[];
teamId?: number[];
tags?: string[];
};

export type SearchQueueTagsParams = {
page?: number;
size?: number;
q?: string;
sort?: string;
fields?: string[];
};

export type DeleteQueueParams = {
domainId?: string;
};

export type ReadQueueParams = {
domainId?: string;
};

export type SearchQueueBucketParams = {
page?: number;
size?: number;
q?: string;
sort?: string;
fields?: string[];
id?: number[];
};

export type SearchQueueHookParams = {
page?: number;
size?: number;
q?: string;
sort?: string;
fields?: string[];
id?: number[];
schemaId?: number[];
event?: string[];
};

export type SearchMemberInQueueParams = {
page?: number;
size?: number;
q?: string;
sort?: string;
fields?: string[];
id?: string[];
bucketId?: number[];
destination?: string;
createdAtFrom?: string;
createdAtTo?: string;
offeringAtFrom?: string;
offeringAtTo?: string;
stopCause?: string[];
priorityFrom?: string;
priorityTo?: string;
name?: string;
attemptsFrom?: string;
attemptsTo?: string;
agentId?: number[];
/**
 * This is a request variable of the map type. The query format is "map_name[key]=value", e.g. If the map name is Age, the key type is string, and the value type is integer, the query parameter is expressed as Age["bob"]=18
 */
variablesString?: string;
};

export type DeleteMemberParams = {
domainId?: string;
force?: boolean;
};

export type ReadMemberParams = {
domainId?: string;
};

export type SearchMemberAttemptsParams = {
domainId?: string;
};

export type SearchQueueResourceGroupParams = {
page?: number;
size?: number;
q?: string;
sort?: string;
fields?: string[];
id?: number[];
};

export type DeleteQueueResourceGroupParams = {
domainId?: string;
};

export type ReadQueueResourceGroupParams = {
domainId?: string;
};

export type SearchQueueSkillParams = {
page?: number;
size?: number;
q?: string;
sort?: string;
fields?: string[];
id?: number[];
skillId?: number[];
bucketId?: number[];
lvl?: number[];
minCapacity?: number[];
maxCapacity?: number[];
enabled?: boolean;
};

export type SearchQuickRepliesParams = {
page?: number;
size?: number;
q?: string;
sort?: string;
fields?: string[];
id?: number[];
queue?: number[];
restrictToAgent?: boolean;
};

export type SearchOutboundResourceGroupParams = {
page?: number;
size?: number;
q?: string;
sort?: string;
fields?: string[];
id?: number[];
};

export type SearchOutboundResourceInGroupParams = {
page?: number;
size?: number;
q?: string;
sort?: string;
fields?: string[];
id?: number[];
};

export type DeleteOutboundResourceInGroupParams = {
domainId?: string;
};

export type ReadOutboundResourceInGroupParams = {
domainId?: string;
};

export type DeleteOutboundResourceGroupParams = {
domainId?: string;
};

export type ReadOutboundResourceGroupParams = {
domainId?: string;
};

export type SearchOutboundResourceParams = {
page?: number;
size?: number;
q?: string;
sort?: string;
fields?: string[];
id?: number[];
};

export type DeleteOutboundResourceParams = {
domainId?: string;
};

export type ReadOutboundResourceParams = {
domainId?: string;
};

export type DeleteOutboundResourceDisplaysParams = {
items?: string[];
};

export type SearchOutboundResourceDisplayParams = {
page?: number;
size?: number;
q?: string;
sort?: string;
fields?: string[];
id?: number[];
};

export type DeleteOutboundResourceDisplayParams = {
domainId?: string;
};

export type ReadOutboundResourceDisplayParams = {
domainId?: string;
};

export type SearchSkillParams = {
page?: number;
size?: number;
q?: string;
sort?: string;
fields?: string[];
id?: number[];
};

export type DeleteSkillParams = {
domainId?: string;
};

export type ReadSkillParams = {
domainId?: string;
};

export type SearchSkillAgentParams = {
page?: number;
size?: number;
q?: string;
sort?: string;
fields?: string[];
id?: string[];
agentId?: string[];
};

export type SearchAgentTeamParams = {
page?: number;
size?: number;
q?: string;
sort?: string;
fields?: string[];
id?: number[];
strategy?: string[];
adminId?: number[];
};

export type SearchAgentTriggerParams = {
teamId?: string;
page?: number;
size?: number;
q?: string;
sort?: string;
fields?: string[];
enabled?: boolean;
id?: number[];
schemaId?: number[];
};

export type DeleteAgentTeamParams = {
domainId?: string;
};

export type ReadAgentTeamParams = {
domainId?: string;
};

export type SearchTeamHookParams = {
page?: number;
size?: number;
q?: string;
sort?: string;
fields?: string[];
id?: number[];
schemaId?: number[];
event?: SearchTeamHookEventItem[];
};

export type SearchTeamHookEventItem = typeof SearchTeamHookEventItem[keyof typeof SearchTeamHookEventItem];


export const SearchTeamHookEventItem = {
  TeamHookEventUndefined: 'teamHookEventUndefined',
  AgentStatus: 'agent_status',
} as const;

export type SearchTeamTriggerParams = {
page?: number;
size?: number;
q?: string;
sort?: string;
fields?: string[];
enabled?: boolean;
id?: number[];
schemaId?: number[];
};

export type SearchUserStatusParams = {
page?: number;
size?: number;
q?: string;
sort?: string;
fields?: string[];
notUserId?: string[];
};

export type SearchActiveCallParams = {
page?: number;
size?: number;
q?: string;
sort?: string;
fields?: string[];
createdAtFrom?: string;
createdAtTo?: string;
userId?: string[];
agentId?: string[];
queueId?: string[];
teamId?: string[];
memberId?: string[];
gatewayId?: string[];
durationFrom?: string;
durationTo?: string;
skipParent?: boolean;
parentId?: string;
cause?: string[];
existsFile?: boolean;
domainId?: string;
number?: string;
direction?: string[];
answeredAtFrom?: string;
answeredAtTo?: string;
missed?: boolean;
storedAtFrom?: string;
storedAtTo?: string;
supervisorId?: string[];
state?: string[];
};

export type ReadCallParams = {
domainId?: string;
};

export type SearchHistoryCallParams = {
page?: number;
size?: number;
q?: string;
sort?: string;
fields?: string[];
createdAtFrom?: string;
createdAtTo?: string;
userId?: string[];
agentId?: string[];
queueId?: string[];
teamId?: string[];
memberId?: string[];
gatewayId?: string[];
durationFrom?: string;
durationTo?: string;
skipParent?: boolean;
parentId?: string;
cause?: string[];
hasFile?: boolean;
domainId?: string;
number?: string;
direction?: string;
answeredAtFrom?: string;
answeredAtTo?: string;
missed?: boolean;
storedAtFrom?: string;
storedAtTo?: string;
id?: string[];
transferFrom?: string[];
transferTo?: string[];
dependencyId?: string;
tags?: string[];
/**
 * This is a request variable of the map type. The query format is "map_name[key]=value", e.g. If the map name is Age, the key type is string, and the value type is integer, the query parameter is expressed as Age["bob"]=18
 */
variablesString?: string;
amdResult?: string[];
fts?: string;
directions?: string[];
hasTranscript?: boolean;
agentDescription?: string;
ownerId?: string[];
granteeId?: string[];
amdAiResult?: string[];
talkFrom?: string;
talkTo?: string;
rated?: boolean;
ratedBy?: string[];
scoreRequiredFrom?: string;
scoreRequiredTo?: string;
scoreOptionalFrom?: string;
scoreOptionalTo?: string;
ratedUser?: string[];
contactId?: string[];
schemaId?: number[];
hasTransfer?: boolean;
timeline?: boolean;
};

export type ListCallExportsParams = {
/**
 * Page number (1-based).
 */
page?: number;
/**
 * Number of items per page.
 */
size?: number;
/**
 * sorting criteria, e.g. "+created_at" or "-name"
 */
sort?: string;
};

export type SearchFilesByCallParams = {
page?: number;
size?: number;
q?: string;
sort?: string;
fields?: string[];
id?: string[];
uploadedAtFrom?: string;
uploadedAtTo?: string;
referenceId?: string[];
retentionUntilFrom?: string;
retentionUntilTo?: string;
/**
 *  - ScreenRecordingChannel: ScreenshotChannel = 8; // deprecated
 */
channel?: SearchFilesByCallChannelItem[];
};

export type SearchFilesByCallChannelItem = typeof SearchFilesByCallChannelItem[keyof typeof SearchFilesByCallChannelItem];


export const SearchFilesByCallChannelItem = {
  UnknownChannel: 'UnknownChannel',
  ChatChannel: 'ChatChannel',
  MailChannel: 'MailChannel',
  CallChannel: 'CallChannel',
  LogChannel: 'LogChannel',
  MediaChannel: 'MediaChannel',
  KnowledgebaseChannel: 'KnowledgebaseChannel',
  CasesChannel: 'CasesChannel',
  ScreenRecordingChannel: 'ScreenRecordingChannel',
} as const;

export type SearchCasesParams = {
/**
 * Page number for pagination.
 */
page?: number;
/**
 * Number of results per page.
 */
size?: number;
/**
 * General query string.
 */
q?: string;
/**
 * List of specific case IDs to retrieve.
 */
ids?: string[];
/**
 * Sorting criteria (e.g., field:asc).
 */
sort?: string;
/**
 * List of fields to include in the response.
 */
fields?: string[];
/**
 * Key-value pairs for additional filtering.
 */
filters?: string[];
/**
 * Contact ID for filtering cases.
 */
contactId?: string;
/**
 * Specify which fields to apply 'q' to.
 */
qin?: string;
/**
 * Updated filters with CEL syntax.
 */
filtersV1?: string;
};

export type CreateCaseParams = {
/**
 * List of fields to include in the response.
 */
fields?: string[];
/**
 * Indicates whether to disable the trigger after the application execution.
Default is false (trigger **will** be executed).
Set to true to explicitly prevent the trigger from running (e.g., when called from another trigger or internal flow).
—Ç–æ
[WTEL-7055]
 */
disableTrigger?: boolean;
};

export type ListCatalogsParams = {
/**
 * Page number for pagination
 */
page?: number;
/**
 * Number of records per page
 */
size?: number;
/**
 * Fields to be retrieved as a result.
If the user passes "-" as the value for fields,
it will retrieve all available fields for each catalog.
 */
fields?: string[];
/**
 * Sorting options by fields
 */
sort?: string;
/**
 * List of IDs to filter the catalogs
 */
id?: string[];
/**
 * Search query string for filtering by name. Supports:
- Wildcards (*) for substring matching
- Placeholder (?) for single character substitution
- Exact match for full names
 */
query?: string;
/**
 * Filter by state (true for active, false for inactive)
 */
state?: boolean;
/**
 * Filter by the depth of the hierarchy to retrieve services.
The depth indicates how many ancestor levels of services
will be included for each catalog.
- A depth of 0 includes only the direct catalog.
- A depth of 1 includes the catalog and its immediate services.
- By default the depth is limited by 3,
  meaning all nested services and sub-services will be included.
 */
depth?: string;
/**
 * Fields to be retrieved as a result for [SUBSERVICES].
If the user passes "-" as the value for fields,
it will retrieve all available fields for each catalog subservices.
 */
subFields?: string[];
/**
 * Filter catalogs with subservices
 */
hasSubservices?: boolean;
};

export type CreateCatalogParams = {
fields?: string[];
};

export type LocateCatalogParams = {
/**
 * Fields to be retrieved as a result.
If the user passes "-" as the value for fields,
it will retrieve all available fields for each catalog.
 */
fields?: string[];
/**
 * Fields to be retrieved as a result for [SUBSERVICES].
If the user passes "-" as the value for fields,
it will retrieve all available fields for each catalog subservices.
 */
subFields?: string[];
};

export type UpdateCatalog2Params = {
fields?: string[];
};

export type UpdateCatalogParams = {
fields?: string[];
};

export type ListCloseReasonGroupsParams = {
page?: number;
size?: number;
fields?: string[];
sort?: string;
id?: string[];
q?: string;
};

export type CreateCloseReasonGroupParams = {
/**
 * Fields to be retrieved as a result.
 */
fields?: string[];
};

export type LocateCloseReasonGroupParams = {
fields?: string[];
};

export type UpdateCloseReasonGroup2Params = {
/**
 * Fields to be retrieved as a result.
 */
fields?: string[];
};

export type UpdateCloseReasonGroupParams = {
/**
 * Fields to be retrieved as a result.
 */
fields?: string[];
};

export type DeleteCommentParams = {
/**
 * Fields to return after deletion.
 */
fields?: string[];
};

export type LocateCommentParams = {
/**
 * Specific fields to return for the comment.
 */
fields?: string[];
};

export type UpdateComment2Params = {
/**
 * Fields to include in the response.
 */
fields?: string[];
/**
 * Optional updating timestamp. If not set, will be set default(current) time.
 */
updatedAt?: string;
};

export type UpdateComment2Body = {
  /** Content of the comment. */
  text?: string;
  /** Optional creator / updater ID. Use this to explicitly set the case creator / updater instead of deriving it from the auth token. */
  userId?: GeneralLookup;
};

export type UpdateCommentParams = {
/**
 * Fields to include in the response.
 */
fields?: string[];
/**
 * Optional updating timestamp. If not set, will be set default(current) time.
 */
updatedAt?: string;
};

export type UpdateCommentBody = {
  /** Content of the comment. */
  text?: string;
  /** Optional creator / updater ID. Use this to explicitly set the case creator / updater instead of deriving it from the auth token. */
  userId?: GeneralLookup;
};

export type ListPrioritiesParams = {
/**
 * Page number of result dataset records. offset = (page*size)
 */
page?: number;
/**
 * Size count of records on result page. limit = (size++)
 */
size?: number;
/**
 * Fields to be retrieved as a result.
 */
fields?: string[];
/**
 * Sort the result according to fields.
 */
sort?: string;
/**
 * Filter by unique IDs.
 */
id?: string[];
/**
 * Search query string for filtering by name. Supports:
- Wildcards (*) for substring matching
- Placeholder (?) for single character substitution
- Exact match for full names
 */
q?: string;
/**
 * Filter priorities that are not in filtered SLA
 */
notInSla?: string;
/**
 * Filter priorities that are in filtered SlaCondition and not in current SLA
 */
inSlaCond?: string;
};

export type CreatePriorityParams = {
/**
 * Fields to be retrieved as a result.
 */
fields?: string[];
};

export type LocatePriorityParams = {
/**
 * Fields to be retrieved as a result.
 */
fields?: string[];
};

export type UpdatePriority2Params = {
/**
 * Fields to be retrieved as a result.
 */
fields?: string[];
};

export type UpdatePriorityParams = {
/**
 * Fields to be retrieved as a result.
 */
fields?: string[];
};

export type ListServicesParams = {
/**
 * Page number for pagination
 */
page?: number;
/**
 * Number of records per page
 */
size?: number;
/**
 * Sorting options by fields
 */
sort?: string;
/**
 * List of IDs to filter the services
 */
id?: string[];
/**
 * Search query string for filtering by name. Supports:
- Wildcards (*) for substring matching
- Placeholder (?) for single character substitution
- Exact match for full names
 */
q?: string;
/**
 * Filter services by catalog ID (required)
 */
rootId?: string;
/**
 * Filter by state (true for active, false for inactive)
 */
state?: boolean;
/**
 * Fields to be retrieved as a result.
 */
fields?: string[];
};

export type CreateServiceParams = {
fields?: string[];
};

export type LocateServiceParams = {
/**
 * Fields to be retrieved as a result.
 */
fields?: string[];
};

export type UpdateService2Params = {
fields?: string[];
};

export type UpdateServiceParams = {
fields?: string[];
};

export type ListSLAsParams = {
/**
 * Page number of result dataset records. offset = (page*size)
 */
page?: number;
/**
 * Size count of records on result page. limit = (size++)
 */
size?: number;
/**
 * Fields to be retrieved as a result.
 */
fields?: string[];
/**
 * Sort the result according to fields.
 */
sort?: string;
/**
 * Filter by unique IDs.
 */
id?: string[];
/**
 * Search query string for filtering by name. Supports:
- Wildcards (*) for substring matching
- Placeholder (?) for single character substitution
- Exact match for full names
 */
q?: string;
};

export type CreateSLAParams = {
/**
 * Fields to be retrieved as a result.
 */
fields?: string[];
};

export type LocateSLAParams = {
fields?: string[];
};

export type UpdateSLA2Params = {
/**
 * Fields to be retrieved as a result.
 */
fields?: string[];
};

export type UpdateSLAParams = {
/**
 * Fields to be retrieved as a result.
 */
fields?: string[];
};

export type ListSourcesParams = {
/**
 * Page number of result dataset records. offset = (page * size)
Default: 0
 */
page?: number;
/**
 * Size count of records on result page. limit = (size++)
Default: 25
 */
size?: number;
/**
 * Fields to be retrieved as a result.
Default: [] (all fields)
 */
fields?: string[];
/**
 * Sort the result according to fields.
Default: "id:desc"
 */
sort?: string;
/**
 * Filter by unique IDs.
 */
id?: string[];
/**
 * Search query string for filtering by name. Supports:
- Wildcards (*)
- Placeholder (?)
- Exact match
 */
q?: string;
/**
 * Filter by source type.

 - TYPE_UNSPECIFIED: Unspecified source type.
 - CALL: Phone call source type.
 - CHAT: Chat source type.
 - SOCIAL_MEDIA: Social media source type.
 - EMAIL: Email source type.
 - API: API source type.
 - MANUAL: Manual source type.
 */
type?: ListSourcesTypeItem[];
};

export type ListSourcesTypeItem = typeof ListSourcesTypeItem[keyof typeof ListSourcesTypeItem];


export const ListSourcesTypeItem = {
  TypeUnspecified: 'TYPE_UNSPECIFIED',
  Call: 'CALL',
  Chat: 'CHAT',
  SocialMedia: 'SOCIAL_MEDIA',
  Email: 'EMAIL',
  Api: 'API',
  Manual: 'MANUAL',
} as const;

export type CreateSourceParams = {
/**
 * Optional list of specific fields to return after creation

Specific fields to include in response
 */
fields?: string[];
};

export type LocateSourceParams = {
/**
 * Fields to be retrieved into result.
 */
fields?: string[];
};

export type UpdateSource2Params = {
fields?: string[];
};

export type UpdateSourceParams = {
fields?: string[];
};

export type ListStatusesParams = {
/**
 * Page number of result dataset records. offset = (page*size)
 */
page?: number;
/**
 * Size count of records on result page. limit = (size++)
 */
size?: number;
/**
 * Fields to be retrieved as a result.
 */
fields?: string[];
/**
 * Sort the result according to fields.
 */
sort?: string;
/**
 * Filter by unique IDs.
 */
id?: string[];
/**
 * Search query string for filtering by name. Supports:
- Wildcards (*) for substring matching
- Placeholder (?) for single character substitution
- Exact match for full names
 */
q?: string;
};

export type CreateStatusParams = {
/**
 * Fields to be retrieved as a result.
 */
fields?: string[];
};

export type LocateStatusParams = {
fields?: string[];
};

export type UpdateStatus2Params = {
/**
 * Fields to be retrieved as a result.
 */
fields?: string[];
};

export type UpdateStatusParams = {
/**
 * Fields to be retrieved as a result.
 */
fields?: string[];
};

export type ListCommentsParams = {
/**
 * Page number for pagination.
 */
page?: number;
/**
 * Number of comments per page.
 */
size?: number;
/**
 * Query string for search.
 */
q?: string;
/**
 * Array of requested id.
 */
ids?: string[];
/**
 * Sorting order.
 */
sort?: string;
/**
 * Fields to return for each comment.
 */
fields?: string[];
};

export type PublishCommentParams = {
/**
 * Result fields to include in the response.
 */
fields?: string[];
/**
 * Optional creation timestamp. If not set, will be set default(current) time.
 */
createdAt?: string;
};

export type ListCommunicationsParams = {
/**
 * List of fields to include in the response.
 */
fields?: string[];
/**
 * Query string for filtering results.
 */
q?: string;
/**
 * Number of records per page.
 */
size?: number;
/**
 * Page number for pagination.
 */
page?: number;
/**
 * Sorting order.
 */
sort?: string;
};

export type LinkCommunicationParams = {
/**
 * List of fields to include in the response.
 */
fields?: string[];
};

export type UnlinkCommunicationParams = {
/**
 * List of fields to include in the response.
 */
fields?: string[];
};

export type ListFilesParams = {
/**
 * The page number to retrieve.
 */
page?: number;
/**
 * Number of items per page.
 */
size?: number;
/**
 * Search term.
 */
q?: string;
/**
 * Fields to include in the response.
 */
fields?: string[];
/**
 * Array of requested id.
 */
ids?: string[];
/**
 * Sorting
 */
sort?: string;
};

export type ListLinksParams = {
page?: number;
size?: number;
q?: string;
ids?: string[];
sort?: string;
fields?: string[];
};

export type CreateLinkParams = {
/**
 * result fields needed on the front-end for each comment
 */
fields?: string[];
inputEtag?: string;
inputUrl?: string;
inputName?: string;
inputUserIdId?: string;
inputUserIdName?: string;
};

export type LocateLinkParams = {
fields?: string[];
};

export type UpdateLink2Params = {
/**
 * on return
 */
fields?: string[];
};

export type UpdateLink2Body = {
  name?: string;
  url?: string;
  /** Optional creator / updater ID. Use this to explicitly set the case creator / updater instead of deriving it from the auth token. */
  userId?: GeneralLookup;
};

export type UpdateLinkParams = {
/**
 * on return
 */
fields?: string[];
};

export type UpdateLinkBody = {
  name?: string;
  url?: string;
  /** Optional creator / updater ID. Use this to explicitly set the case creator / updater instead of deriving it from the auth token. */
  userId?: GeneralLookup;
};

export type CasesChatCatalogGetCaseChatHistoryParams = {
/**
 * Messages ONLY starting from the specified message ID
 */
offsetId?: string;
/**
 * Messages ONLY been sent before the specified epochtime(milli).
 */
offsetDate?: string;
/**
 * Number of messages to return.
 */
size?: number;
page?: number;
/**
 * Search term: message.text
 */
q?: string;
/**
 * Fields to return into result.
 */
fields?: string[];
/**
 * Includes the history of ONLY those dialogs
whose member channel(s) contain
a specified set of variables.
 */
groupString?: string;
};

export type GetTimelineParams = {
page?: number;
size?: number;
q?: string;
sort?: string;
fields?: string[];
ids?: string[];
dateFrom?: string;
dateTo?: string;
type?: GetTimelineTypeItem[];
};

export type GetTimelineTypeItem = typeof GetTimelineTypeItem[keyof typeof GetTimelineTypeItem];


export const GetTimelineTypeItem = {
  Chat: 'chat',
  Call: 'call',
  Email: 'email',
} as const;

export type DeleteCaseParams = {
/**
 * List of fields to include in the deleted case response.
 */
fields?: string[];
};

export type LocateCaseParams = {
/**
 * List of fields to include in the response.
 */
fields?: string[];
};

export type UpdateCase2Params = {
/**
 * List of JSON fields to update.
 */
xJsonMask?: string[];
/**
 * List of fields to include in the response.
 */
fields?: string[];
/**
 * Indicates whether to disable the trigger after the application execution.
Default is false (trigger **will** be executed).
Set to true to explicitly prevent the trigger from running (e.g., when called from another trigger or internal flow).

[WTEL-7055]
 */
disableTrigger?: boolean;
};

/**
 * Custom data extension fields ..
 */
export type UpdateCase2BodyCustom = { [key: string]: unknown };

export type UpdateCase2Body = {
  assignee?: GeneralLookup;
  closeReason?: GeneralLookup;
  closeResult?: string;
  contactInfo?: string;
  /** Custom data extension fields .. */
  custom?: UpdateCase2BodyCustom;
  description?: string;
  group?: GeneralLookup;
  impacted?: GeneralLookup;
  priority?: GeneralLookup;
  rating?: string;
  ratingComment?: string;
  reporter?: GeneralLookup;
  service?: GeneralLookup;
  source?: GeneralLookup;
  status?: GeneralLookup;
  statusCondition?: WebitelCasesStatusCondition;
  subject?: string;
  /** Optional creator / updater ID. Use this to explicitly set the case creator / updater instead of deriving it from the auth token. */
  userId?: GeneralLookup;
};

export type UpdateCaseParams = {
/**
 * List of JSON fields to update.
 */
xJsonMask?: string[];
/**
 * List of fields to include in the response.
 */
fields?: string[];
/**
 * Indicates whether to disable the trigger after the application execution.
Default is false (trigger **will** be executed).
Set to true to explicitly prevent the trigger from running (e.g., when called from another trigger or internal flow).

[WTEL-7055]
 */
disableTrigger?: boolean;
};

/**
 * Custom data extension fields ..
 */
export type UpdateCaseBodyCustom = { [key: string]: unknown };

export type UpdateCaseBody = {
  assignee?: GeneralLookup;
  closeReason?: GeneralLookup;
  closeResult?: string;
  contactInfo?: string;
  /** Custom data extension fields .. */
  custom?: UpdateCaseBodyCustom;
  description?: string;
  group?: GeneralLookup;
  impacted?: GeneralLookup;
  priority?: GeneralLookup;
  rating?: string;
  ratingComment?: string;
  reporter?: GeneralLookup;
  service?: GeneralLookup;
  source?: GeneralLookup;
  status?: GeneralLookup;
  statusCondition?: WebitelCasesStatusCondition;
  subject?: string;
  /** Optional creator / updater ID. Use this to explicitly set the case creator / updater instead of deriving it from the auth token. */
  userId?: GeneralLookup;
};

export type UpdateRelatedCase2Params = {
/**
 * Fields to include in the response.
 */
fields?: string[];
};

/**
 * Primary case details.
 */
export type UpdateRelatedCase2BodyPrimaryCase = {
  name?: string;
};

export type UpdateRelatedCase2Body = {
  /** Primary case details. */
  primaryCase?: UpdateRelatedCase2BodyPrimaryCase;
  /** Related case details. */
  relatedCase?: GeneralLookup;
  /** Relation type. */
  relationType?: WebitelCasesRelationType;
  /** Optional creator / updater ID. Use this to explicitly set the case creator / updater instead of deriving it from the auth token. */
  userId?: GeneralLookup;
};

export type UpdateRelatedCaseParams = {
/**
 * Fields to include in the response.
 */
fields?: string[];
};

/**
 * Primary case details.
 */
export type UpdateRelatedCaseBodyPrimaryCase = {
  name?: string;
};

export type UpdateRelatedCaseBody = {
  /** Primary case details. */
  primaryCase?: UpdateRelatedCaseBodyPrimaryCase;
  /** Related case details. */
  relatedCase?: GeneralLookup;
  /** Relation type. */
  relationType?: WebitelCasesRelationType;
  /** Optional creator / updater ID. Use this to explicitly set the case creator / updater instead of deriving it from the auth token. */
  userId?: GeneralLookup;
};

export type ListRelatedCasesParams = {
/**
 * Page number for pagination.
 */
page?: number;
/**
 * Number of related cases per page.
 */
size?: number;
/**
 * Query string for search.
 */
q?: string;
/**
 * Sorting order.
 */
sort?: string;
/**
 * Fields to return for each related case.
 */
fields?: string[];
/**
 * Filter by ids
 */
ids?: string[];
};

export type CreateRelatedCaseParams = {
/**
 * Fields to include in the response.
 */
fields?: string[];
};

export type LocateRelatedCaseParams = {
/**
 * Fields to return in the response.
 */
fields?: string[];
};

export type CatalogGetCustomersParams = {
/**
 * Page number to return. **default**: 1.
 */
page?: number;
/**
 * Page records limit. **default**: 16.
 */
size?: number;
/**
 * Search term: peer{id,name}
 */
q?: string;
/**
 * Sort records by { fields } specification.
 */
sort?: string[];
/**
 * Fields [Q]uery to build result dataset record.
 */
fields?: string[];
/**
 * Set of unique contact **ID**entifier(s).
 */
id?: string[];
/**
 * The type of contact to filter.
 */
type?: string;
/**
 * Contact unique **ID**entifier.
Contact **type**-specific string.
 */
viaId?: string;
/**
 * Contact **type** provider.
 */
viaType?: string;
/**
 * Contact display **name**.
 */
viaName?: string;
};

export type CatalogGetDialogsParams = {
/**
 * Page number to return. **default**: 1.
 */
page?: number;
/**
 * Page records limit. **default**: 16.
 */
size?: number;
/**
 * Search term: peer.name
 */
q?: string;
/**
 * Sort records by { fields } specification.
 */
sort?: string[];
/**
 * Fields [Q]uery to build result dataset record.
 */
fields?: string[];
/**
 * Set of unique chat IDentifier(s).
Accept: dialog -or- member ID.
 */
id?: string[];
/**
 * Contact unique **ID**entifier.
Contact **type**-specific string.
 */
viaId?: string;
/**
 * Contact **type** provider.
 */
viaType?: string;
/**
 * Contact display **name**.
 */
viaName?: string;
/**
 * Contact unique **ID**entifier.
Contact **type**-specific string.
 */
peerId?: string;
/**
 * Contact **type** provider.
 */
peerType?: string;
/**
 * Contact display **name**.
 */
peerName?: string;
/**
 * Since epochtime (milli).
**Match**: greater than ..
 */
dateSince?: string;
/**
 * Until epochtime (milli).
**Match**: less or equal ..
 */
dateUntil?: string;
/**
 * Dialogs ONLY that are currently [not] active( closed: ? ).
 */
online?: boolean;
/**
 * Includes ONLY those chat dialogs
whose member channel(s) contain
a specified set of variables.

10
 */
groupString?: string;
};

export type CatalogGetMembersParams = {
/**
 * Page number to return. **default**: 1.
 */
page?: number;
/**
 * Page records limit. **default**: 16.
 */
size?: number;
/**
 * Search term: peer(type;name)
 */
q?: string;
/**
 * Sort records by { fields } specification.
 */
sort?: string[];
/**
 * Fields [Q]uery to build result dataset record.
 */
fields?: string[];
/**
 * Set of unique chat member ID.
 */
id?: string[];
/**
 * Contact unique **ID**entifier.
Contact **type**-specific string.
 */
viaId?: string;
/**
 * Contact **type** provider.
 */
viaType?: string;
/**
 * Contact display **name**.
 */
viaName?: string;
/**
 * Contact unique **ID**entifier.
Contact **type**-specific string.
 */
peerId?: string;
/**
 * Contact **type** provider.
 */
peerType?: string;
/**
 * Contact display **name**.
 */
peerName?: string;
/**
 * Since epochtime (milli).
**Match**: greater than ..
 */
dateSince?: string;
/**
 * Until epochtime (milli).
**Match**: less or equal ..
 */
dateUntil?: string;
/**
 * Participants ONLY who are currently [not] connected to the chat.
( left: ( 0 ? online : offline ) )
 */
online?: boolean;
/**
 * Participants ONLY who have [not] been connected to the chat.
( join: ( 0 ? [request|abandoned] : connected ) )
 */
joined?: boolean;
};

export type CatalogGetHistoryParams = {
/**
 * Messages ONLY starting from the specified message ID
 */
offsetId?: string;
/**
 * Messages ONLY been sent before the specified epochtime(milli).
 */
offsetDate?: string;
/**
 * Number of messages to return.
 */
limit?: number;
/**
 * Search term: message.text
 */
q?: string;
/**
 * Fields to return into result.
 */
fields?: string[];
/**
 * Contact unique **ID**entifier.
Contact **type**-specific string.
 */
peerId?: string;
/**
 * Contact **type** provider.
 */
peerType?: string;
/**
 * Contact display **name**.
 */
peerName?: string;
/**
 * Includes the history of ONLY those dialogs
whose member channel(s) contain
a specified set of variables.
 */
groupString?: string;
};

export type ContactLinkingServiceCreateContactFromConversationParams = {
timezoneId?: string;
timezoneName?: string;
ownerId?: string;
ownerName?: string;
label?: string[];
name?: string;
description?: string;
};

export type ContactLinkingServiceLinkContactToClientParams = {
contactId?: string;
};

export type CatalogGetHistory2Params = {
/**
 * Messages ONLY starting from the specified message ID
 */
offsetId?: string;
/**
 * Messages ONLY been sent before the specified epochtime(milli).
 */
offsetDate?: string;
/**
 * Number of messages to return.
 */
limit?: number;
/**
 * Search term: message.text
 */
q?: string;
/**
 * Fields to return into result.
 */
fields?: string[];
/**
 * Unique chat dialog
 */
chatId?: string;
/**
 * Contact display **name**.
 */
peerName?: string;
/**
 * Includes the history of ONLY those dialogs
whose member channel(s) contain
a specified set of variables.
 */
groupStringString?: string;
};

export type ListCloseReasonsParams = {
/**
 * Page number of result dataset records. offset = (page*size)
 */
page?: number;
/**
 * Size count of records on result page. limit = (size++)
 */
size?: number;
/**
 * Fields to be retrieved as a result.
 */
fields?: string[];
/**
 * Sort the result according to fields.
 */
sort?: string;
id?: string[];
/**
 * Search query string for filtering by name. Supports:
- Wildcards (*) for substring matching
- Placeholder (?) for single character substitution
- Exact match for full names
 */
q?: string;
};

export type CreateCloseReasonParams = {
/**
 * Fields to be retrieved as a result.
 */
fields?: string[];
};

export type LocateCloseReasonParams = {
fields?: string[];
};

export type UpdateCloseReason2Params = {
/**
 * Fields to be retrieved as a result.
 */
fields?: string[];
};

export type UpdateCloseReasonParams = {
/**
 * Fields to be retrieved as a result.
 */
fields?: string[];
};

export type SearchContactsParams = {
/**
 * Page number of result records.   _default(1); offset=(size*(page-1));_

```javascript
let
    offset = 0
  , page = req.page
;
if (page <= 0)
    page = 1;
if (page > 1)
    offset = ((page-1)*size);
// . . .
```
 */
page?: number;
/**
 * Limit of result page records count.   _default(16); limit=(size<=0?-1:size+1);_

```javascript
const
    default = 16
  , maximum = 32
;
let limit = req.size;
if (limit <= 0)
    limit = default;
if (maximum < limit)
    limit = maximum;
// . . .
```
 */
size?: number;
/**
 * Search term:
`?` - matches any character
`*` - matches 0 or more characters
Used to query records within a set of `qin` fields, eg: name,emails{type},labels etc...
 */
q?: string;
/**
 * Sort result dataset of records by fields.
```
sort ::= *( ORDER name )

ORDER  = ASC / DESC
DESC   = "-" / "!"
ASC    = [ "+" ]   ; Default
```

Fields available

- `id`(seq)
- `domain`{name}
- `created_at`
- `created_by`{name}
- `updated_at`
- `updated_by`{name}

Use ?fields=`field.sort()` option to sort Edge fields.
 */
sort?: string[];
/**
 * Fields [Q]uery to build result dataset record.
```
fields ::= field [ *( "," field ) ]
field  ::= name [ *( func ) ] [ inner ]
inner  ::= "{" fields "}"
funcs  ::= *( func )
func   ::= "." name "(" [ args ] ")"
name   ::= ALPHA / DIGIT / USCORE

ALPHA    = %x41-5A / %x61-7A  ; "A"-"Z" / "a"-"z"
DIGIT    = %x30-39            ; "0"-"9"
USCORE   = %x5F ; underscore  ; "_"
```
 */
fields?: string[];
/**
 * Records with unique IDentifier(s).
Accept: `id` -or- `etag`.
 */
id?: string[];
/**
 * [Q]uery[IN] is a set of search fields for term `q`.
Default: `name{common_name}`.
 */
qin?: string[];
/**
 * Source access mode requirement.

 - READ: Can `fetch` record. [GET]
 - WRITE: Can `update` record. [PUT|PATCH]
 - DELETE: Can `delete` record. [DELETE]
 */
mode?: SearchContactsMode;
/**
 * Excludes contacts that belong to the specified group ID.
- Filters out contacts associated with the given `group_id`.
 */
notIdGroup?: string;
/**
 * Filters contacts by the specified group(s).
- Includes only contacts that belong to one or more of the given group Group(s).
 */
group?: string[];
/**
 * Filters contacts by the specified owner(s).
- Includes only contacts whose owner matches one or more of the given Owner(s).
- The owner ID corresponds to `contact_id` in the `directory.wbt_user` table.
 */
owner?: string[];
/**
 * Filters contacts by the specified label(s).
- Includes only contacts that have one or more of the given Label(s).
 */
label?: string[];
/**
 * Filters contacts based on whether they are user-associated.
- `true`  ‚Üí Includes only user-associated contacts.
- `false` ‚Üí Includes only contacts that are NOT user-associated.
- A contact is considered user-associated if it exists in `directory.wbt_user`.
 */
user?: boolean;
};

export type SearchContactsMode = typeof SearchContactsMode[keyof typeof SearchContactsMode];


export const SearchContactsMode = {
  Read: 'READ',
  Write: 'WRITE',
  Delete: 'DELETE',
} as const;

export type CreateContactParams = {
/**
 * Source Fields to return into result.
 */
fields?: string[];
};

export type ListGroupsParams = {
/**
 * Page number of result dataset records. offset = (page*size)
 */
page?: number;
/**
 * Size count of records on result page. limit = (size++)
 */
size?: number;
/**
 * Fields to be retrieved as a result.
 */
fields?: string[];
/**
 * Sort the result according to fields.
 */
sort?: string[];
/**
 * Filter by unique IDs.
 */
id?: string[];
/**
 * Search term: group name;
`?` - matches any one character
`*` - matches 0 or more characters
 */
q?: string;
/**
 * Filter by group name.
 */
name?: string;
/**
 * Filter by group type.

 - GROUP_TYPE_UNSPECIFIED: Default value
 - STATIC: Static group
 - DYNAMIC: Dynamic group
 */
type?: ListGroupsType;
/**
 * Filter by only enabled group
 */
enabled?: boolean;
};

export type ListGroupsType = typeof ListGroupsType[keyof typeof ListGroupsType];


export const ListGroupsType = {
  GroupTypeUnspecified: 'GROUP_TYPE_UNSPECIFIED',
  Static: 'STATIC',
  Dynamic: 'DYNAMIC',
} as const;

export type LocateConditionParams = {
/**
 * Fields to be retrieved as a result.
 */
fields?: string[];
};

export type ListDynamicGroupsParams = {
/**
 * Page number of result dataset records. offset = (page*size)
 */
page?: number;
/**
 * Size count of records on result page. limit = (size++)
 */
size?: number;
/**
 * Fields to be retrieved as a result.
 */
fields?: string[];
/**
 * Sort the result according to fields.
 */
sort?: string[];
/**
 * Filter by unique IDs.
 */
id?: string[];
/**
 * Search term: group name;
`?` - matches any one character
`*` - matches 0 or more characters
 */
q?: string;
/**
 * Filter by group name.
 */
name?: string;
};

export type ListConditionsParams = {
/**
 * Page number of result dataset records. offset = (page*size)
 */
page?: number;
/**
 * Size count of records on result page. limit = (size++)
 */
size?: number;
/**
 * Fields to be retrieved as a result.
 */
fields?: string[];
/**
 * Sort the result according to fields.
 */
sort?: string[];
/**
 * Search term for conditions.
 */
q?: string;
/**
 * Filter by unique IDs.
 */
id?: string[];
};

export type RemoveContactsFromGroupParams = {
/**
 * List of contact IDs to remove from the group.
 */
contactIds?: string[];
};

export type LocateGroupParams = {
/**
 * Fields to be retrieved into result.
 */
fields?: string[];
};

export type LocateDynamicGroupParams = {
fields?: string[];
};

export type GetLabelsParams = {
/**
 * Page number of result dataset records. offset = ((page-1)*size)
 */
page?: number;
/**
 * Size count of records on result page. limit = (size+1)
 */
size?: number;
/**
 * Search term: label.
`?` - matches any one character
`*` - matches 0 or more characters
 */
q?: string;
};

export type SearchCases2Params = {
/**
 * Page number for pagination.
 */
page?: number;
/**
 * Number of results per page.
 */
size?: number;
/**
 * General query string.
 */
q?: string;
/**
 * List of specific case IDs to retrieve.
 */
ids?: string[];
/**
 * Sorting criteria (e.g., field:asc).
 */
sort?: string;
/**
 * List of fields to include in the response.
 */
fields?: string[];
/**
 * Key-value pairs for additional filtering.
 */
filters?: string[];
/**
 * Specify which fields to apply 'q' to.
 */
qin?: string;
/**
 * Updated filters with CEL syntax.
 */
filtersV1?: string;
};

export type ContactsChatCatalogGetContactChatHistory2Params = {
/**
 * Messages ONLY starting from the specified message ID
 */
offsetId?: string;
/**
 * Messages ONLY been sent before the specified epochtime(milli).
 */
offsetDate?: string;
/**
 * Number of messages to return.
 */
size?: number;
page?: number;
/**
 * Search term: message.text
 */
q?: string;
/**
 * Fields to return into result.
 */
fields?: string[];
/**
 * Unique chat dialog
 */
chatId?: string;
/**
 * Includes the history of ONLY those dialogs
whose member channel(s) contain
a specified set of variables.
 */
groupStringString?: string;
};

export type ContactsChatCatalogGetContactChatHistoryParams = {
/**
 * Messages ONLY starting from the specified message ID
 */
offsetId?: string;
/**
 * Messages ONLY been sent before the specified epochtime(milli).
 */
offsetDate?: string;
/**
 * Number of messages to return.
 */
size?: number;
page?: number;
/**
 * Search term: message.text
 */
q?: string;
/**
 * Fields to return into result.
 */
fields?: string[];
/**
 * Includes the history of ONLY those dialogs
whose member channel(s) contain
a specified set of variables.
 */
groupString?: string;
};

export type SearchCommentsParams = {
/**
 * Page number of result. offset = ((page-1)*size)
 */
page?: number;
/**
 * Size of result page. limit = (size++)
 */
size?: number;
/**
 * Search term: comment text;
`?` - matches any character
`*` - matches 0 or more characters

term-of-search: lookup[name|...]
 */
q?: string;
/**
 * Sort the result according to fields.
 */
sort?: string[];
/**
 * Fields to be retrieved as a result.
 */
fields?: string[];
/**
 * Comment(s) with unique ID only.
 */
id?: string[];
/**
 * The requirement of [M]andatory [A]ccess [C]ontrol.

 - READ: Can `fetch` record. [GET]
 - WRITE: Can `update` record. [PUT|PATCH]
 - DELETE: Can `delete` record. [DELETE]
 */
mode?: SearchCommentsMode;
/**
 * Since timestamp(milli). Not before.
 */
dateSince?: string;
/**
 * Until timestamp(milli). Not after.
 */
dateUntil?: string;
/**
 * Reference Object unique ID.
 */
authorId?: string;
/**
 * Reference Object well-known type.
 */
authorType?: string;
/**
 * Reference Object display name.
 */
authorName?: string;
/**
 * Reference Object unique ID.
 */
editorId?: string;
/**
 * Reference Object well-known type.
 */
editorType?: string;
/**
 * Reference Object display name.
 */
editorName?: string;
};

export type SearchCommentsMode = typeof SearchCommentsMode[keyof typeof SearchCommentsMode];


export const SearchCommentsMode = {
  Read: 'READ',
  Write: 'WRITE',
  Delete: 'DELETE',
} as const;

export type PublishCommentCommentsParams = {
/**
 * Fields to be retrieved as a result.
 */
fields?: string[];
};

export type DeleteCommentCommentsParams = {
/**
 * Fields to be retrieved as a result.
 */
fields?: string[];
};

export type UpdateCommentCommentsParams = {
/**
 * Fields to be retrieved into result of changes.
 */
fields?: string[];
};

export type UpdateCommentCommentsBody = {
  /** NEW Text components styling format. */
  format?: CommentFormat[];
  /** NEW Text of the comment. */
  text: string;
};

export type DeleteEmailsParams = {
/**
 * Fields to be retrieved as a result.
 */
fields?: string[];
/**
 * Set of unique ID(s) to remove.
 */
etag: string[];
};

export type ListEmailsParams = {
/**
 * Page number of result dataset records. offset = (page*size)
 */
page?: number;
/**
 * Size count of records on result page. limit = (size++)
 */
size?: number;
/**
 * Search term: email address.
`?` - matches any one character
`*` - matches 0 or more characters
 */
q?: string;
/**
 * Sort the result according to fields.
 */
sort?: string[];
/**
 * Fields to be retrieved into result.
 */
fields?: string[];
/**
 * Link(s) with unique ID only.
 */
id?: string[];
/**
 * Primary email address only.
 */
primary?: boolean;
/**
 * Verified email addresses only.
 */
verified?: boolean;
/**
 * Reference Object unique ID.
 */
typeId?: string;
/**
 * Reference Object well-known type.
 */
typeType?: string;
/**
 * Reference Object display name.
 */
typeName?: string;
};

export type MergeEmailsParams = {
/**
 * Fields to be retrieved into result of changes.
 */
fields?: string[];
};

export type ResetEmailsParams = {
/**
 * Fields to be retrieved into result of changes.
 */
fields?: string[];
};

export type DeleteEmailParams = {
/**
 * Fields to be retrieved as a result.
 */
fields?: string[];
};

export type LocateEmailParams = {
/**
 * Fields to be retrieved into result.
 */
fields?: string[];
};

export type UpdateEmail2Params = {
/**
 * Fields to be retrieved into result of changes.
 */
fields?: string[];
};

export type UpdateEmail2Body = {
  /** The email address. */
  email: string;
  /** Indicates whether this phone number is default within other channels of the same type(phone). */
  primary?: boolean;
  type?: WebitelcontactsLookup;
  verified?: boolean;
};

export type UpdateEmailParams = {
/**
 * Fields to be retrieved into result of changes.
 */
fields?: string[];
};

export type UpdateEmailBody = {
  /** The email address. */
  email: string;
  /** Indicates whether this phone number is default within other channels of the same type(phone). */
  primary?: boolean;
  type?: WebitelcontactsLookup;
  verified?: boolean;
};

export type DeleteContactGroupsParams = {
/**
 * Fields to be retrieved as a result.
 */
fields?: string[];
/**
 * Set of unique ID(s) to remove.
 */
etag: string[];
};

export type ListContactGroupsParams = {
/**
 * Page number of result dataset records. offset = (page*size)
 */
page?: number;
/**
 * Size count of records on result page. limit = (size++)
 */
size?: number;
/**
 * Search term: group name;
`?` - matches any one character
`*` - matches 0 or more characters
 */
query?: string;
/**
 * Sort the result according to fields.
 */
sort?: string[];
/**
 * Fields to be retrieved as a result.
 */
fields?: string[];
/**
 * Record(s) with unique ID only.
 */
id?: string[];
};

export type MergeContactGroupsParams = {
/**
 * Fields to be retrieved as a result.
 */
fields?: string[];
};

export type ResetContactGroupsParams = {
/**
 * Fields to be retrieved into result of changes.
 */
fields?: string[];
};

export type DeleteContactGroupParams = {
/**
 * Fields to be retrieved as a result.
 */
fields?: string[];
};

export type LocateContactGroupParams = {
/**
 * Fields to be retrieved into result.
 */
fields?: string[];
};

export type UpdateContactGroup2Params = {
/**
 * Fields to be retrieved into result of changes.
 */
fields?: string[];
};

export type UpdateContactGroup2Body = {
  /** Group of contacts associated. */
  group?: WebitelcontactsLookup;
};

export type UpdateContactGroupParams = {
/**
 * Fields to be retrieved into result of changes.
 */
fields?: string[];
};

export type UpdateContactGroupBody = {
  /** Group of contacts associated. */
  group?: WebitelcontactsLookup;
};

export type ListIMClientsParams = {
/**
 * Page number of result dataset records. offset = (page*size)
 */
page?: number;
/**
 * Size count of records on result page. limit = (size++)
 */
size?: number;
/**
 * Search term: IMClient.
`?` - matches any one character
`*` - matches 0 or more characters
Search fields: {user,app}
 */
q?: string;
/**
 * Sort the result according to fields.
 */
sort?: string[];
/**
 * Fields to be retrieved into result.
 */
fields?: string[];
/**
 * Link(s) with unique ID only.
 */
id?: string[];
};

export type DeleteLabelsParams = {
/**
 * Fields to be retrieved into result.
 */
fields?: string[];
/**
 * Set of unique label(s).etag identifiers.
 */
etag: string[];
};

export type ListLabelsParams = {
/**
 * Page number of result dataset records. offset = ((page-1)*size)
 */
page?: number;
/**
 * Size count of records on result page. limit = (size+1)
 */
size?: number;
/**
 * Search term: label tag.
`?` - matches any one character
`*` - matches 0 or more characters
 */
q?: string;
/**
 * Sort the result according to fields.
 */
sort?: string[];
/**
 * Fields to be retrieved into result.
 */
fields?: string[];
/**
 * Record(s) with unique ID or ETag.
 */
id?: string[];
};

export type MergeLabelsParams = {
/**
 * Fields to be retrieved into result.
 */
fields?: string[];
};

export type ResetLabelsParams = {
/**
 * Fields to be retrieved into result.
 */
fields?: string[];
};

export type DelContactLanguagesParams = {
/**
 * Fields to be retrieved as a result.
 */
fields?: string[];
/**
 * Set of unique language{etag} association(s) to remove.
 */
etag: string[];
};

export type GetContactLanguagesParams = {
/**
 * Page number of result dataset records. offset = (page*size)
 */
page?: number;
/**
 * Size count of records on result page. limit = (size++)
 */
size?: number;
/**
 * Search term: language tag (lang, name, region, ..)
`?` - matches any one character
`*` - matches 0 or more characters
 */
q?: string;
/**
 * Sort the result according to fields.
 */
sort?: string[];
/**
 * Fields to be retrieved as a result.
 */
fields?: string[];
/**
 * Language(s) with unique ID|ETag only.
 */
id?: string[];
/**
 * Primary language only.
 */
primary?: boolean;
code?: string;
lang?: string;
name?: string;
region?: string;
};

export type AddContactLanguagesParams = {
/**
 * Fields to be retrieved as a result.
 */
fields?: string[];
};

export type SetContactLanguagesParams = {
/**
 * Fields to be retrieved as a result.
 */
fields?: string[];
};

export type DelContactLanguageParams = {
/**
 * Fields to be retrieved as a result.
 */
fields?: string[];
};

export type SetContactLanguage2Params = {
/**
 * Fields to be retrieved as a result.
 */
fields?: string[];
};

export type SetContactLanguage2Body = {
  /** Indicates whether this association must be default
among others of the same type. */
  primary?: boolean;
  tag?: string;
};

export type SetContactLanguageParams = {
/**
 * Fields to be retrieved as a result.
 */
fields?: string[];
};

export type SetContactLanguageBody = {
  /** Indicates whether this association must be default
among others of the same type. */
  primary?: boolean;
  tag?: string;
};

export type DeleteManagersParams = {
/**
 * Fields to be retrieved as a result.
 */
fields?: string[];
/**
 * Set of unique ID(s) to remove.
 */
etag: string[];
};

export type ListManagersParams = {
/**
 * Page number of result. offset = ((page-1)*size)
 */
page?: number;
/**
 * Size of result page. limit = (size++)
 */
size?: number;
/**
 * Search term: user name;
`?` - matches any one character
`*` - matches 0 or more characters
 */
q?: string;
/**
 * Sort the result according to fields.
 */
sort?: string[];
/**
 * Fields to be retrieved as a result.
 */
fields?: string[];
/**
 * Record(s) with unique ID only.
 */
id?: string[];
};

export type MergeManagersParams = {
/**
 * Fields to be retrieved as a result.
 */
fields?: string[];
};

export type ResetManagersParams = {
/**
 * Fields to be retrieved as a result.
 */
fields?: string[];
};

export type DeleteManagerParams = {
/**
 * Fields to be retrieved as a result.
 */
fields?: string[];
};

export type LocateManagerParams = {
/**
 * Fields to be retrieved into result.
 */
fields?: string[];
};

export type UpdateManager2Params = {
/**
 * Fields to be retrieved into result of changes.
 */
fields?: string[];
};

export type UpdateManager2Body = {
  /** Indicates whether this association must be default among others. */
  primary?: boolean;
  /** Responsible User. */
  user?: WebitelcontactsLookup;
};

export type UpdateManagerParams = {
/**
 * Fields to be retrieved into result of changes.
 */
fields?: string[];
};

export type UpdateManagerBody = {
  /** Indicates whether this association must be default among others. */
  primary?: boolean;
  /** Responsible User. */
  user?: WebitelcontactsLookup;
};

export type DeletePhonesParams = {
/**
 * Fields to be retrieved into result.
 */
fields?: string[];
/**
 * Set of linked ID(s) to be removed.
 */
etag: string[];
};

export type ListPhonesParams = {
/**
 * Page number of result dataset records. offset = (page*size)
 */
page?: number;
/**
 * Size count of records on result page. limit = (size++)
 */
size?: number;
/**
 * Search term: phone number.
`?` - matches any one character
`*` - matches 0 or more characters
 */
q?: string;
/**
 * Sort the result according to fields.
 */
sort?: string[];
/**
 * Fields to be retrieved into result.
 */
fields?: string[];
/**
 * Link(s) with unique ID only.
 */
id?: string[];
/**
 * Primary phone  only.
 */
primary?: boolean;
/**
 * Verified phone only.
 */
verified?: boolean;
/**
 * Reference Object unique ID.
 */
typeId?: string;
/**
 * Reference Object well-known type.
 */
typeType?: string;
/**
 * Reference Object display name.
 */
typeName?: string;
};

export type MergePhonesParams = {
/**
 * Fields to be retrieved into result of changes.
 */
fields?: string[];
};

export type ResetPhonesParams = {
/**
 * Fields to be retrieved into result of changes.
 */
fields?: string[];
};

export type DeletePhoneParams = {
/**
 * Fields to be retrieved into result.
 */
fields?: string[];
};

export type LocatePhoneParams = {
/**
 * Fields [Q]uery to build result record.
 */
fields?: string[];
};

export type UpdatePhone2Params = {
/**
 * Fields to be retrieved into result of changes.
 */
fields?: string[];
};

export type UpdatePhone2Body = {
  /** The phone number. */
  number: string;
  /** Indicates whether this phone number is default within other channels of the same type(phone). */
  primary?: boolean;
  type?: WebitelcontactsLookup;
  verified?: boolean;
};

export type UpdatePhoneParams = {
/**
 * Fields to be retrieved into result of changes.
 */
fields?: string[];
};

export type UpdatePhoneBody = {
  /** The phone number. */
  number: string;
  /** Indicates whether this phone number is default within other channels of the same type(phone). */
  primary?: boolean;
  type?: WebitelcontactsLookup;
  verified?: boolean;
};

export type DeletePhotosParams = {
/**
 * Fields to be retrieved into result of changes.
 */
fields?: string[];
/**
 * Set of linked ID(s) to be removed.
 */
etag: string[];
};

export type SearchPhotosParams = {
/**
 * Page number of result dataset records. offset = (page*size)
 */
page?: number;
/**
 * Size count of records on result page. limit = (size++)
 */
size?: number;
/**
 * Search term: email address.
`?` - matches any one character
`*` - matches 0 or more characters
 */
q?: string;
/**
 * Sort the result according to fields.
 */
sort?: string[];
/**
 * Fields to be retrieved into result.
 */
fields?: string[];
/**
 * Link(s) with unique ID only.
 */
id?: string[];
/**
 * Default photos only.
 */
primary?: boolean;
};

export type CreatePhotosParams = {
/**
 * Fields to be retrieved into result of changes.
 */
fields?: string[];
};

export type UpdatePhotosParams = {
/**
 * Fields to be retrieved into result of changes.
 */
fields?: string[];
};

export type DeletePhotoParams = {
/**
 * Fields to be retrieved into result of changes.
 */
fields?: string[];
};

export type UpdatePhoto2Params = {
/**
 * Fields to be retrieved into result of changes.
 */
fields?: string[];
};

export type UpdatePhoto2Body = {
  photoId?: string;
  photoUrl?: string;
  /** True if the photo is a default photo; false if the photo is a user-provided photo. */
  primary?: boolean;
};

export type UpdatePhotoParams = {
/**
 * Fields to be retrieved into result of changes.
 */
fields?: string[];
};

export type UpdatePhotoBody = {
  photoId?: string;
  photoUrl?: string;
  /** True if the photo is a default photo; false if the photo is a user-provided photo. */
  primary?: boolean;
};

export type LocatePhotoParams = {
/**
 * Fields to be retrieved into result.
 */
fields?: string[];
};

export type GetTimelineTimelineParams = {
page?: string;
size?: string;
q?: string;
sort?: string;
fields?: string[];
ids?: string[];
dateFrom?: string;
dateTo?: string;
type?: GetTimelineTimelineTypeItem[];
};

export type GetTimelineTimelineTypeItem = typeof GetTimelineTimelineTypeItem[keyof typeof GetTimelineTimelineTypeItem];


export const GetTimelineTimelineTypeItem = {
  Chat: 'chat',
  Call: 'call',
  Email: 'email',
} as const;

export type DeleteTimezonesParams = {
/**
 * Fields to be retrieved as a result.
 */
fields?: string[];
/**
 * Set of unique ID(s) to remove.
 */
etag: string[];
};

export type ListTimezonesParams = {
/**
 * Page number of result dataset records. offset = (page*size)
 */
page?: number;
/**
 * Size count of records on result page. limit = (size++)
 */
size?: number;
/**
 * Search term: location name;
`?` - matches any one character
`*` - matches 0 or more characters
 */
q?: string;
/**
 * Sort the result according to fields.
 */
sort?: string[];
/**
 * Fields to be retrieved as a result.
 */
fields?: string[];
/**
 * Record(s) with unique ID only.
 */
id?: string[];
/**
 * Primary timezone only.
 */
primary?: boolean;
};

export type MergeTimezonesParams = {
/**
 * Fields to be retrieved as a result.
 */
fields?: string[];
};

export type ResetTimezonesParams = {
/**
 * Fields to be retrieved into result of changes.
 */
fields?: string[];
};

export type DeleteTimezoneParams = {
/**
 * Fields to be retrieved as a result.
 */
fields?: string[];
};

export type LocateTimezoneParams = {
/**
 * Fields to be retrieved into result.
 */
fields?: string[];
};

export type UpdateTimezone2Params = {
/**
 * Fields to be retrieved into result of changes.
 */
fields?: string[];
};

export type UpdateTimezone2Body = {
  /** Indicates whether this association must be default among others. */
  primary?: boolean;
  /** Timezone dictionary reference value associated. */
  timezone?: WebitelcontactsLookup;
};

export type UpdateTimezoneParams = {
/**
 * Fields to be retrieved into result of changes.
 */
fields?: string[];
};

export type UpdateTimezoneBody = {
  /** Indicates whether this association must be default among others. */
  primary?: boolean;
  /** Timezone dictionary reference value associated. */
  timezone?: WebitelcontactsLookup;
};

export type DeleteVariablesParams = {
/**
 * Fields to be retrieved as a result.
 */
fields?: string[];
/**
 * Set of unique ID(s) to remove.
 */
etag: string[];
};

export type ListVariablesParams = {
/**
 * Page number of result. offset = ((page-1)*size)
 */
page?: number;
/**
 * Size of result page. limit = (size++)
 */
size?: number;
/**
 * Search term: variable key;
`?` - matches any one character
`*` - matches 0 or more characters
 */
q?: string;
/**
 * Sort the result according to fields.
 */
sort?: string[];
/**
 * Fields to be retrieved as a result.
 */
fields?: string[];
/**
 * Record(s) with unique ID only.
 */
id?: string[];
};

export type MergeVariablesParams = {
/**
 * Fields to be retrieved as a result.
 */
fields?: string[];
};

export type ResetVariablesParams = {
/**
 * Fields to be retrieved into result of changes.
 */
fields?: string[];
};

export type DeleteVariableParams = {
/**
 * Fields to be retrieved as a result.
 */
fields?: string[];
};

export type UpdateVariable2Params = {
/**
 * Fields to be retrieved into result of changes.
 */
fields?: string[];
};

export type UpdateVariable2Body = {
  /**
   * NEW Key.
   * @pattern ^\w+$
   */
  key: string;
  /** NEW Value. */
  value?: unknown;
};

export type UpdateVariableParams = {
/**
 * Fields to be retrieved into result of changes.
 */
fields?: string[];
};

export type UpdateVariableBody = {
  /**
   * NEW Key.
   * @pattern ^\w+$
   */
  key: string;
  /** NEW Value. */
  value?: unknown;
};

export type DeleteContactParams = {
/**
 * Fields to be retrieved into result of changes.
 */
fields?: string[];
};

export type LocateContactParams = {
/**
 * Source Fields to return into result.
 */
fields?: string[];
/**
 * The requirement of a special access mode to the Source.

 - READ: Can `fetch` record. [GET]
 - WRITE: Can `update` record. [PUT|PATCH]
 - DELETE: Can `delete` record. [DELETE]
 */
mode?: LocateContactMode;
};

export type LocateContactMode = typeof LocateContactMode[keyof typeof LocateContactMode];


export const LocateContactMode = {
  Read: 'READ',
  Write: 'WRITE',
  Delete: 'DELETE',
} as const;

export type UpdateContactParams = {
/**
 * Source Fields to return into result.
 */
fields?: string[];
};

export type UpdateContactBody = {
  /** BIO. Short description about the Contact person.
OPTIONAL. Multi-lined text. */
  about?: string;
  /** Publish NEW comment(s) for this Contact. */
  comments?: ContactsInputComment[];
  /** The Contact's email address(es). */
  emails?: ContactsInputEmailAddress[];
  /** The Contact's associated group(s). */
  groups?: ContactsInputContactGroup[];
  /** The contact's [I]nstant[M]essaging clients. */
  imclients?: ContactsInputIMClient[];
  /** The Contact's associated label(s). */
  labels?: ContactsInputLabel[];
  /** A Contact's locale preference(s). */
  languages?: ContactsInputLanguage[];
  /** The Contact's internal manager(s). */
  managers?: ContactsInputManager[];
  name?: ContactsInputName;
  /** The Contact's phone numbers. */
  phones?: ContactsInputPhoneNumber[];
  /** Output only. The Contact's photo(s). */
  readonly photos?: readonly ContactsInputPhoto[];
  /** The Contact's timezone preference(s). */
  timezones?: ContactsInputTimezone[];
  /** Arbitrary client data that is populated by clients. */
  variables?: ContactsInputVariable[];
};

export type GetCustomerParams = {
/**
 * Available Filters

show by customer id; serial number (uuid)
 */
id?: string;
/**
 * show if valid only!
 */
valid?: boolean;
/**
 * identifier
 */
domainId?: string;
/**
 * display name
 */
domainName?: string;
/**
 * Request Controls

serial,
 */
fields?: string[];
sort?: string[];
};

export type UpdateCustomerParams = {
/**
 * [optional] e.g.: Example Org.
 */
organization?: string;
/**
 * [optional] logo source image
 */
logoPicture?: string;
/**
 * [optional] raw bytes protobuf::base64.RawStdEncoding != certificate::base64.StdEncoding
 */
certificate?: string;
revoke?: boolean;
};

export type LicenseUsageParams = {
/**
 * ----- Search Options ----- //

default: 16
 */
size?: number;
/**
 * default: 1
 */
page?: number;
/**
 * set of output fields
 */
fields?: string[];
/**
 * e.g.: "updated_at" - ASC; "!updated_at" - DESC;
 */
sort?: string[];
/**
 * identifier
 */
userId?: string;
/**
 * display name
 */
userName?: string;
/**
 * identifier
 */
domainId?: string;
/**
 * display name
 */
domainName?: string;
/**
 * by serial number(s)
 */
id?: string[];
/**
 * by product name(s)
 */
product?: string[];
/**
 * view: all|valid|grantable

show: available to be granted
 */
valid?: boolean;
/**
 * filter: term of search
 */
q?: string;
};

export type GetCustomer2Params = {
/**
 * show if valid only!
 */
valid?: boolean;
/**
 * identifier
 */
domainId?: string;
/**
 * display name
 */
domainName?: string;
/**
 * Request Controls

serial,
 */
fields?: string[];
sort?: string[];
};

export type DeleteDevice2Params = {
id?: string;
permanent?: boolean;
};

export type SearchDeviceParams = {
/**
 * ----- Select Options -------------------------

default: 16
 */
size?: number;
/**
 * default: 1
 */
page?: number;
/**
 * attributes list
 */
fields?: string[];
/**
 * e.g.: "updated_at" - ASC; "!updated_at" - DESC;
 */
sort?: string[];
/**
 * ----- Search Basic Filters ---------------------------

selection: by unique identifier
 */
ids?: string[];
/**
 * term-of-search: lookup[name,account,hotdesk,brand,model,mac,ip]
 */
q?: string;
/**
 * case-ignore substring match: ILIKE '*' - any; '?' - one
 */
name?: string;
/**
 * [M]andatory[A]ccess[C]ontrol: with access mode (action) granted!
 */
access?: string;
/**
 * ----- Device-Specific Filters ----------------

substring like '%name%'
 */
account?: string;
/**
 * filter: has hotdesk (=pattern); is hotdesk (=*)
 */
hotdesk?: string;
/**
 * Object ID
 */
userId?: string;
/**
 * Display Name
 */
userName?: string;
/**
 * filter: by MAC address
 */
mac?: string;
/**
 * filter: by IP address
 */
ip?: string;
};

export type UpdateDevice2Params = {
/**
 * PATCH: partial update
 */
fields?: string[];
};

export type UpdateDevice2BodyProvision = {[key: string]: string};

export type UpdateDevice2Body = {
  /** username */
  account?: string;
  /** vendor brand name */
  brand?: string;
  createdAt?: string;
  createdBy?: ApiUserId;
  deletedAt?: string;
  deletedBy?: ApiUserId;
  /** act as a hotdesk */
  hotdesk?: boolean;
  hotdesks?: string[];
  ip?: string;
  loggedIn?: string;
  mac?: string;
  model?: string;
  /** display name */
  name?: string;
  password?: string;
  provision?: UpdateDevice2BodyProvision;
  reged?: boolean;
  updatedAt?: string;
  updatedBy?: ApiUserId;
  user?: ApiUserId;
};

export type UpdateDeviceParams = {
/**
 * PATCH: partial update
 */
fields?: string[];
};

export type UpdateDeviceBodyProvision = {[key: string]: string};

export type UpdateDeviceBody = {
  /** username */
  account?: string;
  /** vendor brand name */
  brand?: string;
  createdAt?: string;
  createdBy?: ApiUserId;
  deletedAt?: string;
  deletedBy?: ApiUserId;
  /** act as a hotdesk */
  hotdesk?: boolean;
  hotdesks?: string[];
  ip?: string;
  loggedIn?: string;
  mac?: string;
  model?: string;
  /** display name */
  name?: string;
  password?: string;
  provision?: UpdateDeviceBodyProvision;
  reged?: boolean;
  updatedAt?: string;
  updatedBy?: ApiUserId;
  user?: ApiUserId;
};

export type ListRegistrationsParams = {
/**
 * Object ID
 */
userId?: string;
/**
 * Display Name
 */
userName?: string;
/**
 * Display Name
 */
deviceName?: string;
};

export type SearchDeviceAuditParams = {
/**
 * Object ID
 */
userId?: string;
/**
 * Display Name
 */
userName?: string;
/**
 * Display Name
 */
deviceName?: string;
/**
 * Filter: timing range (optional)

unix milliseconds
 */
timeFrom?: string;
/**
 * unix milliseconds
 */
timeTill?: string;
/**
 * Search Options
 */
fields?: string[];
sort?: string[];
size?: number;
page?: number;
};

export type DeleteDeviceParams = {
permanent?: boolean;
/**
 * bulk
 */
ids?: string[];
};

export type ReadDeviceParams = {
/**
 * output selection
 */
fields?: string[];
};

export type DeleteDataParams = {
/**
 * Fields to be retrieved into result dataset.
 */
fields?: string[];
/**
 * [`record.id`]
 */
id: string[];
};

export type SearchDataParams = {
/**
 * Number of result records (per page).
Default: 16.
 */
size?: number;
/**
 * Page number of result set of records.
Default: 1.
 */
page?: number;
/**
 * Sort result dataset of records by fields.
```
sort ::= *( ORDER name )

ORDER  = ASC / DESC
DESC   = "-" / "!"
ASC    = [ "+" ]   ; Default
```

Fields available

- `id`(seq)
- `domain`{name}
- `created_at`
- `created_by`{name}
- `updated_at`
- `updated_by`{name}

Use ?fields=`field.sort()` option to sort Edge fields.
 */
sort?: string[];
/**
 * Fields [Q]uery to build result dataset record.
```
fields ::= field [ *( "," field ) ]
field  ::= name [ *( func ) ] [ inner ]
inner  ::= "{" fields "}"
funcs  ::= *( func )
func   ::= "." name "(" [ args ] ")"
name   ::= ALPHA / DIGIT / USCORE

ALPHA    = %x41-5A / %x61-7A  ; "A"-"Z" / "a"-"z"
DIGIT    = %x30-39            ; "0"-"9"
USCORE   = %x5F ; underscore  ; "_"
```
 */
fields?: string[];
/**
 * Search term:
`?` - matches any character
`*` - matches 0 or more characters
e.g.: name,emails{type},labels etc...
 */
q?: string;
/**
 * [`record.id`]
 */
id?: string[];
/**
 * Filter string in CEL format.
 */
filters?: string;
};

export type CreateDataBody = { [key: string]: unknown };

export type CreateData200 = { [key: string]: unknown };

export type DeleteData2Params = {
/**
 * Fields to be retrieved into result dataset.
 */
fields?: string[];
};

export type LocateDataParams = {
/**
 * Fields [Q]uery to build result dataset record.
```
fields ::= field [ *( "," field ) ]
field  ::= name [ *( func ) ] [ inner ]
inner  ::= "{" fields "}"
funcs  ::= *( func )
func   ::= "." name "(" [ args ] ")"
name   ::= ALPHA / DIGIT / USCORE

ALPHA    = %x41-5A / %x61-7A  ; "A"-"Z" / "a"-"z"
DIGIT    = %x30-39            ; "0"-"9"
USCORE   = %x5F ; underscore  ; "_"
```
 */
fields?: string[];
};

export type LocateData200 = { [key: string]: unknown };

export type UpdateDataParams = {
/**
 * Source Fields to return into result.
 */
fields?: string[];
};

export type UpdateDataBody = { [key: string]: unknown };

export type UpdateData200 = { [key: string]: unknown };

export type UpdateData2Params = {
/**
 * Source Fields to return into result.
 */
fields?: string[];
};

export type UpdateData2Body = { [key: string]: unknown };

export type UpdateData2200 = { [key: string]: unknown };

export type DeleteDomainParams = {
domain?: string;
dc?: string;
};

export type ReadDomainParams = {
domain?: string;
dc?: string;
};

export type SearchDomainsParams = {
/**
 * like
 */
domain?: string;
/**
 * attrs
 */
fields?: string[];
sort?: string[];
page?: string;
size?: string;
};

export type DeleteDomain2Params = {
domain?: string;
};

export type ReadDomain2Params = {
domain?: string;
};

export type SearchEmailProfileParams = {
page?: number;
size?: number;
q?: string;
sort?: string;
fields?: string[];
};

export type GetFeedbackParams = {
key?: string;
};

export type CreateFeedbackParams = {
key?: string;
/**
 * This is a request variable of the map type. The query format is "map_name[key]=value", e.g. If the map name is Age, the key type is string, and the value type is integer, the query parameter is expressed as Age["bob"]=18
 */
payloadString?: string;
rating?: number;
description?: string;
};

export type SearchWebHookParams = {
page?: number;
size?: number;
q?: string;
sort?: string;
fields?: string[];
id?: number[];
};

export type SearchLDAPCatalogParams = {
/**
 * ----- Select Options -------------------------

default: 1
 */
page?: number;
/**
 * default: 16
 */
size?: number;
/**
 * attributes list
 */
fields?: string[];
/**
 * e.g.: "updated_at" - ASC; "!updated_at" - DESC;
 */
sort?: string[];
/**
 * ----- Search Basic Filters ---------------------------

selection: by unique identifier
 */
id?: string[];
/**
 * term-of-search: lookup[name]
 */
q?: string;
/**
 * case-ignore substring match: ILIKE '*' - any; '?' - one
 */
name?: string;
/**
 * [M]andatory[A]ccess[C]ontrol: with access mode (action) granted!
 */
access?: string;
};

export type LDAPSearch4Params = {
/**
 * ----- connection -----
Optional. ID of the preconfigured LDAP catalog
 */
catalogId?: string;
/**
 * Optional. URL to establish connection to LDAP catalog

URL e.g.: [(ldap|ldapi|ldaps)://]host[:port]
 */
url?: string;
/**
 * TODO: (!)

base64
 */
tlsPem?: string;
/**
 * ----- BIND: Authorization -----

authorization method e.g.: SIMPLE, SAML, NTLM, etc.
 */
bind?: string;
/**
 * bind_dn
 */
username?: string;
/**
 * password
 */
password?: string;
/**
 * ----- SearchRequest -----
baseObject [D]istinguished[N]ame
 */
baseObject?: string;
/**
 * baseObject              (0),
singleLevel             (1),
wholeSubtree            (2)
 */
scope?: number;
/**
 * neverDerefAliases       (0),
derefInSearching        (1),
derefFindingBaseObj     (2),
derefAlways             (3)
 */
derefAliases?: number;
/**
 * INTEGER (0 ..  maxInt),
 */
sizeLimit?: string;
/**
 * INTEGER (0 ..  maxInt),
 */
timeLimit?: string;
/**
 * BOOLEAN,
 */
typesOnly?: boolean;
/**
 * Filter,
 */
filter?: string;
/**
 * AttributeSelection
 */
attributes?: string[];
};

export type SearchLDAProcessParams = {
/**
 * ----- Select Options -------------------------

default: 1
 */
page?: number;
/**
 * default: 16
 */
size?: number;
/**
 * attributes list
 */
fields?: string[];
/**
 * e.g.: "updated_at" - ASC; "!updated_at" - DESC;
 */
sort?: string[];
/**
 * ----- Search Basic Filters ---------------------------
OPTIONAL. Search process by unique .id
 */
id?: string[];
/**
 * OPTIONAL. Filter(s) SET
 */
q?: string;
template?: string;
objclass?: string[];
/**
 * WITH .errs
 */
failed?: boolean;
/**
 * created|updated
 */
enabled?: boolean;
/**
 * deleted
 */
disabled?: boolean;
};

export type LocateLDAProcessParams = {
/**
 * ----- Select Options -------------------------

default: 1
 */
page?: number;
/**
 * default: 16
 */
size?: number;
/**
 * attributes list
 */
fields?: string[];
/**
 * e.g.: "updated_at" - ASC; "!updated_at" - DESC;
 */
sort?: string[];
/**
 * OPTIONAL. Filter(s) SET
 */
q?: string;
template?: string;
objclass?: string[];
/**
 * WITH .errs
 */
failed?: boolean;
/**
 * created|updated
 */
enabled?: boolean;
/**
 * deleted
 */
disabled?: boolean;
};

export type LDAPSearch2Params = {
/**
 * Optional. URL to establish connection to LDAP catalog

URL e.g.: [(ldap|ldapi|ldaps)://]host[:port]
 */
url?: string;
/**
 * TODO: (!)

base64
 */
tlsPem?: string;
/**
 * ----- BIND: Authorization -----

authorization method e.g.: SIMPLE, SAML, NTLM, etc.
 */
bind?: string;
/**
 * bind_dn
 */
username?: string;
/**
 * password
 */
password?: string;
/**
 * ----- SearchRequest -----
baseObject [D]istinguished[N]ame
 */
baseObject?: string;
/**
 * baseObject              (0),
singleLevel             (1),
wholeSubtree            (2)
 */
scope?: number;
/**
 * neverDerefAliases       (0),
derefInSearching        (1),
derefFindingBaseObj     (2),
derefAlways             (3)
 */
derefAliases?: number;
/**
 * INTEGER (0 ..  maxInt),
 */
sizeLimit?: string;
/**
 * INTEGER (0 ..  maxInt),
 */
timeLimit?: string;
/**
 * BOOLEAN,
 */
typesOnly?: boolean;
/**
 * Filter,
 */
filter?: string;
/**
 * AttributeSelection
 */
attributes?: string[];
};

export type SearchLDAPTemplateParams = {
/**
 * ----- Select Options -------------------------

default: 1
 */
page?: number;
/**
 * default: 16
 */
size?: number;
/**
 * attributes list
 */
fields?: string[];
/**
 * e.g.: "updated_at" - ASC; "!updated_at" - DESC;
 */
sort?: string[];
/**
 * ----- Search Basic Filters ---------------------------
OPTIONAL. Search templates by .id
 */
id?: string[];
/**
 * OPTIONAL. Filter(s) SET
 */
q?: string;
name?: string;
baseDn?: string;
objclass?: string;
enabled?: boolean;
disabled?: boolean;
};

export type LocateLDAPTemplateParams = {
/**
 * ----- Select Options -------------------------

default: 1
 */
page?: number;
/**
 * default: 16
 */
size?: number;
/**
 * attributes list
 */
fields?: string[];
/**
 * e.g.: "updated_at" - ASC; "!updated_at" - DESC;
 */
sort?: string[];
/**
 * OPTIONAL. Filter(s) SET
 */
q?: string;
name?: string;
baseDn?: string;
objclass?: string;
enabled?: boolean;
disabled?: boolean;
};

export type DeleteLDAPCatalogParams = {
/**
 * WITH objects bound to ?
 */
relatedObjects?: boolean;
};

export type LocateLDAPCatalogParams = {
/**
 * ----- Select Options -------------------------

default: 1
 */
page?: number;
/**
 * default: 16
 */
size?: number;
/**
 * attributes list
 */
fields?: string[];
/**
 * e.g.: "updated_at" - ASC; "!updated_at" - DESC;
 */
sort?: string[];
/**
 * term-of-search: lookup[name]
 */
q?: string;
/**
 * case-ignore substring match: ILIKE '*' - any; '?' - one
 */
name?: string;
/**
 * [M]andatory[A]ccess[C]ontrol: with access mode (action) granted!
 */
access?: string;
};

export type LicenseUsage2Params = {
/**
 * ----- Search Options ----- //

default: 16
 */
size?: number;
/**
 * default: 1
 */
page?: number;
/**
 * set of output fields
 */
fields?: string[];
/**
 * e.g.: "updated_at" - ASC; "!updated_at" - DESC;
 */
sort?: string[];
/**
 * identifier
 */
userId?: string;
/**
 * display name
 */
userName?: string;
/**
 * identifier
 */
domainId?: string;
/**
 * display name
 */
domainName?: string;
customerId?: string;
/**
 * by serial number(s)
 */
id?: string[];
/**
 * by product name(s)
 */
product?: string[];
/**
 * view: all|valid|grantable

show: available to be granted
 */
valid?: boolean;
/**
 * filter: term of search
 */
q?: string;
};

export type ConfigServiceReadSystemObjectsParams = {
includeExisting?: boolean;
page?: number;
size?: number;
q?: string;
sort?: string;
fields?: string[];
};

export type ConfigServiceSearchConfigParams = {
page?: number;
size?: number;
q?: string;
sort?: string;
fields?: string[];
/**
 * NOT USED
 */
object?: ConfigServiceSearchConfigObjectItem[];
};

export type ConfigServiceSearchConfigObjectItem = typeof ConfigServiceSearchConfigObjectItem[keyof typeof ConfigServiceSearchConfigObjectItem];


export const ConfigServiceSearchConfigObjectItem = {
  CcQueue: 'cc_queue',
  Schema: 'schema',
  Users: 'users',
  Devices: 'devices',
  Calendars: 'calendars',
  CcList: 'cc_list',
  CcTeam: 'cc_team',
  CcAgent: 'cc_agent',
  CcResource: 'cc_resource',
  CcResourceGroup: 'cc_resource_group',
  ChatBots: 'chat_bots',
  Cases: 'cases',
  Contacts: 'contacts',
  CcListNumber: 'cc_list_number',
  CaseComments: 'case_comments',
  RecordFile: 'record_file',
} as const;

export type ConfigServicePatchConfigBody = {
  daysToStore?: number;
  description?: string;
  enabled?: boolean;
  fields?: string[];
  period?: number;
  storage?: LoggerLookup;
};

export type ConfigServiceUpdateConfigBody = {
  daysToStore?: number;
  description?: string;
  enabled?: boolean;
  period?: number;
  storage?: LoggerLookup;
};

export type LoggerServiceSearchLogByConfigIdParams = {
page?: number;
size?: number;
q?: string;
sort?: string;
fields?: string[];
userId?: string[];
action?: LoggerServiceSearchLogByConfigIdActionItem[];
userIp?: string;
dateFrom?: string;
dateTo?: string;
};

export type LoggerServiceSearchLogByConfigIdActionItem = typeof LoggerServiceSearchLogByConfigIdActionItem[keyof typeof LoggerServiceSearchLogByConfigIdActionItem];


export const LoggerServiceSearchLogByConfigIdActionItem = {
  DefaultNoAction: 'default_no_action',
  Create: 'create',
  Update: 'update',
  Read: 'read',
  Delete: 'delete',
} as const;

export type LoggerServiceSearchLogByUserIdParams = {
page?: number;
size?: number;
q?: string;
sort?: string;
fields?: string[];
/**
 * SPECIFIC filter
 */
objectId?: string[];
/**
 * GENERAL filters
 */
action?: LoggerServiceSearchLogByUserIdActionItem[];
userIp?: string;
dateFrom?: string;
dateTo?: string;
};

export type LoggerServiceSearchLogByUserIdActionItem = typeof LoggerServiceSearchLogByUserIdActionItem[keyof typeof LoggerServiceSearchLogByUserIdActionItem];


export const LoggerServiceSearchLogByUserIdActionItem = {
  DefaultNoAction: 'default_no_action',
  Create: 'create',
  Update: 'update',
  Read: 'read',
  Delete: 'delete',
} as const;

export type LoggerServiceSearchLogByRecordIdParams = {
page?: number;
size?: number;
q?: string;
sort?: string;
fields?: string[];
/**
 * GENERAL filters
 */
action?: LoggerServiceSearchLogByRecordIdActionItem[];
userId?: string[];
userIp?: string;
dateFrom?: string;
dateTo?: string;
};

export type LoggerServiceSearchLogByRecordIdActionItem = typeof LoggerServiceSearchLogByRecordIdActionItem[keyof typeof LoggerServiceSearchLogByRecordIdActionItem];


export const LoggerServiceSearchLogByRecordIdActionItem = {
  DefaultNoAction: 'default_no_action',
  Create: 'create',
  Update: 'update',
  Read: 'read',
  Delete: 'delete',
} as const;

export type SearchOAuthServiceParams = {
/**
 * ----- Select Options -------------------------

default: 1
 */
page?: number;
/**
 * default: 16
 */
size?: number;
/**
 * attributes list
 */
fields?: string[];
/**
 * e.g.: "updated_at" - ASC; "!updated_at" - DESC;
 */
sort?: string[];
/**
 * ----- Search Basic Filters ---------------------------

selection: by unique identifier
 */
id?: string[];
/**
 * term-of-search: lookup[name]
 */
q?: string;
/**
 * case-ignore substring match: ILIKE '*' - any; '?' - one
 */
name?: string;
/**
 * [M]andatory[A]ccess[C]ontrol: with access mode (action) granted!
 */
access?: string;
/**
 * ----- OAuthService-Specific Filters ----------------
 */
enabled?: boolean;
};

export type LocateOAuthServiceParams = {
/**
 * ----- Select Options -------------------------

default: 1
 */
page?: number;
/**
 * default: 16
 */
size?: number;
/**
 * attributes list
 */
fields?: string[];
/**
 * e.g.: "updated_at" - ASC; "!updated_at" - DESC;
 */
sort?: string[];
/**
 * term-of-search: lookup[name]
 */
q?: string;
/**
 * case-ignore substring match: ILIKE '*' - any; '?' - one
 */
name?: string;
/**
 * [M]andatory[A]ccess[C]ontrol: with access mode (action) granted!
 */
access?: string;
/**
 * ----- OAuthService-Specific Filters ----------------
 */
enabled?: boolean;
};

export type SearchClassesParams = {
/**
 * TO BE REMOVED // bound to session.domain.id
 */
domain?: string;
/**
 * [filter]: like '%class%'
 */
class?: string;
/**
 * int64 id = 3;  // [filter]: obj.id = id
controls

output
 */
fields?: string[];
/**
 * sort: "field" asc; "!field" desc
 */
sort?: string[];
/**
 * page number
 */
page?: number;
/**
 * page size
 */
size?: number;
};

export type ReadClassParams = {
domain?: string;
/**
 * [filter]: like '%class%'
 */
class?: string;
};

export type GetPermissionsParams = {
/**
 * TermOfSearch
 */
q?: string;
/**
 * = ANY(id)
 */
id?: string[];
/**
 * <> ANY(not)
 */
not?: string[];
/**
 * controls

output
 */
fields?: string[];
/**
 * sort: "field" asc; "!field" desc
 */
sort?: string[];
/**
 * page number
 */
page?: number;
/**
 * page size
 */
size?: number;
};

export type LicenseUsage3Params = {
/**
 * ----- Search Options ----- //

default: 16
 */
size?: number;
/**
 * default: 1
 */
page?: number;
/**
 * set of output fields
 */
fields?: string[];
/**
 * e.g.: "updated_at" - ASC; "!updated_at" - DESC;
 */
sort?: string[];
/**
 * identifier
 */
userId?: string;
/**
 * display name
 */
userName?: string;
/**
 * identifier
 */
domainId?: string;
/**
 * display name
 */
domainName?: string;
customerId?: string;
/**
 * by serial number(s)
 */
id?: string[];
/**
 * by product name(s)
 */
product?: string[];
/**
 * view: all|valid|grantable

show: available to be granted
 */
valid?: boolean;
/**
 * filter: term of search
 */
q?: string;
};

export type LicenseUsersParams = {
/**
 * ----- Search Options ----- //

default: 16
 */
size?: number;
/**
 * default: 1
 */
page?: number;
/**
 * set of output fields
 */
fields?: string[];
/**
 * e.g.: "updated_at" - ASC; "!updated_at" - DESC;
 */
sort?: string[];
/**
 * filter: term of search (username)
 */
q?: string;
};

export type SearchRegionParams = {
page?: number;
size?: number;
q?: string;
sort?: string;
fields?: string[];
id?: string[];
name?: string;
description?: string;
timezoneId?: number[];
};

export type SearchRoutingOutboundCallParams = {
page?: number;
size?: number;
q?: string;
sort?: string;
fields?: string[];
id?: number[];
name?: string;
schemaId?: number[];
pattern?: string;
description?: string;
};

export type DeleteRoutingOutboundCallParams = {
domainId?: string;
};

export type ReadRoutingOutboundCallParams = {
domainId?: string;
};

export type SearchChatPlanParams = {
page?: number;
size?: number;
q?: string;
sort?: string;
fields?: string[];
id?: number[];
name?: string;
enabled?: boolean;
};

export type SearchRoutingSchemaParams = {
page?: number;
size?: number;
q?: string;
sort?: string;
fields?: string[];
id?: number[];
name?: string;
type?: SearchRoutingSchemaTypeItem[];
editor?: boolean;
tags?: string[];
};

export type SearchRoutingSchemaTypeItem = typeof SearchRoutingSchemaTypeItem[keyof typeof SearchRoutingSchemaTypeItem];


export const SearchRoutingSchemaTypeItem = {
  Default: 'default',
  Voice: 'voice',
  Chat: 'chat',
  Processing: 'processing',
  Service: 'service',
} as const;

export type SearchRoutingSchemaTagsParams = {
page?: number;
size?: number;
q?: string;
sort?: string;
fields?: string[];
type?: SearchRoutingSchemaTagsTypeItem[];
};

export type SearchRoutingSchemaTagsTypeItem = typeof SearchRoutingSchemaTagsTypeItem[keyof typeof SearchRoutingSchemaTagsTypeItem];


export const SearchRoutingSchemaTagsTypeItem = {
  Default: 'default',
  Voice: 'voice',
  Chat: 'chat',
  Processing: 'processing',
  Service: 'service',
} as const;

export type SearchSchemaVariableParams = {
page?: number;
size?: number;
q?: string;
sort?: string;
fields?: string[];
};

export type DeleteRoutingSchemaParams = {
domainId?: string;
};

export type ReadRoutingSchemaParams = {
domainId?: string;
};

export type SearchSchemaVersionParams = {
page?: number;
size?: number;
q?: string;
sort?: string;
fields?: string[];
};

export type SearchRoutingVariableParams = {
page?: number;
size?: number;
domainId?: string;
};

export type DeleteRoutingVariableParams = {
domainId?: string;
};

export type ReadRoutingVariableParams = {
domainId?: string;
};

export type SearchParams = {
page?: number;
size?: number;
q?: string;
sort?: string;
fields?: string[];
objectName?: string[];
};

export type SearchSystemSettingParams = {
page?: number;
size?: number;
q?: string;
sort?: string;
fields?: string[];
/**
 * Filter by setting names
 */
name?: SearchSystemSettingNameItem[];
};

export type SearchSystemSettingNameItem = typeof SearchSystemSettingNameItem[keyof typeof SearchSystemSettingNameItem];


export const SearchSystemSettingNameItem = {
  EmptySystemSettingsName: 'empty_system_settings_name',
  EnableOmnichannel: 'enable_omnichannel',
  MemberChunkSize: 'member_chunk_size',
  AmdCancelNotHuman: 'amd_cancel_not_human',
  SchemeVersionLimit: 'scheme_version_limit',
  Enable2fa: 'enable_2fa',
  ExportSettings: 'export_settings',
  SearchNumberLength: 'search_number_length',
  ChatAiConnection: 'chat_ai_connection',
  PasswordRegExp: 'password_reg_exp',
  PasswordValidationText: 'password_validation_text',
  AutolinkCallToContact: 'autolink_call_to_contact',
  PeriodToPlaybackRecords: 'period_to_playback_records',
  IsFulltextSearchEnabled: 'is_fulltext_search_enabled',
  WbtHideContact: 'wbt_hide_contact',
  ShowFullContact: 'show_full_contact',
  CallEndSoundNotification: 'call_end_sound_notification',
  CallEndPushNotification: 'call_end_push_notification',
  ChatEndSoundNotification: 'chat_end_sound_notification',
  ChatEndPushNotification: 'chat_end_push_notification',
  TaskEndSoundNotification: 'task_end_sound_notification',
  TaskEndPushNotification: 'task_end_push_notification',
  PushNotificationTimeout: 'push_notification_timeout',
  LabelsToLimitContacts: 'labels_to_limit_contacts',
  AutolinkMailToContact: 'autolink_mail_to_contact',
  NewMessageSoundNotification: 'new_message_sound_notification',
  NewChatSoundNotification: 'new_chat_sound_notification',
  ScreenshotInterval: 'screenshot_interval',
  PasswordExpiryDays: 'password_expiry_days',
  PasswordMinLength: 'password_min_length',
  PasswordCategories: 'password_categories',
  PasswordContainsLogin: 'password_contains_login',
  PasswordWarningDays: 'password_warning_days',
  DefaultPassword: 'default_password',
} as const;

export type SearchAvailableSystemSettingParams = {
page?: number;
size?: number;
q?: string;
sort?: string;
fields?: string[];
};

export type SignupParams = {
/**
 * domain name
 */
domain?: string;
/**
 * username
 */
username?: string;
/**
 * user password
 */
password?: string;
/**
 * scope request control
 */
scope?: string[];
/**
 * license/certificate
 */
certificate?: string;
/**
 * OPTIONAL. Mobile device /login request ?
 */
mobile?: boolean;
};

export type CreateSLAConditionParams = {
fields?: string[];
};

export type LocateSLAConditionParams = {
/**
 * Fields to be retrieved as a result.
 */
fields?: string[];
};

export type UpdateSLACondition2Params = {
fields?: string[];
};

export type UpdateSLAConditionParams = {
fields?: string[];
};

export type ListSLAConditionsParams = {
/**
 * Page number of result dataset records. offset = (page*size)
 */
page?: number;
/**
 * Size count of records on result page. limit = (size++)
 */
size?: number;
/**
 * Fields to be retrieved as a result.
 */
fields?: string[];
/**
 * Sort the result according to fields.
 */
sort?: string;
/**
 * Filter by unique IDs.
 */
id?: string[];
/**
 * Search query string for filtering by name. Supports:
- Wildcards (*) for substring matching
- Placeholder (?) for single character substitution
- Exact match for full names
 */
q?: string;
/**
 * Filter by SLACondition Id.
 */
slaConditionId?: string;
/**
 * filter by priority id
 */
priorityId?: string;
};

export type ListSpacesParams = {
page?: number;
/**
 * Limit of result page records count.   _default(16); limit=(size<=0?-1:size+1);_

```javascript
const
    default = 16
  , maximum = 32
;

```
 */
size?: number;
/**
 * Search term:
`?` - matches any character
`*` - matches 0 or more characters
Used to query records within a set of `qin` fields, eg: name, etc...
 */
q?: string;
/**
 * Sort result dataset of records by fields.
```
sort ::= *( ORDER name )

ORDER  = ASC / DESC
DESC   = "-" / "!"
ASC    = [ "+" ]   ; Default
```

Fields available

- `id`(seq)
- `domain`{name}
- `state`
 */
sort?: string[];
fields?: string[];
/**
 * Records with unique IDentifier(s).
Accept: `id` -or- `etag`.
 */
id?: string[];
};

export type CreateSpaceParams = {
/**
 * Source Fields to return into result.
 */
fields?: string[];
};

export type SpacesArticlesSearchParams = {
/**
 * Size count of records on result page. limit = (size++)
 */
size?: number;
/**
 * Page number of result dataset records. offset = (page*size)
 */
page?: number;
/**
 * Sort the result according to fields.
 */
sort?: string[];
/**
 * Search term: location name;
`?` - matches any one character
`*` - matches 0 or more characters
 */
q?: string;
/**
 * Active Article only.
 */
state?: boolean;
/**
 * Tags associated with the article.
 */
tags?: string[];
};

export type ListTagsParams = {
page?: number;
size?: number;
};

export type DeleteSpaceParams = {
/**
 * Fields to be retrieved into result of changes.
 */
fields?: string[];
};

export type LocateSpaceParams = {
/**
 * Source Fields to return into result.
 */
fields?: string[];
};

export type UpdateSpaceParams = {
/**
 * Source Fields to return into result.
 */
fields?: string[];
};

export type UpdateSpaceBody = {
  /** BIO. Short description about the space.
OPTIONAL. Multi-lined text. */
  homePage?: string;
  /** Represents the name of the knowledge base space. */
  name?: string;
  /** The state of the space. */
  state?: boolean;
};

export type ListArticlesParams = {
/**
 * Page number of result dataset records. offset = (page*size)
 */
page?: number;
/**
 * Size count of records on result page. limit = (size++)
 */
size?: number;
/**
 * Sort the result according to fields.
 */
sort?: string[];
/**
 * Fields to be retrieved as a result.
 */
fields?: string[];
/**
 * Search term: location name;
`?` - matches any one character
`*` - matches 0 or more characters
 */
q?: string;
/**
 * Record(s) with unique ID only.
 */
articleId?: string;
/**
 * Active Article only.
 */
state?: boolean;
/**
 * Tags associated with the article.
 */
tags?: string[];
};

export type CreateArticleParams = {
/**
 * Fields to be retrieved into result of changes.
 */
fields?: string[];
};

export type ArticlesAttachmentListParams = {
/**
 * Page number of result dataset records. offset = (page*size)
 */
page?: number;
/**
 * Size count of records on result page. limit = (size++)
 */
size?: number;
/**
 * Sort the result according to fields.
 */
sort?: string[];
};

export type ListArticles2Params = {
/**
 * Page number of result dataset records. offset = (page*size)
 */
page?: number;
/**
 * Size count of records on result page. limit = (size++)
 */
size?: number;
/**
 * Sort the result according to fields.
 */
sort?: string[];
/**
 * Fields to be retrieved as a result.
 */
fields?: string[];
/**
 * Search term: location name;
`?` - matches any one character
`*` - matches 0 or more characters
 */
q?: string;
/**
 * Active Article only.
 */
state?: boolean;
/**
 * Tags associated with the article.
 */
tags?: string[];
};

export type ArticleVersionsListParams = {
/**
 * Page number of result dataset records. offset = (page*size)
 */
page?: number;
/**
 * Size count of records on result page. limit = (size++)
 */
size?: number;
/**
 * Sort the result according to fields.
 */
sort?: string[];
};

export type DeleteArticleParams = {
/**
 * Fields to be retrieved as a result.
 */
fields?: string[];
};

export type LocateArticleParams = {
/**
 * Fields to be retrieved into result.
 */
fields?: string[];
};

export type UpdateArticleParams = {
/**
 * Fields to be retrieved into result of changes.
 */
fields?: string[];
};

export type UpdateArticleBody = {
  /** Tags associated with the article. */
  tags?: string[];
  /** The parent article ID. */
  parentArticle?: string;
  /** Indicates that the article is pinned on the top of list. */
  pinned?: boolean;
  /** [VALUE]: --------------------------------------
Space ID associated with. */
  spaceId?: string;
  /** Indicates if article is active and actual. */
  state?: boolean;
  /** The text content of the article. */
  text?: string;
  /** The title of the article. */
  title?: string;
};

export type ListStatusConditionsParams = {
/**
 * Page number of result dataset records. offset = (page*size)
 */
page?: number;
/**
 * Size count of records on result page. limit = (size++)
 */
size?: number;
/**
 * Fields to be retrieved as a result.
 */
fields?: string[];
/**
 * Sort the result according to fields.
 */
sort?: string;
/**
 * Filter by unique IDs.
 */
id?: string[];
/**
 * Search query string for filtering by name. Supports:
- Wildcards (*) for substring matching
- Placeholder (?) for single character substitution
- Exact match for full names
 */
q?: string;
};

export type CreateStatusConditionParams = {
fields?: string[];
};

export type LocateStatusConditionParams = {
/**
 * Fields to be retrieved as a result.
 */
fields?: string[];
};

export type UpdateStatusCondition2Params = {
fields?: string[];
};

export type UpdateStatusConditionParams = {
fields?: string[];
};

export type SearchScreenRecordingsByAgentParams = {
page?: number;
size?: number;
q?: string;
sort?: string;
fields?: string[];
id?: string[];
uploadedAtFrom?: string;
uploadedAtTo?: string;
referenceId?: string[];
retentionUntilFrom?: string;
retentionUntilTo?: string;
type?: SearchScreenRecordingsByAgentType;
channel?: SearchScreenRecordingsByAgentChannel;
};

export type SearchScreenRecordingsByAgentType = typeof SearchScreenRecordingsByAgentType[keyof typeof SearchScreenRecordingsByAgentType];


export const SearchScreenRecordingsByAgentType = {
  Pdf: 'PDF',
  Screenshot: 'SCREENSHOT',
  Screensharing: 'SCREENSHARING',
} as const;

export type SearchScreenRecordingsByAgentChannel = typeof SearchScreenRecordingsByAgentChannel[keyof typeof SearchScreenRecordingsByAgentChannel];


export const SearchScreenRecordingsByAgentChannel = {
  Screenrecording: 'SCREENRECORDING',
  Call: 'CALL',
} as const;

export type SearchBackendProfileParams = {
page?: number;
size?: number;
q?: string;
sort?: string;
fields?: string[];
id?: number[];
};

export type DeleteBackendProfileParams = {
domainId?: string;
};

export type ReadBackendProfileParams = {
domainId?: string;
};

export type SearchCognitiveProfileParams = {
page?: number;
size?: number;
q?: string;
sort?: string;
fields?: string[];
id?: string[];
service?: SearchCognitiveProfileServiceItem[];
enabled?: boolean;
};

export type SearchCognitiveProfileServiceItem = typeof SearchCognitiveProfileServiceItem[keyof typeof SearchCognitiveProfileServiceItem];


export const SearchCognitiveProfileServiceItem = {
  DefaultService: 'DefaultService',
  Stt: 'STT',
  Tts: 'TTS',
} as const;

export type SearchCognitiveProfileVoicesParams = {
q?: string;
key?: string;
};

export type SearchFilesParams = {
page?: number;
size?: number;
q?: string;
sort?: string;
fields?: string[];
id?: string[];
uploadedAtFrom?: string;
uploadedAtTo?: string;
uploadedBy?: string[];
referenceId?: string[];
/**
 *  - ScreenRecordingChannel: ScreenshotChannel = 8; // deprecated
 */
channel?: SearchFilesChannelItem[];
retentionUntilFrom?: string;
retentionUntilTo?: string;
};

export type SearchFilesChannelItem = typeof SearchFilesChannelItem[keyof typeof SearchFilesChannelItem];


export const SearchFilesChannelItem = {
  UnknownChannel: 'UnknownChannel',
  ChatChannel: 'ChatChannel',
  MailChannel: 'MailChannel',
  CallChannel: 'CallChannel',
  LogChannel: 'LogChannel',
  MediaChannel: 'MediaChannel',
  KnowledgebaseChannel: 'KnowledgebaseChannel',
  CasesChannel: 'CasesChannel',
  ScreenRecordingChannel: 'ScreenRecordingChannel',
} as const;

export type SearchFilePoliciesParams = {
page?: number;
size?: number;
q?: string;
sort?: string;
fields?: string[];
id?: number[];
};

export type SearchImportTemplateParams = {
page?: number;
size?: number;
q?: string;
sort?: string;
fields?: string[];
id?: number[];
};

export type SearchMediaFileParams = {
page?: number;
size?: number;
q?: string;
sort?: string;
fields?: string[];
id?: number[];
};

export type DeleteMediaFileParams = {
domainId?: string;
};

export type ReadMediaFileParams = {
domainId?: string;
};

export type GetFileTranscriptPhrasesParams = {
page?: number;
size?: number;
};

export type SearchScreenRecordingsParams = {
page?: number;
size?: number;
q?: string;
sort?: string;
fields?: string[];
id?: string[];
uploadedAtFrom?: string;
uploadedAtTo?: string;
referenceId?: string[];
retentionUntilFrom?: string;
retentionUntilTo?: string;
type?: SearchScreenRecordingsType;
channel?: SearchScreenRecordingsChannel;
};

export type SearchScreenRecordingsType = typeof SearchScreenRecordingsType[keyof typeof SearchScreenRecordingsType];


export const SearchScreenRecordingsType = {
  Pdf: 'PDF',
  Screenshot: 'SCREENSHOT',
  Screensharing: 'SCREENSHARING',
} as const;

export type SearchScreenRecordingsChannel = typeof SearchScreenRecordingsChannel[keyof typeof SearchScreenRecordingsChannel];


export const SearchScreenRecordingsChannel = {
  Screenrecording: 'SCREENRECORDING',
  Call: 'CALL',
} as const;

export type SearchTriggerParams = {
page?: number;
size?: number;
q?: string;
sort?: string;
fields?: string[];
id?: number[];
schemaId?: number[];
};

export type SearchTriggerJobParams = {
page?: number;
size?: number;
q?: string;
sort?: string;
fields?: string[];
createdAtFrom?: string;
createdAtTo?: string;
startedAtFrom?: string;
startedAtTo?: string;
durationFrom?: string;
durationTo?: string;
state?: SearchTriggerJobStateItem[];
};

export type SearchTriggerJobStateItem = typeof SearchTriggerJobStateItem[keyof typeof SearchTriggerJobStateItem];


export const SearchTriggerJobStateItem = {
  Idle: 'idle',
  Active: 'active',
  Done: 'done',
  Error: 'error',
} as const;

export type SearchTypesParams = {
/**
 * Search term:
`?` - matches any character
`*` - matches 0 or more characters
e.g.: name,emails{type},labels etc...
 */
q?: string;
/**
 * `types.id`
 */
id?: string;
/**
 * `types.name`
 */
name?: string;
/**
 * `types.repo`
 */
repo?: string;
/**
 * `types.path`
 */
path?: string;
/**
 * [NOT] [ system / custom ] types only
 */
readonly?: boolean;
/**
 * [NOT] Extend[able] types only.
 */
extendable?: boolean;
/**
 * [NOT] include extensions/* types.
 */
extensions?: boolean;
/**
 * [NOT] Extend[ed] types only.
 */
extended?: boolean;
/**
 * [NOT] Administer access control only
 */
administered?: boolean;
/**
 * Number of result records (per page).
Default: 16.
 */
size?: number;
/**
 * Page number of result set of records.
Default: 1.
 */
page?: number;
/**
 * Sort result dataset of records by fields.
```
sort ::= *( ORDER name )

ORDER  = ASC / DESC
DESC   = "-" / "!"
ASC    = [ "+" ]   ; Default
```

Fields available

- `id`(seq)
- `domain`{name}
- `created_at`
- `created_by`{name}
- `updated_at`
- `updated_by`{name}

Use ?fields=`field.sort()` option to sort Edge fields.
 */
sort?: string[];
/**
 * Fields [Q]uery to build result dataset record.
```
fields ::= field [ *( "," field ) ]
field  ::= name [ *( func ) ] [ inner ]
inner  ::= "{" fields "}"
funcs  ::= *( func )
func   ::= "." name "(" [ args ] ")"
name   ::= ALPHA / DIGIT / USCORE

ALPHA    = %x41-5A / %x61-7A  ; "A"-"Z" / "a"-"z"
DIGIT    = %x30-39            ; "0"-"9"
USCORE   = %x5F ; underscore  ; "_"
```
 */
fields?: string[];
};

export type DeleteTypeParams = {
/**
 * Fields to retrive into result dataset.
 */
fields?: string[];
/**
 * `types.repo`

// `record.pk`
 repeated string id = 3;
 */
repo: string[];
};

export type SearchTypeParams = {
/**
 * Search term:
`?` - matches any character
`*` - matches 0 or more characters
e.g.: name,emails{type},labels etc...
 */
q?: string;
/**
 * `types.id`
 */
id?: string;
/**
 * `types.name`
 */
name?: string;
/**
 * `types.repo`
 */
repo?: string;
/**
 * `types.path`
 */
path?: string;
/**
 * [NOT] [ system / custom ] types only
 */
readonly?: boolean;
/**
 * [NOT] Extend[able] types only.
 */
extendable?: boolean;
/**
 * [NOT] include extensions/* types.
 */
extensions?: boolean;
/**
 * [NOT] Extend[ed] types only.
 */
extended?: boolean;
/**
 * [NOT] Administer access control only
 */
administered?: boolean;
/**
 * Number of result records (per page).
Default: 16.
 */
size?: number;
/**
 * Page number of result set of records.
Default: 1.
 */
page?: number;
/**
 * Sort result dataset of records by fields.
```
sort ::= *( ORDER name )

ORDER  = ASC / DESC
DESC   = "-" / "!"
ASC    = [ "+" ]   ; Default
```

Fields available

- `id`(seq)
- `domain`{name}
- `created_at`
- `created_by`{name}
- `updated_at`
- `updated_by`{name}

Use ?fields=`field.sort()` option to sort Edge fields.
 */
sort?: string[];
/**
 * Fields [Q]uery to build result dataset record.
```
fields ::= field [ *( "," field ) ]
field  ::= name [ *( func ) ] [ inner ]
inner  ::= "{" fields "}"
funcs  ::= *( func )
func   ::= "." name "(" [ args ] ")"
name   ::= ALPHA / DIGIT / USCORE

ALPHA    = %x41-5A / %x61-7A  ; "A"-"Z" / "a"-"z"
DIGIT    = %x30-39            ; "0"-"9"
USCORE   = %x5F ; underscore  ; "_"
```
 */
fields?: string[];
};

export type UpdateTypeParams = {
/**
 * Fields to return into result.
 */
fields?: string[];
};

export type DeleteType2Params = {
fields?: string[];
/**
 * `type.repo`
 */
repo?: string[];
};

export type SearchTypeExtensionsParams = {
/**
 * Number of result records (per page).
Default: 16.
 */
size?: number;
/**
 * Page number of result set of records.
Default: 1.
 */
page?: number;
/**
 * Sort result dataset of records by fields.
```
sort ::= *( ORDER name )

ORDER  = ASC / DESC
DESC   = "-" / "!"
ASC    = [ "+" ]   ; Default
```

Fields available

- `id`(seq)
- `domain`{name}
- `created_at`
- `created_by`{name}
- `updated_at`
- `updated_by`{name}

Use ?fields=`field.sort()` option to sort Edge fields.
 */
sort?: string[];
/**
 * Fields [Q]uery to build result dataset record.
```
fields ::= field [ *( "," field ) ]
field  ::= name [ *( func ) ] [ inner ]
inner  ::= "{" fields "}"
funcs  ::= *( func )
func   ::= "." name "(" [ args ] ")"
name   ::= ALPHA / DIGIT / USCORE

ALPHA    = %x41-5A / %x61-7A  ; "A"-"Z" / "a"-"z"
DIGIT    = %x30-39            ; "0"-"9"
USCORE   = %x5F ; underscore  ; "_"
```
 */
fields?: string[];
/**
 * Search term:
`?` - matches any character
`*` - matches 0 or more characters
e.g.: name,emails{type},labels etc...
 */
q?: string;
/**
 * extension.type.id
 */
id?: string[];
};

export type DeleteTypeExtensionsParams = {
fields?: string[];
};

export type ReadUser2Params = {
id?: string;
/**
 * partial output
 */
fields?: string[];
};

export type ActivityWorkspaceWidgetParams = {
fields?: string[];
};

export type OpenedWebSocketsParams = {
page?: number;
size?: number;
q?: string;
sort?: string;
fields?: string[];
};

export type UserInfo2Params = {
/**
 * string id_token = 2;
 */
accessToken?: string;
};

export type UserInfoParams = {
/**
 * string id_token = 2;
 */
accessToken?: string;
};

export type DeleteUsers2Params = {
/**
 * ONE /users/{id}
 */
id?: string;
permanent?: boolean;
};

export type SearchUsersParams = {
/**
 * ----- Base Filters ---------------------------

filter: .id = any({id}...)
 */
id?: string[];
/**
 * filter: .id <> all({not_ids}...)
 */
notId?: string[];
/**
 * ----- User-specific Filters ------------------

filter: (.name|.username|.extension|.status) ILIKE '{q}'
 */
q?: string;
/**
 * filter: .name ILIKE '{name}'
 */
name?: string;
/**
 * filter: .status ILIKE '{status}'
 */
status?: string;
/**
 * filter: .username ILIKE '{username}'
 */
username?: string;
/**
 * filter: .extension LIKE '{extension}'
 */
extension?: string;
/**
 * ----- View Modes -----------------------------
NOTE: by default, search NOT 'deleted' objects ONLY

filter: include 'deleted' ALSO ! (inactive)
 */
any?: boolean;
/**
 * filter: .deleted_at NOTNULL (view: RECYCLE)
 */
deleted?: boolean;
presenceStatus?: string;
presenceNote?: string;
/**
 * // navigation filter
repeated int64 roles = 7;
----- Search Options -------------------------

select: output (fields,...)
 */
fields?: string[];
/**
 * select: order by (fields,...)
 */
sort?: string[];
/**
 * select: offset {page}
 */
page?: number;
/**
 * select: limit {size}
 */
size?: number;
};

export type ReadPasswordSettingsParams = {
password?: string;
username?: string;
domain?: string;
};

export type DeleteUsersParams = {
/**
 * MANY /users .ids=[id,...]
 */
selection?: string[];
permanent?: boolean;
};

export type ReadUserParams = {
/**
 * partial output
 */
fields?: string[];
};

export type AddUserAccessTokenParams = {
/**
 * ObjectId user = 1; // [required]
 string usage = 2;  // [optional] usage description
 bool enable = 3;
 */
enable?: boolean;
};

export type AddUserAccessTokenBodyUser = {
  name?: string;
};

export type AddUserAccessTokenBody = {
  createdAt?: string;
  createdBy?: ApiObjectId;
  deletedAt?: string;
  deletedBy?: ApiObjectId;
  id?: string;
  token?: string;
  updatedAt?: string;
  updatedBy?: ApiObjectId;
  usage?: string;
  user?: AddUserAccessTokenBodyUser;
};

export type UpdateUserAccessToken2Params = {
/**
 * [optional] PATCH implementation
 */
fields?: string[];
enable?: boolean;
};

export type UpdateUserAccessToken2BodyUser = {
  name?: string;
};

export type UpdateUserAccessToken2Body = {
  createdAt?: string;
  createdBy?: ApiObjectId;
  deletedAt?: string;
  deletedBy?: ApiObjectId;
  token?: string;
  updatedAt?: string;
  updatedBy?: ApiObjectId;
  usage?: string;
  user?: UpdateUserAccessToken2BodyUser;
};

export type UpdateUserAccessTokenParams = {
/**
 * [optional] PATCH implementation
 */
fields?: string[];
enable?: boolean;
};

export type UpdateUserAccessTokenBodyUser = {
  name?: string;
};

export type UpdateUserAccessTokenBody = {
  createdAt?: string;
  createdBy?: ApiObjectId;
  deletedAt?: string;
  deletedBy?: ApiObjectId;
  token?: string;
  updatedAt?: string;
  updatedBy?: ApiObjectId;
  usage?: string;
  user?: UpdateUserAccessTokenBodyUser;
};

export type UpdateUser2Params = {
/**
 * PATCH: partial update
 */
fields?: string[];
};

export type UpdateUser2BodyProfile = {[key: string]: string};

export type UpdateUser2Body = {
  /** The "chat_name" field is used to store the name displayed externally on the platform.
For example, "chat_name" is shown when an agent connects to chats with clients. */
  chatName?: string;
  /** [optional] contact connected to this user */
  contact?: ApiObjectId;
  createdAt?: string;
  createdBy?: ApiUserId;
  deletedAt?: string;
  deletedBy?: ApiUserId;
  device?: ApiObjectId;
  /** [editable] list of unique `regular` devices, attached to this user */
  devices?: ApiObjectId[];
  email?: string;
  extension?: string;
  /** When set to true, the user will be required to change their password on next login. */
  forcePasswordChange?: boolean;
  hotdesks?: ApiObjectId[];
  license?: ApiLicenseUser[];
  name?: string;
  password?: string;
  permissions?: ApiPermission[];
  /** string presence = 7; // unique set of <user> presentity <status:basic> tuples open[ed]
 string status = 8; // short display status (short description) */
  presence?: ApiUserPresence;
  profile?: UpdateUser2BodyProfile;
  roles?: ApiObjectId[];
  totpUrl?: string;
  updatedAt?: string;
  updatedBy?: ApiUserId;
  username?: string;
};

export type UpdateUserParams = {
/**
 * PATCH: partial update
 */
fields?: string[];
};

export type UpdateUserBodyProfile = {[key: string]: string};

export type UpdateUserBody = {
  /** The "chat_name" field is used to store the name displayed externally on the platform.
For example, "chat_name" is shown when an agent connects to chats with clients. */
  chatName?: string;
  /** [optional] contact connected to this user */
  contact?: ApiObjectId;
  createdAt?: string;
  createdBy?: ApiUserId;
  deletedAt?: string;
  deletedBy?: ApiUserId;
  device?: ApiObjectId;
  /** [editable] list of unique `regular` devices, attached to this user */
  devices?: ApiObjectId[];
  email?: string;
  extension?: string;
  /** When set to true, the user will be required to change their password on next login. */
  forcePasswordChange?: boolean;
  hotdesks?: ApiObjectId[];
  license?: ApiLicenseUser[];
  name?: string;
  password?: string;
  permissions?: ApiPermission[];
  /** string presence = 7; // unique set of <user> presentity <status:basic> tuples open[ed]
 string status = 8; // short display status (short description) */
  presence?: ApiUserPresence;
  profile?: UpdateUserBodyProfile;
  roles?: ApiObjectId[];
  totpUrl?: string;
  updatedAt?: string;
  updatedBy?: ApiUserId;
  username?: string;
};

export type ListUserAccessTokenParams = {
/**
 * display name
 */
userName?: string;
/**
 * int32 page = 2;
int64 size = 3;

.usage ILIKE :q
 */
q?: string;
/**
 * ----- Search Options -------------------------

select: output (fields,...)
 */
fields?: string[];
/**
 * select: order by (fields,...)
 */
sort?: string[];
/**
 * select: offset {page}
 */
page?: number;
/**
 * select: limit {size}
 */
size?: number;
};

export type DeleteUserAccessTokenParams = {
/**
 * display name
 */
userName?: string;
};

export type GetUserAccessTokenParams = {
/**
 * display name
 */
userName?: string;
};

export type _DeleteParams = {
/**
 * Fields to be retrieved into result dataset.
 */
fields?: string[];
/**
 * [`record.id`]
 */
id: string[];
};

export type SearchRecordsParams = {
/**
 * Number of result records (per page).
Default: 16.
 */
size?: number;
/**
 * Page number of result set of records.
Default: 1.
 */
page?: number;
/**
 * Sort result dataset of records by fields.
```
sort ::= *( ORDER name )

ORDER  = ASC / DESC
DESC   = "-" / "!"
ASC    = [ "+" ]   ; Default
```

Fields available

- `id`(seq)
- `domain`{name}
- `created_at`
- `created_by`{name}
- `updated_at`
- `updated_by`{name}

Use ?fields=`field.sort()` option to sort Edge fields.
 */
sort?: string[];
/**
 * Fields [Q]uery to build result dataset record.
```
fields ::= field [ *( "," field ) ]
field  ::= name [ *( func ) ] [ inner ]
inner  ::= "{" fields "}"
funcs  ::= *( func )
func   ::= "." name "(" [ args ] ")"
name   ::= ALPHA / DIGIT / USCORE

ALPHA    = %x41-5A / %x61-7A  ; "A"-"Z" / "a"-"z"
DIGIT    = %x30-39            ; "0"-"9"
USCORE   = %x5F ; underscore  ; "_"
```
 */
fields?: string[];
/**
 * Search term:
`?` - matches any character
`*` - matches 0 or more characters
e.g.: name,emails{type},labels etc...
 */
q?: string;
/**
 * [`record.id`]
 */
id?: string[];
/**
 * Filter string in CEL format.
 */
filters?: string;
};

export type CreateBody = { [key: string]: unknown };

export type Create200 = { [key: string]: unknown };

export type LocateRecordsParams = {
/**
 * Fields [Q]uery to build result dataset record.
```
fields ::= field [ *( "," field ) ]
field  ::= name [ *( func ) ] [ inner ]
inner  ::= "{" fields "}"
funcs  ::= *( func )
func   ::= "." name "(" [ args ] ")"
name   ::= ALPHA / DIGIT / USCORE

ALPHA    = %x41-5A / %x61-7A  ; "A"-"Z" / "a"-"z"
DIGIT    = %x30-39            ; "0"-"9"
USCORE   = %x5F ; underscore  ; "_"
```
 */
fields?: string[];
};

export type LocateRecords200 = { [key: string]: unknown };

export type UpdateParams = {
/**
 * Source Fields to return into result.
 */
fields?: string[];
};

export type UpdateBody = { [key: string]: unknown };

export type Update200 = { [key: string]: unknown };

export type Update2Params = {
/**
 * Source Fields to return into result.
 */
fields?: string[];
};

export type Update2Body = { [key: string]: unknown };

export type Update2200 = { [key: string]: unknown };

export type AgentAbsenceServiceSearchAgentsAbsencesParams = {
/**
 * Searches by agent name.
 */
q?: string;
page?: number;
size?: number;
sort?: string;
fields?: string[];
filters?: string[];
};

export type AgentWorkingScheduleServiceSearchAgentsWorkingScheduleParams = {
dateFrom?: string;
dateTo?: string;
supervisorId?: string[];
teamId?: string[];
skillId?: string[];
q?: string;
};

/**
 * Map key is a day of week: 0 - Sunday, ..., 6 - Saturday.
 */
export type AgentWorkingScheduleServiceCreateAgentsWorkingScheduleShiftsBodyItems = {[key: string]: WfmAgentScheduleShift};

export type AgentWorkingScheduleServiceCreateAgentsWorkingScheduleShiftsBody = {
  agents?: WfmLookupEntity[];
  date?: WfmFilterBetween;
  /** Map key is a day of week: 0 - Sunday, ..., 6 - Saturday. */
  items?: AgentWorkingScheduleServiceCreateAgentsWorkingScheduleShiftsBodyItems;
};

export type AgentAbsenceServiceSearchAgentAbsenceParams = {
page?: number;
size?: number;
sort?: string;
fields?: string[];
filters?: string[];
};

export type AgentAbsenceServiceCreateAgentAbsenceBody = {
  item?: WfmAbsence;
};

export type AgentAbsenceServiceUpdateAgentAbsenceBodyItem = {
  absentAt?: string;
  createdAt?: string;
  createdBy?: WfmLookupEntity;
  domainId?: string;
  typeId?: WfmAbsenceType;
  updatedAt?: string;
  updatedBy?: WfmLookupEntity;
};

export type AgentAbsenceServiceUpdateAgentAbsenceBody = {
  item?: AgentAbsenceServiceUpdateAgentAbsenceBodyItem;
};

export type AgentWorkingConditionsServiceUpdateAgentWorkingConditionsBody = {
  item?: WfmAgentWorkingConditions;
};

export type ForecastCalculationServiceSearchForecastCalculationParams = {
q?: string;
page?: number;
size?: number;
sort?: string;
fields?: string[];
};

export type ForecastCalculationServiceReadForecastCalculationParams = {
fields?: string[];
};

export type ForecastCalculationServiceExecuteForecastCalculationParams = {
teamId?: string;
forecastDataFrom?: string;
forecastDataTo?: string;
};

export type ForecastCalculationServiceUpdateForecastCalculationBodyItem = {
  args?: string[];
  createdAt?: string;
  createdBy?: WfmLookupEntity;
  description?: string;
  domainId?: string;
  name?: string;
  procedure?: string;
  updatedAt?: string;
  updatedBy?: WfmLookupEntity;
};

export type ForecastCalculationServiceUpdateForecastCalculationBody = {
  item?: ForecastCalculationServiceUpdateForecastCalculationBodyItem;
};

export type PauseTemplateServiceSearchPauseTemplateParams = {
q?: string;
page?: number;
size?: number;
sort?: string;
fields?: string[];
};

export type PauseTemplateServiceReadPauseTemplateParams = {
fields?: string[];
};

export type PauseTemplateServiceUpdatePauseTemplateBodyItem = {
  causes?: WfmPauseTemplateCause[];
  createdAt?: string;
  createdBy?: WfmLookupEntity;
  description?: string;
  domainId?: string;
  name?: string;
  updatedAt?: string;
  updatedBy?: WfmLookupEntity;
};

export type PauseTemplateServiceUpdatePauseTemplateBody = {
  item?: PauseTemplateServiceUpdatePauseTemplateBodyItem;
};

export type ShiftTemplateServiceSearchShiftTemplateParams = {
q?: string;
page?: number;
size?: number;
sort?: string;
fields?: string[];
};

export type ShiftTemplateServiceReadShiftTemplateParams = {
fields?: string[];
};

export type ShiftTemplateServiceUpdateShiftTemplateBodyItem = {
  createdAt?: string;
  createdBy?: WfmLookupEntity;
  description?: string;
  domainId?: string;
  name?: string;
  times?: WfmShiftTemplateTime[];
  updatedAt?: string;
  updatedBy?: WfmLookupEntity;
};

export type ShiftTemplateServiceUpdateShiftTemplateBody = {
  item?: ShiftTemplateServiceUpdateShiftTemplateBodyItem;
};

export type WorkingConditionServiceSearchWorkingConditionParams = {
page?: number;
size?: number;
q?: string;
sort?: string;
fields?: string[];
};

export type WorkingConditionServiceReadWorkingConditionParams = {
fields?: string[];
};

export type WorkingConditionServiceUpdateWorkingConditionBodyItem = {
  createdAt?: string;
  createdBy?: WfmLookupEntity;
  daysOff?: number;
  description?: string;
  domainId?: string;
  name?: string;
  pauseDuration?: number;
  pauseTemplate?: WfmLookupEntity;
  shiftTemplate?: WfmLookupEntity;
  sickLeaves?: number;
  updatedAt?: string;
  updatedBy?: WfmLookupEntity;
  vacation?: number;
  workdayHours?: number;
  workdaysPerMonth?: number;
};

export type WorkingConditionServiceUpdateWorkingConditionBody = {
  item?: WorkingConditionServiceUpdateWorkingConditionBodyItem;
};

export type WorkingScheduleServiceSearchWorkingScheduleParams = {
q?: string;
page?: number;
size?: number;
sort?: string;
fields?: string[];
};

export type WorkingScheduleServiceReadWorkingScheduleParams = {
fields?: string[];
};

export type WorkingScheduleServiceUpdateWorkingScheduleAddAgentsBody = {
  agents?: WfmLookupEntity[];
};

export type WorkingScheduleServiceReadWorkingScheduleForecastParams = {
dateFrom?: string;
dateTo?: string;
};

export type WorkingScheduleServiceUpdateWorkingScheduleBodyItem = {
  agents?: WfmLookupEntity[];
  blockOutsideActivity?: boolean;
  calendar?: WfmLookupEntity;
  createdAt?: string;
  createdBy?: WfmLookupEntity;
  domainId?: string;
  endDateAt?: string;
  endTimeAt?: string;
  extraSkills?: WfmLookupEntity[];
  name?: string;
  startDateAt?: string;
  startTimeAt?: string;
  state?: WfmWorkingScheduleState;
  team?: WfmLookupEntity;
  totalAgents?: string;
  updatedAt?: string;
  updatedBy?: WfmLookupEntity;
};

export type WorkingScheduleServiceUpdateWorkingScheduleBody = {
  item?: WorkingScheduleServiceUpdateWorkingScheduleBodyItem;
};

export type ListObjectAccessParams = {
/**
 * --- filters ---

[optional] [FROM] each rule owner is any of role(s) id; user -or- role
 */
grantor?: string[];
/**
 * [optional] [TO] subject role(s) id; user -or- role
 */
grantee?: string[];
/**
 * [xrwdxrwd] [R]ecord-[b]ased-[A]ccess-[C]ontrol level check(!)
 */
granted?: string[];
/**
 * [optional] [TO] subject.name ILIKE ?q=; user -or- role
 */
q?: string;
/**
 * ----- Select Options -------------------------

attributes list
 */
fields?: string[];
/**
 * e.g.: "updated_at" - ASC; "!updated_at" - DESC;
 */
sort?: string[];
/**
 * pagedResultsControl

default: 16
 */
size?: number;
/**
 * default: 1
 */
page?: number;
};

