/**
 * Generated by orval v7.10.0 üç∫
 * Do not edit manually.
 * Webitel API
 * OpenAPI spec version: 24.04.0
 */
import { z as zod } from 'zod/v4';

/**
 * @summary Delete a dictionary records.
 */
export const dictionariesDeleteDataParams = zod.object({
	repo: zod.string().describe('[`types.repo`]'),
});

export const dictionariesDeleteDataQueryParams = zod.object({
	fields: zod
		.array(zod.string())
		.optional()
		.describe('Fields to be retrieved into result dataset.'),
	id: zod.array(zod.string()).describe('[`record.id`]'),
});

export const dictionariesDeleteDataResponseTypeFieldsItemKindDefault = 'none';

export const dictionariesDeleteDataResponse = zod
	.object({
		data: zod
			.array(zod.object({}))
			.optional()
			.describe('List of the dataset page records.'),
		next: zod.boolean().optional(),
		page: zod.number().optional().describe('Current page number.'),
		type: zod
			.object({
				about: zod.string().optional().describe('Optional. Short description.'),
				administered: zod.boolean().optional(),
				createdAt: zod.string().optional(),
				createdBy: zod
					.object({
						id: zod
							.string()
							.optional()
							.describe('Required. Unique Identifier.'),
						name: zod.string().optional().describe('Readonly. Display name.'),
						type: zod.string().optional().describe('Optional. Reference type.'),
					})
					.optional(),
				display: zod
					.string()
					.optional()
					.describe(
						'Required. Display [fields.id] key.\nUsed as [lookup].name setting for this [struct] type.',
					),
				extendable: zod
					.boolean()
					.optional()
					.describe('// Extension fields type.\n Extension extension = 23;'),
				fields: zod
					.array(
						zod
							.object({
								always: zod
									.any()
									.optional()
									.describe(
										'Always signifies that the field value will be computed on any write (INSERT OR UPDATE) operations.\nThe field cannot be written to, and when read the result of the last generated expression will be returned.\n\nThe generation expression can refer to other columns in the table, but not other generated columns. Any functions and operators used must be immutable. References to other tables are not allowed.',
									),
								binary: zod
									.object({
										maxBytes: zod.number().optional(),
										violation: zod
											.record(zod.string(), zod.string())
											.optional(),
									})
									.optional(),
								bool: zod.object({}).optional(),
								datetime: zod
									.object({
										epoch: zod
											.number()
											.optional()
											.describe(
												'Epoch timestamp.\nIf zero - UNIX epoch (1970-01-01 00:00:00) will be used.',
											),
										format: zod.string().optional(),
										zone: zod
											.string()
											.optional()
											.describe('Timezone associated.\nDefault: `UTC`.'),
									})
									.optional()
									.describe(
										'Datetime type settings.\n\nenum Part {\n   full = 0; // date & time\n   date = 1; // date only ; YYYY-MM-DD\n   time = 2; // time only ; HH:mm:ss[.pres]\n }\n Part part = 1; // part of: [ date &| time ]\n enum Stamp {\n   s  =  0; // seconds\n   ms =  1; // [milli]seconds ; E+3\n   mc =  2; // [micro]seconds ; E+6\n   ns =  3; // [nano]seconds  ; E+9\n   m  = -1; // minutes\n   h  = -2; // hours\n }\n Stamp time = 2; // time precision\n string zone = 3; // ??? [ Europe/Kyiv | +03:00 ]',
									),
								default: zod
									.any()
									.optional()
									.describe(
										'The `default` expression will be used in `INSERT` operation\nthat does not specify a value for the field.\n\nIf there is no default for a field, then the default is null.',
									),
								disabled: zod.boolean().optional(),
								duration: zod
									.object({
										format: zod.string().optional(),
										max: zod.string().optional(),
										min: zod.string().optional(),
										violation: zod
											.record(zod.string(), zod.string())
											.optional(),
									})
									.optional(),
								float: zod
									.object({
										frac: zod.number().optional(),
										max: zod.number().optional(),
										min: zod.number().optional(),
										violation: zod
											.record(zod.string(), zod.string())
											.optional(),
									})
									.optional(),
								float32: zod
									.object({
										frac: zod.number().optional(),
										max: zod.number().optional(),
										min: zod.number().optional(),
										violation: zod
											.record(zod.string(), zod.string())
											.optional(),
									})
									.optional(),
								float64: zod
									.object({
										frac: zod.number().optional(),
										max: zod.number().optional(),
										min: zod.number().optional(),
										violation: zod
											.record(zod.string(), zod.string())
											.optional(),
									})
									.optional(),
								hidden: zod.boolean().optional(),
								hint: zod
									.string()
									.optional()
									.describe('Short description. Default: {name}.'),
								id: zod
									.string()
									.optional()
									.describe('Field [code] name.\n\ncode'),
								int: zod
									.object({
										max: zod.string().optional(),
										min: zod.string().optional(),
										violation: zod
											.record(zod.string(), zod.string())
											.optional(),
									})
									.optional(),
								int32: zod
									.object({
										max: zod.string().optional(),
										min: zod.string().optional(),
										violation: zod
											.record(zod.string(), zod.string())
											.optional(),
									})
									.optional(),
								int64: zod
									.object({
										max: zod.string().optional(),
										min: zod.string().optional(),
										violation: zod
											.record(zod.string(), zod.string())
											.optional(),
									})
									.optional(),
								kind: zod
									.enum([
										'none',
										'list',
										'bool',
										'int',
										'int32',
										'int64',
										'uint',
										'uint32',
										'uint64',
										'float',
										'float32',
										'float64',
										'binary',
										'lookup',
										'string',
										'richtext',
										'datetime',
										'duration',
									])
									.default(
										dictionariesDeleteDataResponseTypeFieldsItemKindDefault,
									)
									.describe(
										'Kind of primitive data types.\n\n - none: option allow_alias = true;\n - list: [array]\n - int: int32\n - uint: uint32\n - float: float32\n - datetime: date &| time',
									),
								lookup: zod
									.object({
										display: zod
											.string()
											.optional()
											.describe(
												'[Readonly]. Display dataset field.\n(lookup).{`name`} value relation.',
											),
										name: zod
											.string()
											.optional()
											.describe('[Readonly]. Dataset title.'),
										path: zod
											.string()
											.optional()
											.describe(
												'[Required]. Reference dataset relative path\ne.g.: "contacts", "dictionaries/cities".\n(lookup).{`type`} value relation.',
											),
										primary: zod
											.string()
											.optional()
											.describe(
												'[Readonly]. Primary dataset field.\n(lookup).{`id`} value relation.',
											),
										query: zod.record(zod.string(), zod.string()).optional(),
										violation: zod
											.record(zod.string(), zod.string())
											.optional(),
									})
									.optional()
									.describe(
										'Lookup ( REFERENCE ) type descriptor.\nSimplified [webitel.custom.Struct] options.',
									),
								name: zod
									.string()
									.optional()
									.describe('Title of the field. Lang specific.\n\ntitle'),
								readonly: zod
									.boolean()
									.optional()
									.describe(
										'Optional. Disable any write (INSERT OR UPDATE) operations.\nREADONLY signifies that the field value will be always computed on any write (INSERT OR UPDATE) operations.\nIf selected, the `default` value MUST be specified.\n\nFIXME: Is base field ? [ id, created_, updated_ ]',
									),
								required: zod.boolean().optional(),
								richtext: zod
									.object({
										maxBytes: zod.number().optional(),
										maxChars: zod.number().optional(),
										multiline: zod.boolean().optional(),
										violation: zod
											.record(zod.string(), zod.string())
											.optional(),
									})
									.optional(),
								string: zod
									.object({
										maxBytes: zod.number().optional(),
										maxChars: zod.number().optional(),
										multiline: zod.boolean().optional(),
										violation: zod
											.record(zod.string(), zod.string())
											.optional(),
									})
									.optional(),
								uint: zod
									.object({
										max: zod.string().optional(),
										min: zod.string().optional(),
										violation: zod
											.record(zod.string(), zod.string())
											.optional(),
									})
									.optional(),
								uint32: zod
									.object({
										max: zod.string().optional(),
										min: zod.string().optional(),
										violation: zod
											.record(zod.string(), zod.string())
											.optional(),
									})
									.optional(),
								uint64: zod
									.object({
										max: zod.string().optional(),
										min: zod.string().optional(),
										violation: zod
											.record(zod.string(), zod.string())
											.optional(),
									})
									.optional(),
							})
							.describe('Field of the struct.'),
					)
					.optional()
					.describe('Fields of the struct type.'),
				id: zod
					.string()
					.optional()
					.describe(
						'Deprecated. Use `repo` instead. The [type] name (singular form), e.g.: `country`.',
					),
				indexes: zod
					.record(
						zod.string(),
						zod
							.object({
								fields: zod
									.array(zod.string())
									.optional()
									.describe(
										'A set of [struct.fields.id] to INDEX within [type] dataset.',
									),
								include: zod
									.array(zod.string())
									.optional()
									.describe(
										'A set of [struct.fields.id] to INCLUDE beside the [fields] index.',
									),
								unique: zod
									.boolean()
									.optional()
									.describe(
										'Indicates whether set of [fields] MUST be UNIQUE within [type].',
									),
							})
							.describe('INDEX [struct.fields].'),
					)
					.optional()
					.describe('INDEX fields.\n\nExtension extension = 15;'),
				name: zod
					.string()
					.optional()
					.describe('A User-friendly [id] name ; lang: specific.'),
				objclass: zod
					.string()
					.optional()
					.describe('Readonly. RbAC objclass identity.'),
				path: zod
					.string()
					.optional()
					.describe(
						'Readonly. Relative path to access the dataset APIs, e.g.: `dictionaries/countries`.',
					),
				primary: zod
					.string()
					.optional()
					.describe(
						'Required. Primary [fields.id] key.\nUsed as [lookup].id setting for this [struct] type.',
					),
				readonly: zod.boolean().optional(),
				repo: zod
					.string()
					.optional()
					.describe(
						'Repository (dataset) name (plural form), e.g.: `countries`.',
					),
				updatedAt: zod.string().optional(),
				updatedBy: zod
					.object({
						id: zod
							.string()
							.optional()
							.describe('Required. Unique Identifier.'),
						name: zod.string().optional().describe('Readonly. Display name.'),
						type: zod.string().optional().describe('Optional. Reference type.'),
					})
					.optional(),
			})
			.optional()
			.describe('Type of the Structure.\n\nint64 dc = 0;'),
	})
	.describe('Dataset records page view.');

/**
 * @summary Lookup a dictionary dataset.
 */
export const dictionariesSearchDataParams = zod.object({
	repo: zod.string().describe('[`types.repo`]'),
});

export const dictionariesSearchDataQuerySortItemDefault = '*';
export const dictionariesSearchDataQuerySortItemRegExp = /^[+|-|!]?\w+$/;
export const dictionariesSearchDataQueryFieldsItemDefault = '*';

export const dictionariesSearchDataQueryParams = zod.object({
	size: zod
		.number()
		.optional()
		.describe('Number of result records (per page).\nDefault: 16.'),
	page: zod
		.number()
		.optional()
		.describe('Page number of result set of records.\nDefault: 1.'),
	sort: zod
		.array(zod.string().regex(dictionariesSearchDataQuerySortItemRegExp))
		.optional()
		.describe(
			'Sort result dataset of records by fields.\n```\nsort ::= *( ORDER name )\n\nORDER  = ASC / DESC\nDESC   = "-" / "!"\nASC    = [ "+" ]   ; Default\n```\n\nFields available\n\n- `id`(seq)\n- `domain`{name}\n- `created_at`\n- `created_by`{name}\n- `updated_at`\n- `updated_by`{name}\n\nUse ?fields=`field.sort()` option to sort Edge fields.',
		),
	fields: zod
		.array(zod.string())
		.optional()
		.describe(
			'Fields [Q]uery to build result dataset record.\n```\nfields ::= field [ *( "," field ) ]\nfield  ::= name [ *( func ) ] [ inner ]\ninner  ::= "{" fields "}"\nfuncs  ::= *( func )\nfunc   ::= "." name "(" [ args ] ")"\nname   ::= ALPHA / DIGIT / USCORE\n\nALPHA    = %x41-5A / %x61-7A  ; "A"-"Z" / "a"-"z"\nDIGIT    = %x30-39            ; "0"-"9"\nUSCORE   = %x5F ; underscore  ; "_"\n```',
		),
	q: zod
		.string()
		.optional()
		.describe(
			'Search term:\n`?` - matches any character\n`*` - matches 0 or more characters\ne.g.: name,emails{type},labels etc...',
		),
	id: zod.array(zod.string()).optional().describe('[`record.id`]'),
});

export const dictionariesSearchDataResponseTypeFieldsItemKindDefault = 'none';

export const dictionariesSearchDataResponse = zod
	.object({
		data: zod
			.array(zod.object({}))
			.optional()
			.describe('List of the dataset page records.'),
		next: zod.boolean().optional(),
		page: zod.number().optional().describe('Current page number.'),
		type: zod
			.object({
				about: zod.string().optional().describe('Optional. Short description.'),
				administered: zod.boolean().optional(),
				createdAt: zod.string().optional(),
				createdBy: zod
					.object({
						id: zod
							.string()
							.optional()
							.describe('Required. Unique Identifier.'),
						name: zod.string().optional().describe('Readonly. Display name.'),
						type: zod.string().optional().describe('Optional. Reference type.'),
					})
					.optional(),
				display: zod
					.string()
					.optional()
					.describe(
						'Required. Display [fields.id] key.\nUsed as [lookup].name setting for this [struct] type.',
					),
				extendable: zod
					.boolean()
					.optional()
					.describe('// Extension fields type.\n Extension extension = 23;'),
				fields: zod
					.array(
						zod
							.object({
								always: zod
									.any()
									.optional()
									.describe(
										'Always signifies that the field value will be computed on any write (INSERT OR UPDATE) operations.\nThe field cannot be written to, and when read the result of the last generated expression will be returned.\n\nThe generation expression can refer to other columns in the table, but not other generated columns. Any functions and operators used must be immutable. References to other tables are not allowed.',
									),
								binary: zod
									.object({
										maxBytes: zod.number().optional(),
										violation: zod
											.record(zod.string(), zod.string())
											.optional(),
									})
									.optional(),
								bool: zod.object({}).optional(),
								datetime: zod
									.object({
										epoch: zod
											.number()
											.optional()
											.describe(
												'Epoch timestamp.\nIf zero - UNIX epoch (1970-01-01 00:00:00) will be used.',
											),
										format: zod.string().optional(),
										zone: zod
											.string()
											.optional()
											.describe('Timezone associated.\nDefault: `UTC`.'),
									})
									.optional()
									.describe(
										'Datetime type settings.\n\nenum Part {\n   full = 0; // date & time\n   date = 1; // date only ; YYYY-MM-DD\n   time = 2; // time only ; HH:mm:ss[.pres]\n }\n Part part = 1; // part of: [ date &| time ]\n enum Stamp {\n   s  =  0; // seconds\n   ms =  1; // [milli]seconds ; E+3\n   mc =  2; // [micro]seconds ; E+6\n   ns =  3; // [nano]seconds  ; E+9\n   m  = -1; // minutes\n   h  = -2; // hours\n }\n Stamp time = 2; // time precision\n string zone = 3; // ??? [ Europe/Kyiv | +03:00 ]',
									),
								default: zod
									.any()
									.optional()
									.describe(
										'The `default` expression will be used in `INSERT` operation\nthat does not specify a value for the field.\n\nIf there is no default for a field, then the default is null.',
									),
								disabled: zod.boolean().optional(),
								duration: zod
									.object({
										format: zod.string().optional(),
										max: zod.string().optional(),
										min: zod.string().optional(),
										violation: zod
											.record(zod.string(), zod.string())
											.optional(),
									})
									.optional(),
								float: zod
									.object({
										frac: zod.number().optional(),
										max: zod.number().optional(),
										min: zod.number().optional(),
										violation: zod
											.record(zod.string(), zod.string())
											.optional(),
									})
									.optional(),
								float32: zod
									.object({
										frac: zod.number().optional(),
										max: zod.number().optional(),
										min: zod.number().optional(),
										violation: zod
											.record(zod.string(), zod.string())
											.optional(),
									})
									.optional(),
								float64: zod
									.object({
										frac: zod.number().optional(),
										max: zod.number().optional(),
										min: zod.number().optional(),
										violation: zod
											.record(zod.string(), zod.string())
											.optional(),
									})
									.optional(),
								hidden: zod.boolean().optional(),
								hint: zod
									.string()
									.optional()
									.describe('Short description. Default: {name}.'),
								id: zod
									.string()
									.optional()
									.describe('Field [code] name.\n\ncode'),
								int: zod
									.object({
										max: zod.string().optional(),
										min: zod.string().optional(),
										violation: zod
											.record(zod.string(), zod.string())
											.optional(),
									})
									.optional(),
								int32: zod
									.object({
										max: zod.string().optional(),
										min: zod.string().optional(),
										violation: zod
											.record(zod.string(), zod.string())
											.optional(),
									})
									.optional(),
								int64: zod
									.object({
										max: zod.string().optional(),
										min: zod.string().optional(),
										violation: zod
											.record(zod.string(), zod.string())
											.optional(),
									})
									.optional(),
								kind: zod
									.enum([
										'none',
										'list',
										'bool',
										'int',
										'int32',
										'int64',
										'uint',
										'uint32',
										'uint64',
										'float',
										'float32',
										'float64',
										'binary',
										'lookup',
										'string',
										'richtext',
										'datetime',
										'duration',
									])
									.default(
										dictionariesSearchDataResponseTypeFieldsItemKindDefault,
									)
									.describe(
										'Kind of primitive data types.\n\n - none: option allow_alias = true;\n - list: [array]\n - int: int32\n - uint: uint32\n - float: float32\n - datetime: date &| time',
									),
								lookup: zod
									.object({
										display: zod
											.string()
											.optional()
											.describe(
												'[Readonly]. Display dataset field.\n(lookup).{`name`} value relation.',
											),
										name: zod
											.string()
											.optional()
											.describe('[Readonly]. Dataset title.'),
										path: zod
											.string()
											.optional()
											.describe(
												'[Required]. Reference dataset relative path\ne.g.: "contacts", "dictionaries/cities".\n(lookup).{`type`} value relation.',
											),
										primary: zod
											.string()
											.optional()
											.describe(
												'[Readonly]. Primary dataset field.\n(lookup).{`id`} value relation.',
											),
										query: zod.record(zod.string(), zod.string()).optional(),
										violation: zod
											.record(zod.string(), zod.string())
											.optional(),
									})
									.optional()
									.describe(
										'Lookup ( REFERENCE ) type descriptor.\nSimplified [webitel.custom.Struct] options.',
									),
								name: zod
									.string()
									.optional()
									.describe('Title of the field. Lang specific.\n\ntitle'),
								readonly: zod
									.boolean()
									.optional()
									.describe(
										'Optional. Disable any write (INSERT OR UPDATE) operations.\nREADONLY signifies that the field value will be always computed on any write (INSERT OR UPDATE) operations.\nIf selected, the `default` value MUST be specified.\n\nFIXME: Is base field ? [ id, created_, updated_ ]',
									),
								required: zod.boolean().optional(),
								richtext: zod
									.object({
										maxBytes: zod.number().optional(),
										maxChars: zod.number().optional(),
										multiline: zod.boolean().optional(),
										violation: zod
											.record(zod.string(), zod.string())
											.optional(),
									})
									.optional(),
								string: zod
									.object({
										maxBytes: zod.number().optional(),
										maxChars: zod.number().optional(),
										multiline: zod.boolean().optional(),
										violation: zod
											.record(zod.string(), zod.string())
											.optional(),
									})
									.optional(),
								uint: zod
									.object({
										max: zod.string().optional(),
										min: zod.string().optional(),
										violation: zod
											.record(zod.string(), zod.string())
											.optional(),
									})
									.optional(),
								uint32: zod
									.object({
										max: zod.string().optional(),
										min: zod.string().optional(),
										violation: zod
											.record(zod.string(), zod.string())
											.optional(),
									})
									.optional(),
								uint64: zod
									.object({
										max: zod.string().optional(),
										min: zod.string().optional(),
										violation: zod
											.record(zod.string(), zod.string())
											.optional(),
									})
									.optional(),
							})
							.describe('Field of the struct.'),
					)
					.optional()
					.describe('Fields of the struct type.'),
				id: zod
					.string()
					.optional()
					.describe(
						'Deprecated. Use `repo` instead. The [type] name (singular form), e.g.: `country`.',
					),
				indexes: zod
					.record(
						zod.string(),
						zod
							.object({
								fields: zod
									.array(zod.string())
									.optional()
									.describe(
										'A set of [struct.fields.id] to INDEX within [type] dataset.',
									),
								include: zod
									.array(zod.string())
									.optional()
									.describe(
										'A set of [struct.fields.id] to INCLUDE beside the [fields] index.',
									),
								unique: zod
									.boolean()
									.optional()
									.describe(
										'Indicates whether set of [fields] MUST be UNIQUE within [type].',
									),
							})
							.describe('INDEX [struct.fields].'),
					)
					.optional()
					.describe('INDEX fields.\n\nExtension extension = 15;'),
				name: zod
					.string()
					.optional()
					.describe('A User-friendly [id] name ; lang: specific.'),
				objclass: zod
					.string()
					.optional()
					.describe('Readonly. RbAC objclass identity.'),
				path: zod
					.string()
					.optional()
					.describe(
						'Readonly. Relative path to access the dataset APIs, e.g.: `dictionaries/countries`.',
					),
				primary: zod
					.string()
					.optional()
					.describe(
						'Required. Primary [fields.id] key.\nUsed as [lookup].id setting for this [struct] type.',
					),
				readonly: zod.boolean().optional(),
				repo: zod
					.string()
					.optional()
					.describe(
						'Repository (dataset) name (plural form), e.g.: `countries`.',
					),
				updatedAt: zod.string().optional(),
				updatedBy: zod
					.object({
						id: zod
							.string()
							.optional()
							.describe('Required. Unique Identifier.'),
						name: zod.string().optional().describe('Readonly. Display name.'),
						type: zod.string().optional().describe('Optional. Reference type.'),
					})
					.optional(),
			})
			.optional()
			.describe('Type of the Structure.\n\nint64 dc = 0;'),
	})
	.describe('Dataset records page view.');

/**
 * (Record) {
 * @summary Create a dictionary record.
 */
export const dictionariesCreateDataParams = zod.object({
	repo: zod.string().describe('[`types.repo`]'),
});

export const dictionariesCreateDataBody = zod.object({});

export const dictionariesCreateDataResponse = zod.object({});

/**
 * @summary Import dataset from CSV file.
 */
export const dictionariesImportCSVParams = zod.object({
	repo: zod.string().describe('`types.repo`'),
});

export const dictionariesImportCSVBodyOnDataErrorDefault = 'continue';
export const dictionariesImportCSVBodyOnEmptyLineDefault = 'continue';

export const dictionariesImportCSVBody = zod.object({
	data: zod.string().optional(),
	fields: zod.record(zod.string(), zod.number()).optional(),
	lineBegin: zod.number().optional(),
	lineEnd: zod.number().optional(),
	onDataError: zod
		.enum(['continue', 'break'])
		.default(dictionariesImportCSVBodyOnDataErrorDefault),
	onEmptyLine: zod
		.enum(['continue', 'break'])
		.default(dictionariesImportCSVBodyOnEmptyLineDefault),
});

export const dictionariesImportCSVResponseTypeFieldsItemKindDefault = 'none';

export const dictionariesImportCSVResponse = zod
	.object({
		data: zod
			.array(zod.object({}))
			.optional()
			.describe('List of the dataset page records.'),
		next: zod.boolean().optional(),
		page: zod.number().optional().describe('Current page number.'),
		type: zod
			.object({
				about: zod.string().optional().describe('Optional. Short description.'),
				administered: zod.boolean().optional(),
				createdAt: zod.string().optional(),
				createdBy: zod
					.object({
						id: zod
							.string()
							.optional()
							.describe('Required. Unique Identifier.'),
						name: zod.string().optional().describe('Readonly. Display name.'),
						type: zod.string().optional().describe('Optional. Reference type.'),
					})
					.optional(),
				display: zod
					.string()
					.optional()
					.describe(
						'Required. Display [fields.id] key.\nUsed as [lookup].name setting for this [struct] type.',
					),
				extendable: zod
					.boolean()
					.optional()
					.describe('// Extension fields type.\n Extension extension = 23;'),
				fields: zod
					.array(
						zod
							.object({
								always: zod
									.any()
									.optional()
									.describe(
										'Always signifies that the field value will be computed on any write (INSERT OR UPDATE) operations.\nThe field cannot be written to, and when read the result of the last generated expression will be returned.\n\nThe generation expression can refer to other columns in the table, but not other generated columns. Any functions and operators used must be immutable. References to other tables are not allowed.',
									),
								binary: zod
									.object({
										maxBytes: zod.number().optional(),
										violation: zod
											.record(zod.string(), zod.string())
											.optional(),
									})
									.optional(),
								bool: zod.object({}).optional(),
								datetime: zod
									.object({
										epoch: zod
											.number()
											.optional()
											.describe(
												'Epoch timestamp.\nIf zero - UNIX epoch (1970-01-01 00:00:00) will be used.',
											),
										format: zod.string().optional(),
										zone: zod
											.string()
											.optional()
											.describe('Timezone associated.\nDefault: `UTC`.'),
									})
									.optional()
									.describe(
										'Datetime type settings.\n\nenum Part {\n   full = 0; // date & time\n   date = 1; // date only ; YYYY-MM-DD\n   time = 2; // time only ; HH:mm:ss[.pres]\n }\n Part part = 1; // part of: [ date &| time ]\n enum Stamp {\n   s  =  0; // seconds\n   ms =  1; // [milli]seconds ; E+3\n   mc =  2; // [micro]seconds ; E+6\n   ns =  3; // [nano]seconds  ; E+9\n   m  = -1; // minutes\n   h  = -2; // hours\n }\n Stamp time = 2; // time precision\n string zone = 3; // ??? [ Europe/Kyiv | +03:00 ]',
									),
								default: zod
									.any()
									.optional()
									.describe(
										'The `default` expression will be used in `INSERT` operation\nthat does not specify a value for the field.\n\nIf there is no default for a field, then the default is null.',
									),
								disabled: zod.boolean().optional(),
								duration: zod
									.object({
										format: zod.string().optional(),
										max: zod.string().optional(),
										min: zod.string().optional(),
										violation: zod
											.record(zod.string(), zod.string())
											.optional(),
									})
									.optional(),
								float: zod
									.object({
										frac: zod.number().optional(),
										max: zod.number().optional(),
										min: zod.number().optional(),
										violation: zod
											.record(zod.string(), zod.string())
											.optional(),
									})
									.optional(),
								float32: zod
									.object({
										frac: zod.number().optional(),
										max: zod.number().optional(),
										min: zod.number().optional(),
										violation: zod
											.record(zod.string(), zod.string())
											.optional(),
									})
									.optional(),
								float64: zod
									.object({
										frac: zod.number().optional(),
										max: zod.number().optional(),
										min: zod.number().optional(),
										violation: zod
											.record(zod.string(), zod.string())
											.optional(),
									})
									.optional(),
								hidden: zod.boolean().optional(),
								hint: zod
									.string()
									.optional()
									.describe('Short description. Default: {name}.'),
								id: zod
									.string()
									.optional()
									.describe('Field [code] name.\n\ncode'),
								int: zod
									.object({
										max: zod.string().optional(),
										min: zod.string().optional(),
										violation: zod
											.record(zod.string(), zod.string())
											.optional(),
									})
									.optional(),
								int32: zod
									.object({
										max: zod.string().optional(),
										min: zod.string().optional(),
										violation: zod
											.record(zod.string(), zod.string())
											.optional(),
									})
									.optional(),
								int64: zod
									.object({
										max: zod.string().optional(),
										min: zod.string().optional(),
										violation: zod
											.record(zod.string(), zod.string())
											.optional(),
									})
									.optional(),
								kind: zod
									.enum([
										'none',
										'list',
										'bool',
										'int',
										'int32',
										'int64',
										'uint',
										'uint32',
										'uint64',
										'float',
										'float32',
										'float64',
										'binary',
										'lookup',
										'string',
										'richtext',
										'datetime',
										'duration',
									])
									.default(
										dictionariesImportCSVResponseTypeFieldsItemKindDefault,
									)
									.describe(
										'Kind of primitive data types.\n\n - none: option allow_alias = true;\n - list: [array]\n - int: int32\n - uint: uint32\n - float: float32\n - datetime: date &| time',
									),
								lookup: zod
									.object({
										display: zod
											.string()
											.optional()
											.describe(
												'[Readonly]. Display dataset field.\n(lookup).{`name`} value relation.',
											),
										name: zod
											.string()
											.optional()
											.describe('[Readonly]. Dataset title.'),
										path: zod
											.string()
											.optional()
											.describe(
												'[Required]. Reference dataset relative path\ne.g.: "contacts", "dictionaries/cities".\n(lookup).{`type`} value relation.',
											),
										primary: zod
											.string()
											.optional()
											.describe(
												'[Readonly]. Primary dataset field.\n(lookup).{`id`} value relation.',
											),
										query: zod.record(zod.string(), zod.string()).optional(),
										violation: zod
											.record(zod.string(), zod.string())
											.optional(),
									})
									.optional()
									.describe(
										'Lookup ( REFERENCE ) type descriptor.\nSimplified [webitel.custom.Struct] options.',
									),
								name: zod
									.string()
									.optional()
									.describe('Title of the field. Lang specific.\n\ntitle'),
								readonly: zod
									.boolean()
									.optional()
									.describe(
										'Optional. Disable any write (INSERT OR UPDATE) operations.\nREADONLY signifies that the field value will be always computed on any write (INSERT OR UPDATE) operations.\nIf selected, the `default` value MUST be specified.\n\nFIXME: Is base field ? [ id, created_, updated_ ]',
									),
								required: zod.boolean().optional(),
								richtext: zod
									.object({
										maxBytes: zod.number().optional(),
										maxChars: zod.number().optional(),
										multiline: zod.boolean().optional(),
										violation: zod
											.record(zod.string(), zod.string())
											.optional(),
									})
									.optional(),
								string: zod
									.object({
										maxBytes: zod.number().optional(),
										maxChars: zod.number().optional(),
										multiline: zod.boolean().optional(),
										violation: zod
											.record(zod.string(), zod.string())
											.optional(),
									})
									.optional(),
								uint: zod
									.object({
										max: zod.string().optional(),
										min: zod.string().optional(),
										violation: zod
											.record(zod.string(), zod.string())
											.optional(),
									})
									.optional(),
								uint32: zod
									.object({
										max: zod.string().optional(),
										min: zod.string().optional(),
										violation: zod
											.record(zod.string(), zod.string())
											.optional(),
									})
									.optional(),
								uint64: zod
									.object({
										max: zod.string().optional(),
										min: zod.string().optional(),
										violation: zod
											.record(zod.string(), zod.string())
											.optional(),
									})
									.optional(),
							})
							.describe('Field of the struct.'),
					)
					.optional()
					.describe('Fields of the struct type.'),
				id: zod
					.string()
					.optional()
					.describe(
						'Deprecated. Use `repo` instead. The [type] name (singular form), e.g.: `country`.',
					),
				indexes: zod
					.record(
						zod.string(),
						zod
							.object({
								fields: zod
									.array(zod.string())
									.optional()
									.describe(
										'A set of [struct.fields.id] to INDEX within [type] dataset.',
									),
								include: zod
									.array(zod.string())
									.optional()
									.describe(
										'A set of [struct.fields.id] to INCLUDE beside the [fields] index.',
									),
								unique: zod
									.boolean()
									.optional()
									.describe(
										'Indicates whether set of [fields] MUST be UNIQUE within [type].',
									),
							})
							.describe('INDEX [struct.fields].'),
					)
					.optional()
					.describe('INDEX fields.\n\nExtension extension = 15;'),
				name: zod
					.string()
					.optional()
					.describe('A User-friendly [id] name ; lang: specific.'),
				objclass: zod
					.string()
					.optional()
					.describe('Readonly. RbAC objclass identity.'),
				path: zod
					.string()
					.optional()
					.describe(
						'Readonly. Relative path to access the dataset APIs, e.g.: `dictionaries/countries`.',
					),
				primary: zod
					.string()
					.optional()
					.describe(
						'Required. Primary [fields.id] key.\nUsed as [lookup].id setting for this [struct] type.',
					),
				readonly: zod.boolean().optional(),
				repo: zod
					.string()
					.optional()
					.describe(
						'Repository (dataset) name (plural form), e.g.: `countries`.',
					),
				updatedAt: zod.string().optional(),
				updatedBy: zod
					.object({
						id: zod
							.string()
							.optional()
							.describe('Required. Unique Identifier.'),
						name: zod.string().optional().describe('Readonly. Display name.'),
						type: zod.string().optional().describe('Optional. Reference type.'),
					})
					.optional(),
			})
			.optional()
			.describe('Type of the Structure.\n\nint64 dc = 0;'),
	})
	.describe('Dataset records page view.');

/**
 * @summary Delete a dictionary records.
 */
export const dictionariesDeleteData2Params = zod.object({
	repo: zod.string().describe('[`types.repo`]'),
	id: zod.array(zod.string()).min(1).describe('[`record.id`]'),
});

export const dictionariesDeleteData2QueryParams = zod.object({
	fields: zod
		.array(zod.string())
		.optional()
		.describe('Fields to be retrieved into result dataset.'),
});

export const dictionariesDeleteData2ResponseTypeFieldsItemKindDefault = 'none';

export const dictionariesDeleteData2Response = zod
	.object({
		data: zod
			.array(zod.object({}))
			.optional()
			.describe('List of the dataset page records.'),
		next: zod.boolean().optional(),
		page: zod.number().optional().describe('Current page number.'),
		type: zod
			.object({
				about: zod.string().optional().describe('Optional. Short description.'),
				administered: zod.boolean().optional(),
				createdAt: zod.string().optional(),
				createdBy: zod
					.object({
						id: zod
							.string()
							.optional()
							.describe('Required. Unique Identifier.'),
						name: zod.string().optional().describe('Readonly. Display name.'),
						type: zod.string().optional().describe('Optional. Reference type.'),
					})
					.optional(),
				display: zod
					.string()
					.optional()
					.describe(
						'Required. Display [fields.id] key.\nUsed as [lookup].name setting for this [struct] type.',
					),
				extendable: zod
					.boolean()
					.optional()
					.describe('// Extension fields type.\n Extension extension = 23;'),
				fields: zod
					.array(
						zod
							.object({
								always: zod
									.any()
									.optional()
									.describe(
										'Always signifies that the field value will be computed on any write (INSERT OR UPDATE) operations.\nThe field cannot be written to, and when read the result of the last generated expression will be returned.\n\nThe generation expression can refer to other columns in the table, but not other generated columns. Any functions and operators used must be immutable. References to other tables are not allowed.',
									),
								binary: zod
									.object({
										maxBytes: zod.number().optional(),
										violation: zod
											.record(zod.string(), zod.string())
											.optional(),
									})
									.optional(),
								bool: zod.object({}).optional(),
								datetime: zod
									.object({
										epoch: zod
											.number()
											.optional()
											.describe(
												'Epoch timestamp.\nIf zero - UNIX epoch (1970-01-01 00:00:00) will be used.',
											),
										format: zod.string().optional(),
										zone: zod
											.string()
											.optional()
											.describe('Timezone associated.\nDefault: `UTC`.'),
									})
									.optional()
									.describe(
										'Datetime type settings.\n\nenum Part {\n   full = 0; // date & time\n   date = 1; // date only ; YYYY-MM-DD\n   time = 2; // time only ; HH:mm:ss[.pres]\n }\n Part part = 1; // part of: [ date &| time ]\n enum Stamp {\n   s  =  0; // seconds\n   ms =  1; // [milli]seconds ; E+3\n   mc =  2; // [micro]seconds ; E+6\n   ns =  3; // [nano]seconds  ; E+9\n   m  = -1; // minutes\n   h  = -2; // hours\n }\n Stamp time = 2; // time precision\n string zone = 3; // ??? [ Europe/Kyiv | +03:00 ]',
									),
								default: zod
									.any()
									.optional()
									.describe(
										'The `default` expression will be used in `INSERT` operation\nthat does not specify a value for the field.\n\nIf there is no default for a field, then the default is null.',
									),
								disabled: zod.boolean().optional(),
								duration: zod
									.object({
										format: zod.string().optional(),
										max: zod.string().optional(),
										min: zod.string().optional(),
										violation: zod
											.record(zod.string(), zod.string())
											.optional(),
									})
									.optional(),
								float: zod
									.object({
										frac: zod.number().optional(),
										max: zod.number().optional(),
										min: zod.number().optional(),
										violation: zod
											.record(zod.string(), zod.string())
											.optional(),
									})
									.optional(),
								float32: zod
									.object({
										frac: zod.number().optional(),
										max: zod.number().optional(),
										min: zod.number().optional(),
										violation: zod
											.record(zod.string(), zod.string())
											.optional(),
									})
									.optional(),
								float64: zod
									.object({
										frac: zod.number().optional(),
										max: zod.number().optional(),
										min: zod.number().optional(),
										violation: zod
											.record(zod.string(), zod.string())
											.optional(),
									})
									.optional(),
								hidden: zod.boolean().optional(),
								hint: zod
									.string()
									.optional()
									.describe('Short description. Default: {name}.'),
								id: zod
									.string()
									.optional()
									.describe('Field [code] name.\n\ncode'),
								int: zod
									.object({
										max: zod.string().optional(),
										min: zod.string().optional(),
										violation: zod
											.record(zod.string(), zod.string())
											.optional(),
									})
									.optional(),
								int32: zod
									.object({
										max: zod.string().optional(),
										min: zod.string().optional(),
										violation: zod
											.record(zod.string(), zod.string())
											.optional(),
									})
									.optional(),
								int64: zod
									.object({
										max: zod.string().optional(),
										min: zod.string().optional(),
										violation: zod
											.record(zod.string(), zod.string())
											.optional(),
									})
									.optional(),
								kind: zod
									.enum([
										'none',
										'list',
										'bool',
										'int',
										'int32',
										'int64',
										'uint',
										'uint32',
										'uint64',
										'float',
										'float32',
										'float64',
										'binary',
										'lookup',
										'string',
										'richtext',
										'datetime',
										'duration',
									])
									.default(
										dictionariesDeleteData2ResponseTypeFieldsItemKindDefault,
									)
									.describe(
										'Kind of primitive data types.\n\n - none: option allow_alias = true;\n - list: [array]\n - int: int32\n - uint: uint32\n - float: float32\n - datetime: date &| time',
									),
								lookup: zod
									.object({
										display: zod
											.string()
											.optional()
											.describe(
												'[Readonly]. Display dataset field.\n(lookup).{`name`} value relation.',
											),
										name: zod
											.string()
											.optional()
											.describe('[Readonly]. Dataset title.'),
										path: zod
											.string()
											.optional()
											.describe(
												'[Required]. Reference dataset relative path\ne.g.: "contacts", "dictionaries/cities".\n(lookup).{`type`} value relation.',
											),
										primary: zod
											.string()
											.optional()
											.describe(
												'[Readonly]. Primary dataset field.\n(lookup).{`id`} value relation.',
											),
										query: zod.record(zod.string(), zod.string()).optional(),
										violation: zod
											.record(zod.string(), zod.string())
											.optional(),
									})
									.optional()
									.describe(
										'Lookup ( REFERENCE ) type descriptor.\nSimplified [webitel.custom.Struct] options.',
									),
								name: zod
									.string()
									.optional()
									.describe('Title of the field. Lang specific.\n\ntitle'),
								readonly: zod
									.boolean()
									.optional()
									.describe(
										'Optional. Disable any write (INSERT OR UPDATE) operations.\nREADONLY signifies that the field value will be always computed on any write (INSERT OR UPDATE) operations.\nIf selected, the `default` value MUST be specified.\n\nFIXME: Is base field ? [ id, created_, updated_ ]',
									),
								required: zod.boolean().optional(),
								richtext: zod
									.object({
										maxBytes: zod.number().optional(),
										maxChars: zod.number().optional(),
										multiline: zod.boolean().optional(),
										violation: zod
											.record(zod.string(), zod.string())
											.optional(),
									})
									.optional(),
								string: zod
									.object({
										maxBytes: zod.number().optional(),
										maxChars: zod.number().optional(),
										multiline: zod.boolean().optional(),
										violation: zod
											.record(zod.string(), zod.string())
											.optional(),
									})
									.optional(),
								uint: zod
									.object({
										max: zod.string().optional(),
										min: zod.string().optional(),
										violation: zod
											.record(zod.string(), zod.string())
											.optional(),
									})
									.optional(),
								uint32: zod
									.object({
										max: zod.string().optional(),
										min: zod.string().optional(),
										violation: zod
											.record(zod.string(), zod.string())
											.optional(),
									})
									.optional(),
								uint64: zod
									.object({
										max: zod.string().optional(),
										min: zod.string().optional(),
										violation: zod
											.record(zod.string(), zod.string())
											.optional(),
									})
									.optional(),
							})
							.describe('Field of the struct.'),
					)
					.optional()
					.describe('Fields of the struct type.'),
				id: zod
					.string()
					.optional()
					.describe(
						'Deprecated. Use `repo` instead. The [type] name (singular form), e.g.: `country`.',
					),
				indexes: zod
					.record(
						zod.string(),
						zod
							.object({
								fields: zod
									.array(zod.string())
									.optional()
									.describe(
										'A set of [struct.fields.id] to INDEX within [type] dataset.',
									),
								include: zod
									.array(zod.string())
									.optional()
									.describe(
										'A set of [struct.fields.id] to INCLUDE beside the [fields] index.',
									),
								unique: zod
									.boolean()
									.optional()
									.describe(
										'Indicates whether set of [fields] MUST be UNIQUE within [type].',
									),
							})
							.describe('INDEX [struct.fields].'),
					)
					.optional()
					.describe('INDEX fields.\n\nExtension extension = 15;'),
				name: zod
					.string()
					.optional()
					.describe('A User-friendly [id] name ; lang: specific.'),
				objclass: zod
					.string()
					.optional()
					.describe('Readonly. RbAC objclass identity.'),
				path: zod
					.string()
					.optional()
					.describe(
						'Readonly. Relative path to access the dataset APIs, e.g.: `dictionaries/countries`.',
					),
				primary: zod
					.string()
					.optional()
					.describe(
						'Required. Primary [fields.id] key.\nUsed as [lookup].id setting for this [struct] type.',
					),
				readonly: zod.boolean().optional(),
				repo: zod
					.string()
					.optional()
					.describe(
						'Repository (dataset) name (plural form), e.g.: `countries`.',
					),
				updatedAt: zod.string().optional(),
				updatedBy: zod
					.object({
						id: zod
							.string()
							.optional()
							.describe('Required. Unique Identifier.'),
						name: zod.string().optional().describe('Readonly. Display name.'),
						type: zod.string().optional().describe('Optional. Reference type.'),
					})
					.optional(),
			})
			.optional()
			.describe('Type of the Structure.\n\nint64 dc = 0;'),
	})
	.describe('Dataset records page view.');

/**
 * (Record) {
 * @summary Locate a dictionary record.
 */
export const dictionariesLocateDataParams = zod.object({
	repo: zod.string().describe('[`types.repo`]'),
	id: zod.string().describe('[`record.id`]'),
});

export const dictionariesLocateDataQueryFieldsItemDefault = '*';

export const dictionariesLocateDataQueryParams = zod.object({
	fields: zod
		.array(zod.string())
		.optional()
		.describe(
			'Fields [Q]uery to build result dataset record.\n```\nfields ::= field [ *( "," field ) ]\nfield  ::= name [ *( func ) ] [ inner ]\ninner  ::= "{" fields "}"\nfuncs  ::= *( func )\nfunc   ::= "." name "(" [ args ] ")"\nname   ::= ALPHA / DIGIT / USCORE\n\nALPHA    = %x41-5A / %x61-7A  ; "A"-"Z" / "a"-"z"\nDIGIT    = %x30-39            ; "0"-"9"\nUSCORE   = %x5F ; underscore  ; "_"\n```',
		),
});

export const dictionariesLocateDataResponse = zod.object({});

/**
 * (Record) {
 * @summary Update a dictionary record.
 */
export const dictionariesUpdateDataParams = zod.object({
	repo: zod.string().describe('[`types.repo`] data source'),
	id: zod.string().describe('[`record.id`] for update'),
});

export const dictionariesUpdateDataQueryParams = zod.object({
	fields: zod
		.array(zod.string())
		.optional()
		.describe('Source Fields to return into result.'),
});

export const dictionariesUpdateDataBody = zod.object({});

export const dictionariesUpdateDataResponse = zod.object({});

/**
 * (Record) {
 * @summary Update a dictionary record.
 */
export const dictionariesUpdateData2Params = zod.object({
	repo: zod.string().describe('[`types.repo`] data source'),
	id: zod.string().describe('[`record.id`] for update'),
});

export const dictionariesUpdateData2QueryParams = zod.object({
	fields: zod
		.array(zod.string())
		.optional()
		.describe('Source Fields to return into result.'),
});

export const dictionariesUpdateData2Body = zod.object({});

export const dictionariesUpdateData2Response = zod.object({});

/**
 * (DictionaryList) {
 * @summary Delete custom dictionaries.
 */
export const dictionariesDeleteTypeQueryParams = zod.object({
	fields: zod
		.array(zod.string())
		.optional()
		.describe('Fields to retrive into result dataset.'),
	repo: zod
		.array(zod.string())
		.describe('`types.repo`\n\n// `record.pk`\n repeated string id = 3;'),
});

export const dictionariesDeleteTypeResponseDataItemFieldsItemKindDefault =
	'none';

export const dictionariesDeleteTypeResponse = zod
	.object({
		data: zod
			.array(
				zod
					.object({
						about: zod
							.string()
							.optional()
							.describe('Optional. Short description.'),
						administered: zod.boolean().optional(),
						createdAt: zod.string().optional(),
						createdBy: zod
							.object({
								id: zod
									.string()
									.optional()
									.describe('Required. Unique Identifier.'),
								name: zod
									.string()
									.optional()
									.describe('Readonly. Display name.'),
								type: zod
									.string()
									.optional()
									.describe('Optional. Reference type.'),
							})
							.optional(),
						display: zod
							.string()
							.optional()
							.describe(
								'Required. Display [fields.id] key.\nUsed as [lookup].name setting for this [struct] type.',
							),
						extendable: zod
							.boolean()
							.optional()
							.describe(
								'// Extension fields type.\n Extension extension = 23;',
							),
						fields: zod
							.array(
								zod
									.object({
										always: zod
											.any()
											.optional()
											.describe(
												'Always signifies that the field value will be computed on any write (INSERT OR UPDATE) operations.\nThe field cannot be written to, and when read the result of the last generated expression will be returned.\n\nThe generation expression can refer to other columns in the table, but not other generated columns. Any functions and operators used must be immutable. References to other tables are not allowed.',
											),
										binary: zod
											.object({
												maxBytes: zod.number().optional(),
												violation: zod
													.record(zod.string(), zod.string())
													.optional(),
											})
											.optional(),
										bool: zod.object({}).optional(),
										datetime: zod
											.object({
												epoch: zod
													.number()
													.optional()
													.describe(
														'Epoch timestamp.\nIf zero - UNIX epoch (1970-01-01 00:00:00) will be used.',
													),
												format: zod.string().optional(),
												zone: zod
													.string()
													.optional()
													.describe('Timezone associated.\nDefault: `UTC`.'),
											})
											.optional()
											.describe(
												'Datetime type settings.\n\nenum Part {\n   full = 0; // date & time\n   date = 1; // date only ; YYYY-MM-DD\n   time = 2; // time only ; HH:mm:ss[.pres]\n }\n Part part = 1; // part of: [ date &| time ]\n enum Stamp {\n   s  =  0; // seconds\n   ms =  1; // [milli]seconds ; E+3\n   mc =  2; // [micro]seconds ; E+6\n   ns =  3; // [nano]seconds  ; E+9\n   m  = -1; // minutes\n   h  = -2; // hours\n }\n Stamp time = 2; // time precision\n string zone = 3; // ??? [ Europe/Kyiv | +03:00 ]',
											),
										default: zod
											.any()
											.optional()
											.describe(
												'The `default` expression will be used in `INSERT` operation\nthat does not specify a value for the field.\n\nIf there is no default for a field, then the default is null.',
											),
										disabled: zod.boolean().optional(),
										duration: zod
											.object({
												format: zod.string().optional(),
												max: zod.string().optional(),
												min: zod.string().optional(),
												violation: zod
													.record(zod.string(), zod.string())
													.optional(),
											})
											.optional(),
										float: zod
											.object({
												frac: zod.number().optional(),
												max: zod.number().optional(),
												min: zod.number().optional(),
												violation: zod
													.record(zod.string(), zod.string())
													.optional(),
											})
											.optional(),
										float32: zod
											.object({
												frac: zod.number().optional(),
												max: zod.number().optional(),
												min: zod.number().optional(),
												violation: zod
													.record(zod.string(), zod.string())
													.optional(),
											})
											.optional(),
										float64: zod
											.object({
												frac: zod.number().optional(),
												max: zod.number().optional(),
												min: zod.number().optional(),
												violation: zod
													.record(zod.string(), zod.string())
													.optional(),
											})
											.optional(),
										hidden: zod.boolean().optional(),
										hint: zod
											.string()
											.optional()
											.describe('Short description. Default: {name}.'),
										id: zod
											.string()
											.optional()
											.describe('Field [code] name.\n\ncode'),
										int: zod
											.object({
												max: zod.string().optional(),
												min: zod.string().optional(),
												violation: zod
													.record(zod.string(), zod.string())
													.optional(),
											})
											.optional(),
										int32: zod
											.object({
												max: zod.string().optional(),
												min: zod.string().optional(),
												violation: zod
													.record(zod.string(), zod.string())
													.optional(),
											})
											.optional(),
										int64: zod
											.object({
												max: zod.string().optional(),
												min: zod.string().optional(),
												violation: zod
													.record(zod.string(), zod.string())
													.optional(),
											})
											.optional(),
										kind: zod
											.enum([
												'none',
												'list',
												'bool',
												'int',
												'int32',
												'int64',
												'uint',
												'uint32',
												'uint64',
												'float',
												'float32',
												'float64',
												'binary',
												'lookup',
												'string',
												'richtext',
												'datetime',
												'duration',
											])
											.default(
												dictionariesDeleteTypeResponseDataItemFieldsItemKindDefault,
											)
											.describe(
												'Kind of primitive data types.\n\n - none: option allow_alias = true;\n - list: [array]\n - int: int32\n - uint: uint32\n - float: float32\n - datetime: date &| time',
											),
										lookup: zod
											.object({
												display: zod
													.string()
													.optional()
													.describe(
														'[Readonly]. Display dataset field.\n(lookup).{`name`} value relation.',
													),
												name: zod
													.string()
													.optional()
													.describe('[Readonly]. Dataset title.'),
												path: zod
													.string()
													.optional()
													.describe(
														'[Required]. Reference dataset relative path\ne.g.: "contacts", "dictionaries/cities".\n(lookup).{`type`} value relation.',
													),
												primary: zod
													.string()
													.optional()
													.describe(
														'[Readonly]. Primary dataset field.\n(lookup).{`id`} value relation.',
													),
												query: zod
													.record(zod.string(), zod.string())
													.optional(),
												violation: zod
													.record(zod.string(), zod.string())
													.optional(),
											})
											.optional()
											.describe(
												'Lookup ( REFERENCE ) type descriptor.\nSimplified [webitel.custom.Struct] options.',
											),
										name: zod
											.string()
											.optional()
											.describe('Title of the field. Lang specific.\n\ntitle'),
										readonly: zod
											.boolean()
											.optional()
											.describe(
												'Optional. Disable any write (INSERT OR UPDATE) operations.\nREADONLY signifies that the field value will be always computed on any write (INSERT OR UPDATE) operations.\nIf selected, the `default` value MUST be specified.\n\nFIXME: Is base field ? [ id, created_, updated_ ]',
											),
										required: zod.boolean().optional(),
										richtext: zod
											.object({
												maxBytes: zod.number().optional(),
												maxChars: zod.number().optional(),
												multiline: zod.boolean().optional(),
												violation: zod
													.record(zod.string(), zod.string())
													.optional(),
											})
											.optional(),
										string: zod
											.object({
												maxBytes: zod.number().optional(),
												maxChars: zod.number().optional(),
												multiline: zod.boolean().optional(),
												violation: zod
													.record(zod.string(), zod.string())
													.optional(),
											})
											.optional(),
										uint: zod
											.object({
												max: zod.string().optional(),
												min: zod.string().optional(),
												violation: zod
													.record(zod.string(), zod.string())
													.optional(),
											})
											.optional(),
										uint32: zod
											.object({
												max: zod.string().optional(),
												min: zod.string().optional(),
												violation: zod
													.record(zod.string(), zod.string())
													.optional(),
											})
											.optional(),
										uint64: zod
											.object({
												max: zod.string().optional(),
												min: zod.string().optional(),
												violation: zod
													.record(zod.string(), zod.string())
													.optional(),
											})
											.optional(),
									})
									.describe('Field of the struct.'),
							)
							.optional()
							.describe('Fields of the struct type.'),
						id: zod
							.string()
							.optional()
							.describe(
								'Deprecated. Use `repo` instead. The [type] name (singular form), e.g.: `country`.',
							),
						indexes: zod
							.record(
								zod.string(),
								zod
									.object({
										fields: zod
											.array(zod.string())
											.optional()
											.describe(
												'A set of [struct.fields.id] to INDEX within [type] dataset.',
											),
										include: zod
											.array(zod.string())
											.optional()
											.describe(
												'A set of [struct.fields.id] to INCLUDE beside the [fields] index.',
											),
										unique: zod
											.boolean()
											.optional()
											.describe(
												'Indicates whether set of [fields] MUST be UNIQUE within [type].',
											),
									})
									.describe('INDEX [struct.fields].'),
							)
							.optional()
							.describe('INDEX fields.\n\nExtension extension = 15;'),
						name: zod
							.string()
							.optional()
							.describe('A User-friendly [id] name ; lang: specific.'),
						objclass: zod
							.string()
							.optional()
							.describe('Readonly. RbAC objclass identity.'),
						path: zod
							.string()
							.optional()
							.describe(
								'Readonly. Relative path to access the dataset APIs, e.g.: `dictionaries/countries`.',
							),
						primary: zod
							.string()
							.optional()
							.describe(
								'Required. Primary [fields.id] key.\nUsed as [lookup].id setting for this [struct] type.',
							),
						readonly: zod.boolean().optional(),
						repo: zod
							.string()
							.optional()
							.describe(
								'Repository (dataset) name (plural form), e.g.: `countries`.',
							),
						updatedAt: zod.string().optional(),
						updatedBy: zod
							.object({
								id: zod
									.string()
									.optional()
									.describe('Required. Unique Identifier.'),
								name: zod
									.string()
									.optional()
									.describe('Readonly. Display name.'),
								type: zod
									.string()
									.optional()
									.describe('Optional. Reference type.'),
							})
							.optional(),
					})
					.describe('Type of the Structure.\n\nint64 dc = 0;'),
			)
			.optional()
			.describe('List of `Struct` types.'),
		next: zod.boolean().optional(),
		page: zod.number().optional().describe('Page number of results.'),
	})
	.describe('Dataset of structured types.');

/**
 * @summary Lookup dictionaries data types.
 */
export const dictionariesSearchTypeQuerySortItemDefault = '*';
export const dictionariesSearchTypeQuerySortItemRegExp = /^[+|-|!]?\w+$/;
export const dictionariesSearchTypeQueryFieldsItemDefault = '*';

export const dictionariesSearchTypeQueryParams = zod.object({
	q: zod
		.string()
		.optional()
		.describe(
			'Search term:\n`?` - matches any character\n`*` - matches 0 or more characters\ne.g.: name,emails{type},labels etc...',
		),
	id: zod.string().optional().describe('`types.id`'),
	name: zod.string().optional().describe('`types.name`'),
	repo: zod.string().optional().describe('`types.repo`'),
	path: zod.string().optional().describe('`types.path`'),
	readonly: zod
		.boolean()
		.optional()
		.describe('[NOT] [ system / custom ] types only'),
	extendable: zod
		.boolean()
		.optional()
		.describe('[NOT] Extend[able] types only.'),
	extensions: zod
		.boolean()
		.optional()
		.describe('[NOT] include extensions/* types.'),
	extended: zod.boolean().optional().describe('[NOT] Extend[ed] types only.'),
	administered: zod
		.boolean()
		.optional()
		.describe('[NOT] Administer access control only'),
	size: zod
		.number()
		.optional()
		.describe('Number of result records (per page).\nDefault: 16.'),
	page: zod
		.number()
		.optional()
		.describe('Page number of result set of records.\nDefault: 1.'),
	sort: zod
		.array(zod.string().regex(dictionariesSearchTypeQuerySortItemRegExp))
		.optional()
		.describe(
			'Sort result dataset of records by fields.\n```\nsort ::= *( ORDER name )\n\nORDER  = ASC / DESC\nDESC   = "-" / "!"\nASC    = [ "+" ]   ; Default\n```\n\nFields available\n\n- `id`(seq)\n- `domain`{name}\n- `created_at`\n- `created_by`{name}\n- `updated_at`\n- `updated_by`{name}\n\nUse ?fields=`field.sort()` option to sort Edge fields.',
		),
	fields: zod
		.array(zod.string())
		.optional()
		.describe(
			'Fields [Q]uery to build result dataset record.\n```\nfields ::= field [ *( "," field ) ]\nfield  ::= name [ *( func ) ] [ inner ]\ninner  ::= "{" fields "}"\nfuncs  ::= *( func )\nfunc   ::= "." name "(" [ args ] ")"\nname   ::= ALPHA / DIGIT / USCORE\n\nALPHA    = %x41-5A / %x61-7A  ; "A"-"Z" / "a"-"z"\nDIGIT    = %x30-39            ; "0"-"9"\nUSCORE   = %x5F ; underscore  ; "_"\n```',
		),
});

export const dictionariesSearchTypeResponseDataItemFieldsItemKindDefault =
	'none';

export const dictionariesSearchTypeResponse = zod
	.object({
		data: zod
			.array(
				zod
					.object({
						about: zod
							.string()
							.optional()
							.describe('Optional. Short description.'),
						administered: zod.boolean().optional(),
						createdAt: zod.string().optional(),
						createdBy: zod
							.object({
								id: zod
									.string()
									.optional()
									.describe('Required. Unique Identifier.'),
								name: zod
									.string()
									.optional()
									.describe('Readonly. Display name.'),
								type: zod
									.string()
									.optional()
									.describe('Optional. Reference type.'),
							})
							.optional(),
						display: zod
							.string()
							.optional()
							.describe(
								'Required. Display [fields.id] key.\nUsed as [lookup].name setting for this [struct] type.',
							),
						extendable: zod
							.boolean()
							.optional()
							.describe(
								'// Extension fields type.\n Extension extension = 23;',
							),
						fields: zod
							.array(
								zod
									.object({
										always: zod
											.any()
											.optional()
											.describe(
												'Always signifies that the field value will be computed on any write (INSERT OR UPDATE) operations.\nThe field cannot be written to, and when read the result of the last generated expression will be returned.\n\nThe generation expression can refer to other columns in the table, but not other generated columns. Any functions and operators used must be immutable. References to other tables are not allowed.',
											),
										binary: zod
											.object({
												maxBytes: zod.number().optional(),
												violation: zod
													.record(zod.string(), zod.string())
													.optional(),
											})
											.optional(),
										bool: zod.object({}).optional(),
										datetime: zod
											.object({
												epoch: zod
													.number()
													.optional()
													.describe(
														'Epoch timestamp.\nIf zero - UNIX epoch (1970-01-01 00:00:00) will be used.',
													),
												format: zod.string().optional(),
												zone: zod
													.string()
													.optional()
													.describe('Timezone associated.\nDefault: `UTC`.'),
											})
											.optional()
											.describe(
												'Datetime type settings.\n\nenum Part {\n   full = 0; // date & time\n   date = 1; // date only ; YYYY-MM-DD\n   time = 2; // time only ; HH:mm:ss[.pres]\n }\n Part part = 1; // part of: [ date &| time ]\n enum Stamp {\n   s  =  0; // seconds\n   ms =  1; // [milli]seconds ; E+3\n   mc =  2; // [micro]seconds ; E+6\n   ns =  3; // [nano]seconds  ; E+9\n   m  = -1; // minutes\n   h  = -2; // hours\n }\n Stamp time = 2; // time precision\n string zone = 3; // ??? [ Europe/Kyiv | +03:00 ]',
											),
										default: zod
											.any()
											.optional()
											.describe(
												'The `default` expression will be used in `INSERT` operation\nthat does not specify a value for the field.\n\nIf there is no default for a field, then the default is null.',
											),
										disabled: zod.boolean().optional(),
										duration: zod
											.object({
												format: zod.string().optional(),
												max: zod.string().optional(),
												min: zod.string().optional(),
												violation: zod
													.record(zod.string(), zod.string())
													.optional(),
											})
											.optional(),
										float: zod
											.object({
												frac: zod.number().optional(),
												max: zod.number().optional(),
												min: zod.number().optional(),
												violation: zod
													.record(zod.string(), zod.string())
													.optional(),
											})
											.optional(),
										float32: zod
											.object({
												frac: zod.number().optional(),
												max: zod.number().optional(),
												min: zod.number().optional(),
												violation: zod
													.record(zod.string(), zod.string())
													.optional(),
											})
											.optional(),
										float64: zod
											.object({
												frac: zod.number().optional(),
												max: zod.number().optional(),
												min: zod.number().optional(),
												violation: zod
													.record(zod.string(), zod.string())
													.optional(),
											})
											.optional(),
										hidden: zod.boolean().optional(),
										hint: zod
											.string()
											.optional()
											.describe('Short description. Default: {name}.'),
										id: zod
											.string()
											.optional()
											.describe('Field [code] name.\n\ncode'),
										int: zod
											.object({
												max: zod.string().optional(),
												min: zod.string().optional(),
												violation: zod
													.record(zod.string(), zod.string())
													.optional(),
											})
											.optional(),
										int32: zod
											.object({
												max: zod.string().optional(),
												min: zod.string().optional(),
												violation: zod
													.record(zod.string(), zod.string())
													.optional(),
											})
											.optional(),
										int64: zod
											.object({
												max: zod.string().optional(),
												min: zod.string().optional(),
												violation: zod
													.record(zod.string(), zod.string())
													.optional(),
											})
											.optional(),
										kind: zod
											.enum([
												'none',
												'list',
												'bool',
												'int',
												'int32',
												'int64',
												'uint',
												'uint32',
												'uint64',
												'float',
												'float32',
												'float64',
												'binary',
												'lookup',
												'string',
												'richtext',
												'datetime',
												'duration',
											])
											.default(
												dictionariesSearchTypeResponseDataItemFieldsItemKindDefault,
											)
											.describe(
												'Kind of primitive data types.\n\n - none: option allow_alias = true;\n - list: [array]\n - int: int32\n - uint: uint32\n - float: float32\n - datetime: date &| time',
											),
										lookup: zod
											.object({
												display: zod
													.string()
													.optional()
													.describe(
														'[Readonly]. Display dataset field.\n(lookup).{`name`} value relation.',
													),
												name: zod
													.string()
													.optional()
													.describe('[Readonly]. Dataset title.'),
												path: zod
													.string()
													.optional()
													.describe(
														'[Required]. Reference dataset relative path\ne.g.: "contacts", "dictionaries/cities".\n(lookup).{`type`} value relation.',
													),
												primary: zod
													.string()
													.optional()
													.describe(
														'[Readonly]. Primary dataset field.\n(lookup).{`id`} value relation.',
													),
												query: zod
													.record(zod.string(), zod.string())
													.optional(),
												violation: zod
													.record(zod.string(), zod.string())
													.optional(),
											})
											.optional()
											.describe(
												'Lookup ( REFERENCE ) type descriptor.\nSimplified [webitel.custom.Struct] options.',
											),
										name: zod
											.string()
											.optional()
											.describe('Title of the field. Lang specific.\n\ntitle'),
										readonly: zod
											.boolean()
											.optional()
											.describe(
												'Optional. Disable any write (INSERT OR UPDATE) operations.\nREADONLY signifies that the field value will be always computed on any write (INSERT OR UPDATE) operations.\nIf selected, the `default` value MUST be specified.\n\nFIXME: Is base field ? [ id, created_, updated_ ]',
											),
										required: zod.boolean().optional(),
										richtext: zod
											.object({
												maxBytes: zod.number().optional(),
												maxChars: zod.number().optional(),
												multiline: zod.boolean().optional(),
												violation: zod
													.record(zod.string(), zod.string())
													.optional(),
											})
											.optional(),
										string: zod
											.object({
												maxBytes: zod.number().optional(),
												maxChars: zod.number().optional(),
												multiline: zod.boolean().optional(),
												violation: zod
													.record(zod.string(), zod.string())
													.optional(),
											})
											.optional(),
										uint: zod
											.object({
												max: zod.string().optional(),
												min: zod.string().optional(),
												violation: zod
													.record(zod.string(), zod.string())
													.optional(),
											})
											.optional(),
										uint32: zod
											.object({
												max: zod.string().optional(),
												min: zod.string().optional(),
												violation: zod
													.record(zod.string(), zod.string())
													.optional(),
											})
											.optional(),
										uint64: zod
											.object({
												max: zod.string().optional(),
												min: zod.string().optional(),
												violation: zod
													.record(zod.string(), zod.string())
													.optional(),
											})
											.optional(),
									})
									.describe('Field of the struct.'),
							)
							.optional()
							.describe('Fields of the struct type.'),
						id: zod
							.string()
							.optional()
							.describe(
								'Deprecated. Use `repo` instead. The [type] name (singular form), e.g.: `country`.',
							),
						indexes: zod
							.record(
								zod.string(),
								zod
									.object({
										fields: zod
											.array(zod.string())
											.optional()
											.describe(
												'A set of [struct.fields.id] to INDEX within [type] dataset.',
											),
										include: zod
											.array(zod.string())
											.optional()
											.describe(
												'A set of [struct.fields.id] to INCLUDE beside the [fields] index.',
											),
										unique: zod
											.boolean()
											.optional()
											.describe(
												'Indicates whether set of [fields] MUST be UNIQUE within [type].',
											),
									})
									.describe('INDEX [struct.fields].'),
							)
							.optional()
							.describe('INDEX fields.\n\nExtension extension = 15;'),
						name: zod
							.string()
							.optional()
							.describe('A User-friendly [id] name ; lang: specific.'),
						objclass: zod
							.string()
							.optional()
							.describe('Readonly. RbAC objclass identity.'),
						path: zod
							.string()
							.optional()
							.describe(
								'Readonly. Relative path to access the dataset APIs, e.g.: `dictionaries/countries`.',
							),
						primary: zod
							.string()
							.optional()
							.describe(
								'Required. Primary [fields.id] key.\nUsed as [lookup].id setting for this [struct] type.',
							),
						readonly: zod.boolean().optional(),
						repo: zod
							.string()
							.optional()
							.describe(
								'Repository (dataset) name (plural form), e.g.: `countries`.',
							),
						updatedAt: zod.string().optional(),
						updatedBy: zod
							.object({
								id: zod
									.string()
									.optional()
									.describe('Required. Unique Identifier.'),
								name: zod
									.string()
									.optional()
									.describe('Readonly. Display name.'),
								type: zod
									.string()
									.optional()
									.describe('Optional. Reference type.'),
							})
							.optional(),
					})
					.describe('Type of the Structure.\n\nint64 dc = 0;'),
			)
			.optional()
			.describe('List of `Struct` types.'),
		next: zod.boolean().optional(),
		page: zod.number().optional().describe('Page number of results.'),
	})
	.describe('Dataset of structured types.');

/**
 * (Dictionary) {
 * @summary Locate the dictionary type.
 */
export const dictionariesLocateTypeParams = zod.object({
	repo: zod.string().describe('`types.repo`'),
});

export const dictionariesLocateTypeResponseFieldsItemKindDefault = 'none';

export const dictionariesLocateTypeResponse = zod
	.object({
		about: zod.string().optional().describe('Optional. Short description.'),
		administered: zod.boolean().optional(),
		createdAt: zod.string().optional(),
		createdBy: zod
			.object({
				id: zod.string().optional().describe('Required. Unique Identifier.'),
				name: zod.string().optional().describe('Readonly. Display name.'),
				type: zod.string().optional().describe('Optional. Reference type.'),
			})
			.optional(),
		display: zod
			.string()
			.optional()
			.describe(
				'Required. Display [fields.id] key.\nUsed as [lookup].name setting for this [struct] type.',
			),
		extendable: zod
			.boolean()
			.optional()
			.describe('// Extension fields type.\n Extension extension = 23;'),
		fields: zod
			.array(
				zod
					.object({
						always: zod
							.any()
							.optional()
							.describe(
								'Always signifies that the field value will be computed on any write (INSERT OR UPDATE) operations.\nThe field cannot be written to, and when read the result of the last generated expression will be returned.\n\nThe generation expression can refer to other columns in the table, but not other generated columns. Any functions and operators used must be immutable. References to other tables are not allowed.',
							),
						binary: zod
							.object({
								maxBytes: zod.number().optional(),
								violation: zod.record(zod.string(), zod.string()).optional(),
							})
							.optional(),
						bool: zod.object({}).optional(),
						datetime: zod
							.object({
								epoch: zod
									.number()
									.optional()
									.describe(
										'Epoch timestamp.\nIf zero - UNIX epoch (1970-01-01 00:00:00) will be used.',
									),
								format: zod.string().optional(),
								zone: zod
									.string()
									.optional()
									.describe('Timezone associated.\nDefault: `UTC`.'),
							})
							.optional()
							.describe(
								'Datetime type settings.\n\nenum Part {\n   full = 0; // date & time\n   date = 1; // date only ; YYYY-MM-DD\n   time = 2; // time only ; HH:mm:ss[.pres]\n }\n Part part = 1; // part of: [ date &| time ]\n enum Stamp {\n   s  =  0; // seconds\n   ms =  1; // [milli]seconds ; E+3\n   mc =  2; // [micro]seconds ; E+6\n   ns =  3; // [nano]seconds  ; E+9\n   m  = -1; // minutes\n   h  = -2; // hours\n }\n Stamp time = 2; // time precision\n string zone = 3; // ??? [ Europe/Kyiv | +03:00 ]',
							),
						default: zod
							.any()
							.optional()
							.describe(
								'The `default` expression will be used in `INSERT` operation\nthat does not specify a value for the field.\n\nIf there is no default for a field, then the default is null.',
							),
						disabled: zod.boolean().optional(),
						duration: zod
							.object({
								format: zod.string().optional(),
								max: zod.string().optional(),
								min: zod.string().optional(),
								violation: zod.record(zod.string(), zod.string()).optional(),
							})
							.optional(),
						float: zod
							.object({
								frac: zod.number().optional(),
								max: zod.number().optional(),
								min: zod.number().optional(),
								violation: zod.record(zod.string(), zod.string()).optional(),
							})
							.optional(),
						float32: zod
							.object({
								frac: zod.number().optional(),
								max: zod.number().optional(),
								min: zod.number().optional(),
								violation: zod.record(zod.string(), zod.string()).optional(),
							})
							.optional(),
						float64: zod
							.object({
								frac: zod.number().optional(),
								max: zod.number().optional(),
								min: zod.number().optional(),
								violation: zod.record(zod.string(), zod.string()).optional(),
							})
							.optional(),
						hidden: zod.boolean().optional(),
						hint: zod
							.string()
							.optional()
							.describe('Short description. Default: {name}.'),
						id: zod.string().optional().describe('Field [code] name.\n\ncode'),
						int: zod
							.object({
								max: zod.string().optional(),
								min: zod.string().optional(),
								violation: zod.record(zod.string(), zod.string()).optional(),
							})
							.optional(),
						int32: zod
							.object({
								max: zod.string().optional(),
								min: zod.string().optional(),
								violation: zod.record(zod.string(), zod.string()).optional(),
							})
							.optional(),
						int64: zod
							.object({
								max: zod.string().optional(),
								min: zod.string().optional(),
								violation: zod.record(zod.string(), zod.string()).optional(),
							})
							.optional(),
						kind: zod
							.enum([
								'none',
								'list',
								'bool',
								'int',
								'int32',
								'int64',
								'uint',
								'uint32',
								'uint64',
								'float',
								'float32',
								'float64',
								'binary',
								'lookup',
								'string',
								'richtext',
								'datetime',
								'duration',
							])
							.default(dictionariesLocateTypeResponseFieldsItemKindDefault)
							.describe(
								'Kind of primitive data types.\n\n - none: option allow_alias = true;\n - list: [array]\n - int: int32\n - uint: uint32\n - float: float32\n - datetime: date &| time',
							),
						lookup: zod
							.object({
								display: zod
									.string()
									.optional()
									.describe(
										'[Readonly]. Display dataset field.\n(lookup).{`name`} value relation.',
									),
								name: zod
									.string()
									.optional()
									.describe('[Readonly]. Dataset title.'),
								path: zod
									.string()
									.optional()
									.describe(
										'[Required]. Reference dataset relative path\ne.g.: "contacts", "dictionaries/cities".\n(lookup).{`type`} value relation.',
									),
								primary: zod
									.string()
									.optional()
									.describe(
										'[Readonly]. Primary dataset field.\n(lookup).{`id`} value relation.',
									),
								query: zod.record(zod.string(), zod.string()).optional(),
								violation: zod.record(zod.string(), zod.string()).optional(),
							})
							.optional()
							.describe(
								'Lookup ( REFERENCE ) type descriptor.\nSimplified [webitel.custom.Struct] options.',
							),
						name: zod
							.string()
							.optional()
							.describe('Title of the field. Lang specific.\n\ntitle'),
						readonly: zod
							.boolean()
							.optional()
							.describe(
								'Optional. Disable any write (INSERT OR UPDATE) operations.\nREADONLY signifies that the field value will be always computed on any write (INSERT OR UPDATE) operations.\nIf selected, the `default` value MUST be specified.\n\nFIXME: Is base field ? [ id, created_, updated_ ]',
							),
						required: zod.boolean().optional(),
						richtext: zod
							.object({
								maxBytes: zod.number().optional(),
								maxChars: zod.number().optional(),
								multiline: zod.boolean().optional(),
								violation: zod.record(zod.string(), zod.string()).optional(),
							})
							.optional(),
						string: zod
							.object({
								maxBytes: zod.number().optional(),
								maxChars: zod.number().optional(),
								multiline: zod.boolean().optional(),
								violation: zod.record(zod.string(), zod.string()).optional(),
							})
							.optional(),
						uint: zod
							.object({
								max: zod.string().optional(),
								min: zod.string().optional(),
								violation: zod.record(zod.string(), zod.string()).optional(),
							})
							.optional(),
						uint32: zod
							.object({
								max: zod.string().optional(),
								min: zod.string().optional(),
								violation: zod.record(zod.string(), zod.string()).optional(),
							})
							.optional(),
						uint64: zod
							.object({
								max: zod.string().optional(),
								min: zod.string().optional(),
								violation: zod.record(zod.string(), zod.string()).optional(),
							})
							.optional(),
					})
					.describe('Field of the struct.'),
			)
			.optional()
			.describe('Fields of the struct type.'),
		id: zod
			.string()
			.optional()
			.describe(
				'Deprecated. Use `repo` instead. The [type] name (singular form), e.g.: `country`.',
			),
		indexes: zod
			.record(
				zod.string(),
				zod
					.object({
						fields: zod
							.array(zod.string())
							.optional()
							.describe(
								'A set of [struct.fields.id] to INDEX within [type] dataset.',
							),
						include: zod
							.array(zod.string())
							.optional()
							.describe(
								'A set of [struct.fields.id] to INCLUDE beside the [fields] index.',
							),
						unique: zod
							.boolean()
							.optional()
							.describe(
								'Indicates whether set of [fields] MUST be UNIQUE within [type].',
							),
					})
					.describe('INDEX [struct.fields].'),
			)
			.optional()
			.describe('INDEX fields.\n\nExtension extension = 15;'),
		name: zod
			.string()
			.optional()
			.describe('A User-friendly [id] name ; lang: specific.'),
		objclass: zod
			.string()
			.optional()
			.describe('Readonly. RbAC objclass identity.'),
		path: zod
			.string()
			.optional()
			.describe(
				'Readonly. Relative path to access the dataset APIs, e.g.: `dictionaries/countries`.',
			),
		primary: zod
			.string()
			.optional()
			.describe(
				'Required. Primary [fields.id] key.\nUsed as [lookup].id setting for this [struct] type.',
			),
		readonly: zod.boolean().optional(),
		repo: zod
			.string()
			.optional()
			.describe('Repository (dataset) name (plural form), e.g.: `countries`.'),
		updatedAt: zod.string().optional(),
		updatedBy: zod
			.object({
				id: zod.string().optional().describe('Required. Unique Identifier.'),
				name: zod.string().optional().describe('Readonly. Display name.'),
				type: zod.string().optional().describe('Optional. Reference type.'),
			})
			.optional(),
	})
	.describe('Type of the Structure.\n\nint64 dc = 0;');

/**
 * (Dictionary) {
 * @summary Create custom dictionary.
 */
export const dictionariesCreateTypeParams = zod.object({
	repo: zod
		.string()
		.describe('NEW [`types.repo`] repository name, e.g.: `countries`.'),
});

export const dictionariesCreateTypeBodyFieldsItemKindDefault = 'none';

export const dictionariesCreateTypeBody = zod.object({
	about: zod.string().optional(),
	administered: zod.boolean().optional(),
	display: zod
		.string()
		.optional()
		.describe(
			'Required. Display [fields.id] key.\nUsed as [lookup].name setting for this [struct] type.',
		),
	fields: zod
		.array(
			zod
				.object({
					always: zod
						.any()
						.optional()
						.describe(
							'Always signifies that the field value will be computed on any write (INSERT OR UPDATE) operations.\nThe field cannot be written to, and when read the result of the last generated expression will be returned.\n\nThe generation expression can refer to other columns in the table, but not other generated columns. Any functions and operators used must be immutable. References to other tables are not allowed.',
						),
					binary: zod
						.object({
							maxBytes: zod.number().optional(),
							violation: zod.record(zod.string(), zod.string()).optional(),
						})
						.optional(),
					bool: zod.object({}).optional(),
					datetime: zod
						.object({
							epoch: zod
								.number()
								.optional()
								.describe(
									'Epoch timestamp.\nIf zero - UNIX epoch (1970-01-01 00:00:00) will be used.',
								),
							format: zod.string().optional(),
							zone: zod
								.string()
								.optional()
								.describe('Timezone associated.\nDefault: `UTC`.'),
						})
						.optional()
						.describe(
							'Datetime type settings.\n\nenum Part {\n   full = 0; // date & time\n   date = 1; // date only ; YYYY-MM-DD\n   time = 2; // time only ; HH:mm:ss[.pres]\n }\n Part part = 1; // part of: [ date &| time ]\n enum Stamp {\n   s  =  0; // seconds\n   ms =  1; // [milli]seconds ; E+3\n   mc =  2; // [micro]seconds ; E+6\n   ns =  3; // [nano]seconds  ; E+9\n   m  = -1; // minutes\n   h  = -2; // hours\n }\n Stamp time = 2; // time precision\n string zone = 3; // ??? [ Europe/Kyiv | +03:00 ]',
						),
					default: zod
						.any()
						.optional()
						.describe(
							'The `default` expression will be used in `INSERT` operation\nthat does not specify a value for the field.\n\nIf there is no default for a field, then the default is null.',
						),
					disabled: zod.boolean().optional(),
					duration: zod
						.object({
							format: zod.string().optional(),
							max: zod.string().optional(),
							min: zod.string().optional(),
							violation: zod.record(zod.string(), zod.string()).optional(),
						})
						.optional(),
					float: zod
						.object({
							frac: zod.number().optional(),
							max: zod.number().optional(),
							min: zod.number().optional(),
							violation: zod.record(zod.string(), zod.string()).optional(),
						})
						.optional(),
					float32: zod
						.object({
							frac: zod.number().optional(),
							max: zod.number().optional(),
							min: zod.number().optional(),
							violation: zod.record(zod.string(), zod.string()).optional(),
						})
						.optional(),
					float64: zod
						.object({
							frac: zod.number().optional(),
							max: zod.number().optional(),
							min: zod.number().optional(),
							violation: zod.record(zod.string(), zod.string()).optional(),
						})
						.optional(),
					hidden: zod.boolean().optional(),
					hint: zod
						.string()
						.optional()
						.describe('Short description. Default: {name}.'),
					id: zod.string().optional().describe('Field [code] name.\n\ncode'),
					int: zod
						.object({
							max: zod.string().optional(),
							min: zod.string().optional(),
							violation: zod.record(zod.string(), zod.string()).optional(),
						})
						.optional(),
					int32: zod
						.object({
							max: zod.string().optional(),
							min: zod.string().optional(),
							violation: zod.record(zod.string(), zod.string()).optional(),
						})
						.optional(),
					int64: zod
						.object({
							max: zod.string().optional(),
							min: zod.string().optional(),
							violation: zod.record(zod.string(), zod.string()).optional(),
						})
						.optional(),
					kind: zod
						.enum([
							'none',
							'list',
							'bool',
							'int',
							'int32',
							'int64',
							'uint',
							'uint32',
							'uint64',
							'float',
							'float32',
							'float64',
							'binary',
							'lookup',
							'string',
							'richtext',
							'datetime',
							'duration',
						])
						.default(dictionariesCreateTypeBodyFieldsItemKindDefault)
						.describe(
							'Kind of primitive data types.\n\n - none: option allow_alias = true;\n - list: [array]\n - int: int32\n - uint: uint32\n - float: float32\n - datetime: date &| time',
						),
					lookup: zod
						.object({
							display: zod
								.string()
								.optional()
								.describe(
									'[Readonly]. Display dataset field.\n(lookup).{`name`} value relation.',
								),
							name: zod
								.string()
								.optional()
								.describe('[Readonly]. Dataset title.'),
							path: zod
								.string()
								.optional()
								.describe(
									'[Required]. Reference dataset relative path\ne.g.: "contacts", "dictionaries/cities".\n(lookup).{`type`} value relation.',
								),
							primary: zod
								.string()
								.optional()
								.describe(
									'[Readonly]. Primary dataset field.\n(lookup).{`id`} value relation.',
								),
							query: zod.record(zod.string(), zod.string()).optional(),
							violation: zod.record(zod.string(), zod.string()).optional(),
						})
						.optional()
						.describe(
							'Lookup ( REFERENCE ) type descriptor.\nSimplified [webitel.custom.Struct] options.',
						),
					name: zod
						.string()
						.optional()
						.describe('Title of the field. Lang specific.\n\ntitle'),
					readonly: zod
						.boolean()
						.optional()
						.describe(
							'Optional. Disable any write (INSERT OR UPDATE) operations.\nREADONLY signifies that the field value will be always computed on any write (INSERT OR UPDATE) operations.\nIf selected, the `default` value MUST be specified.\n\nFIXME: Is base field ? [ id, created_, updated_ ]',
						),
					required: zod.boolean().optional(),
					richtext: zod
						.object({
							maxBytes: zod.number().optional(),
							maxChars: zod.number().optional(),
							multiline: zod.boolean().optional(),
							violation: zod.record(zod.string(), zod.string()).optional(),
						})
						.optional(),
					string: zod
						.object({
							maxBytes: zod.number().optional(),
							maxChars: zod.number().optional(),
							multiline: zod.boolean().optional(),
							violation: zod.record(zod.string(), zod.string()).optional(),
						})
						.optional(),
					uint: zod
						.object({
							max: zod.string().optional(),
							min: zod.string().optional(),
							violation: zod.record(zod.string(), zod.string()).optional(),
						})
						.optional(),
					uint32: zod
						.object({
							max: zod.string().optional(),
							min: zod.string().optional(),
							violation: zod.record(zod.string(), zod.string()).optional(),
						})
						.optional(),
					uint64: zod
						.object({
							max: zod.string().optional(),
							min: zod.string().optional(),
							violation: zod.record(zod.string(), zod.string()).optional(),
						})
						.optional(),
				})
				.describe('Field of the struct.'),
		)
		.optional(),
	indexes: zod
		.record(
			zod.string(),
			zod
				.object({
					fields: zod
						.array(zod.string())
						.optional()
						.describe(
							'A set of [struct.fields.id] to INDEX within [type] dataset.',
						),
					include: zod
						.array(zod.string())
						.optional()
						.describe(
							'A set of [struct.fields.id] to INCLUDE beside the [fields] index.',
						),
					unique: zod
						.boolean()
						.optional()
						.describe(
							'Indicates whether set of [fields] MUST be UNIQUE within [type].',
						),
				})
				.describe('INDEX [struct.fields].'),
		)
		.optional()
		.describe('INDEX fields.'),
	name: zod
		.string()
		.optional()
		.describe('A User-friendly [type.id] name ; lang: specific.'),
	primary: zod
		.string()
		.optional()
		.describe(
			'Required. Primary [fields.id] key.\nUsed as [lookup].id setting for this [struct] type.',
		),
	repo: zod
		.string()
		.optional()
		.describe(
			'string id = 1; // The [type] name (singular form), e.g.: `country`.\n\nRepository (dataset) name (plural form), e.g.: `countries`.',
		),
});

export const dictionariesCreateTypeResponseFieldsItemKindDefault = 'none';

export const dictionariesCreateTypeResponse = zod
	.object({
		about: zod.string().optional().describe('Optional. Short description.'),
		administered: zod.boolean().optional(),
		createdAt: zod.string().optional(),
		createdBy: zod
			.object({
				id: zod.string().optional().describe('Required. Unique Identifier.'),
				name: zod.string().optional().describe('Readonly. Display name.'),
				type: zod.string().optional().describe('Optional. Reference type.'),
			})
			.optional(),
		display: zod
			.string()
			.optional()
			.describe(
				'Required. Display [fields.id] key.\nUsed as [lookup].name setting for this [struct] type.',
			),
		extendable: zod
			.boolean()
			.optional()
			.describe('// Extension fields type.\n Extension extension = 23;'),
		fields: zod
			.array(
				zod
					.object({
						always: zod
							.any()
							.optional()
							.describe(
								'Always signifies that the field value will be computed on any write (INSERT OR UPDATE) operations.\nThe field cannot be written to, and when read the result of the last generated expression will be returned.\n\nThe generation expression can refer to other columns in the table, but not other generated columns. Any functions and operators used must be immutable. References to other tables are not allowed.',
							),
						binary: zod
							.object({
								maxBytes: zod.number().optional(),
								violation: zod.record(zod.string(), zod.string()).optional(),
							})
							.optional(),
						bool: zod.object({}).optional(),
						datetime: zod
							.object({
								epoch: zod
									.number()
									.optional()
									.describe(
										'Epoch timestamp.\nIf zero - UNIX epoch (1970-01-01 00:00:00) will be used.',
									),
								format: zod.string().optional(),
								zone: zod
									.string()
									.optional()
									.describe('Timezone associated.\nDefault: `UTC`.'),
							})
							.optional()
							.describe(
								'Datetime type settings.\n\nenum Part {\n   full = 0; // date & time\n   date = 1; // date only ; YYYY-MM-DD\n   time = 2; // time only ; HH:mm:ss[.pres]\n }\n Part part = 1; // part of: [ date &| time ]\n enum Stamp {\n   s  =  0; // seconds\n   ms =  1; // [milli]seconds ; E+3\n   mc =  2; // [micro]seconds ; E+6\n   ns =  3; // [nano]seconds  ; E+9\n   m  = -1; // minutes\n   h  = -2; // hours\n }\n Stamp time = 2; // time precision\n string zone = 3; // ??? [ Europe/Kyiv | +03:00 ]',
							),
						default: zod
							.any()
							.optional()
							.describe(
								'The `default` expression will be used in `INSERT` operation\nthat does not specify a value for the field.\n\nIf there is no default for a field, then the default is null.',
							),
						disabled: zod.boolean().optional(),
						duration: zod
							.object({
								format: zod.string().optional(),
								max: zod.string().optional(),
								min: zod.string().optional(),
								violation: zod.record(zod.string(), zod.string()).optional(),
							})
							.optional(),
						float: zod
							.object({
								frac: zod.number().optional(),
								max: zod.number().optional(),
								min: zod.number().optional(),
								violation: zod.record(zod.string(), zod.string()).optional(),
							})
							.optional(),
						float32: zod
							.object({
								frac: zod.number().optional(),
								max: zod.number().optional(),
								min: zod.number().optional(),
								violation: zod.record(zod.string(), zod.string()).optional(),
							})
							.optional(),
						float64: zod
							.object({
								frac: zod.number().optional(),
								max: zod.number().optional(),
								min: zod.number().optional(),
								violation: zod.record(zod.string(), zod.string()).optional(),
							})
							.optional(),
						hidden: zod.boolean().optional(),
						hint: zod
							.string()
							.optional()
							.describe('Short description. Default: {name}.'),
						id: zod.string().optional().describe('Field [code] name.\n\ncode'),
						int: zod
							.object({
								max: zod.string().optional(),
								min: zod.string().optional(),
								violation: zod.record(zod.string(), zod.string()).optional(),
							})
							.optional(),
						int32: zod
							.object({
								max: zod.string().optional(),
								min: zod.string().optional(),
								violation: zod.record(zod.string(), zod.string()).optional(),
							})
							.optional(),
						int64: zod
							.object({
								max: zod.string().optional(),
								min: zod.string().optional(),
								violation: zod.record(zod.string(), zod.string()).optional(),
							})
							.optional(),
						kind: zod
							.enum([
								'none',
								'list',
								'bool',
								'int',
								'int32',
								'int64',
								'uint',
								'uint32',
								'uint64',
								'float',
								'float32',
								'float64',
								'binary',
								'lookup',
								'string',
								'richtext',
								'datetime',
								'duration',
							])
							.default(dictionariesCreateTypeResponseFieldsItemKindDefault)
							.describe(
								'Kind of primitive data types.\n\n - none: option allow_alias = true;\n - list: [array]\n - int: int32\n - uint: uint32\n - float: float32\n - datetime: date &| time',
							),
						lookup: zod
							.object({
								display: zod
									.string()
									.optional()
									.describe(
										'[Readonly]. Display dataset field.\n(lookup).{`name`} value relation.',
									),
								name: zod
									.string()
									.optional()
									.describe('[Readonly]. Dataset title.'),
								path: zod
									.string()
									.optional()
									.describe(
										'[Required]. Reference dataset relative path\ne.g.: "contacts", "dictionaries/cities".\n(lookup).{`type`} value relation.',
									),
								primary: zod
									.string()
									.optional()
									.describe(
										'[Readonly]. Primary dataset field.\n(lookup).{`id`} value relation.',
									),
								query: zod.record(zod.string(), zod.string()).optional(),
								violation: zod.record(zod.string(), zod.string()).optional(),
							})
							.optional()
							.describe(
								'Lookup ( REFERENCE ) type descriptor.\nSimplified [webitel.custom.Struct] options.',
							),
						name: zod
							.string()
							.optional()
							.describe('Title of the field. Lang specific.\n\ntitle'),
						readonly: zod
							.boolean()
							.optional()
							.describe(
								'Optional. Disable any write (INSERT OR UPDATE) operations.\nREADONLY signifies that the field value will be always computed on any write (INSERT OR UPDATE) operations.\nIf selected, the `default` value MUST be specified.\n\nFIXME: Is base field ? [ id, created_, updated_ ]',
							),
						required: zod.boolean().optional(),
						richtext: zod
							.object({
								maxBytes: zod.number().optional(),
								maxChars: zod.number().optional(),
								multiline: zod.boolean().optional(),
								violation: zod.record(zod.string(), zod.string()).optional(),
							})
							.optional(),
						string: zod
							.object({
								maxBytes: zod.number().optional(),
								maxChars: zod.number().optional(),
								multiline: zod.boolean().optional(),
								violation: zod.record(zod.string(), zod.string()).optional(),
							})
							.optional(),
						uint: zod
							.object({
								max: zod.string().optional(),
								min: zod.string().optional(),
								violation: zod.record(zod.string(), zod.string()).optional(),
							})
							.optional(),
						uint32: zod
							.object({
								max: zod.string().optional(),
								min: zod.string().optional(),
								violation: zod.record(zod.string(), zod.string()).optional(),
							})
							.optional(),
						uint64: zod
							.object({
								max: zod.string().optional(),
								min: zod.string().optional(),
								violation: zod.record(zod.string(), zod.string()).optional(),
							})
							.optional(),
					})
					.describe('Field of the struct.'),
			)
			.optional()
			.describe('Fields of the struct type.'),
		id: zod
			.string()
			.optional()
			.describe(
				'Deprecated. Use `repo` instead. The [type] name (singular form), e.g.: `country`.',
			),
		indexes: zod
			.record(
				zod.string(),
				zod
					.object({
						fields: zod
							.array(zod.string())
							.optional()
							.describe(
								'A set of [struct.fields.id] to INDEX within [type] dataset.',
							),
						include: zod
							.array(zod.string())
							.optional()
							.describe(
								'A set of [struct.fields.id] to INCLUDE beside the [fields] index.',
							),
						unique: zod
							.boolean()
							.optional()
							.describe(
								'Indicates whether set of [fields] MUST be UNIQUE within [type].',
							),
					})
					.describe('INDEX [struct.fields].'),
			)
			.optional()
			.describe('INDEX fields.\n\nExtension extension = 15;'),
		name: zod
			.string()
			.optional()
			.describe('A User-friendly [id] name ; lang: specific.'),
		objclass: zod
			.string()
			.optional()
			.describe('Readonly. RbAC objclass identity.'),
		path: zod
			.string()
			.optional()
			.describe(
				'Readonly. Relative path to access the dataset APIs, e.g.: `dictionaries/countries`.',
			),
		primary: zod
			.string()
			.optional()
			.describe(
				'Required. Primary [fields.id] key.\nUsed as [lookup].id setting for this [struct] type.',
			),
		readonly: zod.boolean().optional(),
		repo: zod
			.string()
			.optional()
			.describe('Repository (dataset) name (plural form), e.g.: `countries`.'),
		updatedAt: zod.string().optional(),
		updatedBy: zod
			.object({
				id: zod.string().optional().describe('Required. Unique Identifier.'),
				name: zod.string().optional().describe('Readonly. Display name.'),
				type: zod.string().optional().describe('Optional. Reference type.'),
			})
			.optional(),
	})
	.describe('Type of the Structure.\n\nint64 dc = 0;');

/**
 * (Dictionary) {
 * @summary Update custom dictionary.
 */
export const dictionariesUpdateTypeParams = zod.object({
	repo: zod
		.string()
		.describe('[**repo**] name of the dataset type, e.g.: `countries`.'),
});

export const dictionariesUpdateTypeQueryParams = zod.object({
	fields: zod
		.array(zod.string())
		.optional()
		.describe('Fields to return into result.'),
});

export const dictionariesUpdateTypeBodyFieldsItemKindDefault = 'none';

export const dictionariesUpdateTypeBody = zod.object({
	about: zod.string().optional(),
	administered: zod.boolean().optional(),
	display: zod
		.string()
		.optional()
		.describe(
			'Required. Display [fields.id] key.\nUsed as [lookup].name setting for this [struct] type.',
		),
	fields: zod
		.array(
			zod
				.object({
					always: zod
						.any()
						.optional()
						.describe(
							'Always signifies that the field value will be computed on any write (INSERT OR UPDATE) operations.\nThe field cannot be written to, and when read the result of the last generated expression will be returned.\n\nThe generation expression can refer to other columns in the table, but not other generated columns. Any functions and operators used must be immutable. References to other tables are not allowed.',
						),
					binary: zod
						.object({
							maxBytes: zod.number().optional(),
							violation: zod.record(zod.string(), zod.string()).optional(),
						})
						.optional(),
					bool: zod.object({}).optional(),
					datetime: zod
						.object({
							epoch: zod
								.number()
								.optional()
								.describe(
									'Epoch timestamp.\nIf zero - UNIX epoch (1970-01-01 00:00:00) will be used.',
								),
							format: zod.string().optional(),
							zone: zod
								.string()
								.optional()
								.describe('Timezone associated.\nDefault: `UTC`.'),
						})
						.optional()
						.describe(
							'Datetime type settings.\n\nenum Part {\n   full = 0; // date & time\n   date = 1; // date only ; YYYY-MM-DD\n   time = 2; // time only ; HH:mm:ss[.pres]\n }\n Part part = 1; // part of: [ date &| time ]\n enum Stamp {\n   s  =  0; // seconds\n   ms =  1; // [milli]seconds ; E+3\n   mc =  2; // [micro]seconds ; E+6\n   ns =  3; // [nano]seconds  ; E+9\n   m  = -1; // minutes\n   h  = -2; // hours\n }\n Stamp time = 2; // time precision\n string zone = 3; // ??? [ Europe/Kyiv | +03:00 ]',
						),
					default: zod
						.any()
						.optional()
						.describe(
							'The `default` expression will be used in `INSERT` operation\nthat does not specify a value for the field.\n\nIf there is no default for a field, then the default is null.',
						),
					disabled: zod.boolean().optional(),
					duration: zod
						.object({
							format: zod.string().optional(),
							max: zod.string().optional(),
							min: zod.string().optional(),
							violation: zod.record(zod.string(), zod.string()).optional(),
						})
						.optional(),
					float: zod
						.object({
							frac: zod.number().optional(),
							max: zod.number().optional(),
							min: zod.number().optional(),
							violation: zod.record(zod.string(), zod.string()).optional(),
						})
						.optional(),
					float32: zod
						.object({
							frac: zod.number().optional(),
							max: zod.number().optional(),
							min: zod.number().optional(),
							violation: zod.record(zod.string(), zod.string()).optional(),
						})
						.optional(),
					float64: zod
						.object({
							frac: zod.number().optional(),
							max: zod.number().optional(),
							min: zod.number().optional(),
							violation: zod.record(zod.string(), zod.string()).optional(),
						})
						.optional(),
					hidden: zod.boolean().optional(),
					hint: zod
						.string()
						.optional()
						.describe('Short description. Default: {name}.'),
					id: zod.string().optional().describe('Field [code] name.\n\ncode'),
					int: zod
						.object({
							max: zod.string().optional(),
							min: zod.string().optional(),
							violation: zod.record(zod.string(), zod.string()).optional(),
						})
						.optional(),
					int32: zod
						.object({
							max: zod.string().optional(),
							min: zod.string().optional(),
							violation: zod.record(zod.string(), zod.string()).optional(),
						})
						.optional(),
					int64: zod
						.object({
							max: zod.string().optional(),
							min: zod.string().optional(),
							violation: zod.record(zod.string(), zod.string()).optional(),
						})
						.optional(),
					kind: zod
						.enum([
							'none',
							'list',
							'bool',
							'int',
							'int32',
							'int64',
							'uint',
							'uint32',
							'uint64',
							'float',
							'float32',
							'float64',
							'binary',
							'lookup',
							'string',
							'richtext',
							'datetime',
							'duration',
						])
						.default(dictionariesUpdateTypeBodyFieldsItemKindDefault)
						.describe(
							'Kind of primitive data types.\n\n - none: option allow_alias = true;\n - list: [array]\n - int: int32\n - uint: uint32\n - float: float32\n - datetime: date &| time',
						),
					lookup: zod
						.object({
							display: zod
								.string()
								.optional()
								.describe(
									'[Readonly]. Display dataset field.\n(lookup).{`name`} value relation.',
								),
							name: zod
								.string()
								.optional()
								.describe('[Readonly]. Dataset title.'),
							path: zod
								.string()
								.optional()
								.describe(
									'[Required]. Reference dataset relative path\ne.g.: "contacts", "dictionaries/cities".\n(lookup).{`type`} value relation.',
								),
							primary: zod
								.string()
								.optional()
								.describe(
									'[Readonly]. Primary dataset field.\n(lookup).{`id`} value relation.',
								),
							query: zod.record(zod.string(), zod.string()).optional(),
							violation: zod.record(zod.string(), zod.string()).optional(),
						})
						.optional()
						.describe(
							'Lookup ( REFERENCE ) type descriptor.\nSimplified [webitel.custom.Struct] options.',
						),
					name: zod
						.string()
						.optional()
						.describe('Title of the field. Lang specific.\n\ntitle'),
					readonly: zod
						.boolean()
						.optional()
						.describe(
							'Optional. Disable any write (INSERT OR UPDATE) operations.\nREADONLY signifies that the field value will be always computed on any write (INSERT OR UPDATE) operations.\nIf selected, the `default` value MUST be specified.\n\nFIXME: Is base field ? [ id, created_, updated_ ]',
						),
					required: zod.boolean().optional(),
					richtext: zod
						.object({
							maxBytes: zod.number().optional(),
							maxChars: zod.number().optional(),
							multiline: zod.boolean().optional(),
							violation: zod.record(zod.string(), zod.string()).optional(),
						})
						.optional(),
					string: zod
						.object({
							maxBytes: zod.number().optional(),
							maxChars: zod.number().optional(),
							multiline: zod.boolean().optional(),
							violation: zod.record(zod.string(), zod.string()).optional(),
						})
						.optional(),
					uint: zod
						.object({
							max: zod.string().optional(),
							min: zod.string().optional(),
							violation: zod.record(zod.string(), zod.string()).optional(),
						})
						.optional(),
					uint32: zod
						.object({
							max: zod.string().optional(),
							min: zod.string().optional(),
							violation: zod.record(zod.string(), zod.string()).optional(),
						})
						.optional(),
					uint64: zod
						.object({
							max: zod.string().optional(),
							min: zod.string().optional(),
							violation: zod.record(zod.string(), zod.string()).optional(),
						})
						.optional(),
				})
				.describe('Field of the struct.'),
		)
		.optional(),
	indexes: zod
		.record(
			zod.string(),
			zod
				.object({
					fields: zod
						.array(zod.string())
						.optional()
						.describe(
							'A set of [struct.fields.id] to INDEX within [type] dataset.',
						),
					include: zod
						.array(zod.string())
						.optional()
						.describe(
							'A set of [struct.fields.id] to INCLUDE beside the [fields] index.',
						),
					unique: zod
						.boolean()
						.optional()
						.describe(
							'Indicates whether set of [fields] MUST be UNIQUE within [type].',
						),
				})
				.describe('INDEX [struct.fields].'),
		)
		.optional()
		.describe('INDEX fields.'),
	name: zod
		.string()
		.optional()
		.describe('A User-friendly [type.id] name ; lang: specific.'),
	primary: zod
		.string()
		.optional()
		.describe(
			'Required. Primary [fields.id] key.\nUsed as [lookup].id setting for this [struct] type.',
		),
	repo: zod
		.string()
		.optional()
		.describe(
			'string id = 1; // The [type] name (singular form), e.g.: `country`.\n\nRepository (dataset) name (plural form), e.g.: `countries`.',
		),
});

export const dictionariesUpdateTypeResponseFieldsItemKindDefault = 'none';

export const dictionariesUpdateTypeResponse = zod
	.object({
		about: zod.string().optional().describe('Optional. Short description.'),
		administered: zod.boolean().optional(),
		createdAt: zod.string().optional(),
		createdBy: zod
			.object({
				id: zod.string().optional().describe('Required. Unique Identifier.'),
				name: zod.string().optional().describe('Readonly. Display name.'),
				type: zod.string().optional().describe('Optional. Reference type.'),
			})
			.optional(),
		display: zod
			.string()
			.optional()
			.describe(
				'Required. Display [fields.id] key.\nUsed as [lookup].name setting for this [struct] type.',
			),
		extendable: zod
			.boolean()
			.optional()
			.describe('// Extension fields type.\n Extension extension = 23;'),
		fields: zod
			.array(
				zod
					.object({
						always: zod
							.any()
							.optional()
							.describe(
								'Always signifies that the field value will be computed on any write (INSERT OR UPDATE) operations.\nThe field cannot be written to, and when read the result of the last generated expression will be returned.\n\nThe generation expression can refer to other columns in the table, but not other generated columns. Any functions and operators used must be immutable. References to other tables are not allowed.',
							),
						binary: zod
							.object({
								maxBytes: zod.number().optional(),
								violation: zod.record(zod.string(), zod.string()).optional(),
							})
							.optional(),
						bool: zod.object({}).optional(),
						datetime: zod
							.object({
								epoch: zod
									.number()
									.optional()
									.describe(
										'Epoch timestamp.\nIf zero - UNIX epoch (1970-01-01 00:00:00) will be used.',
									),
								format: zod.string().optional(),
								zone: zod
									.string()
									.optional()
									.describe('Timezone associated.\nDefault: `UTC`.'),
							})
							.optional()
							.describe(
								'Datetime type settings.\n\nenum Part {\n   full = 0; // date & time\n   date = 1; // date only ; YYYY-MM-DD\n   time = 2; // time only ; HH:mm:ss[.pres]\n }\n Part part = 1; // part of: [ date &| time ]\n enum Stamp {\n   s  =  0; // seconds\n   ms =  1; // [milli]seconds ; E+3\n   mc =  2; // [micro]seconds ; E+6\n   ns =  3; // [nano]seconds  ; E+9\n   m  = -1; // minutes\n   h  = -2; // hours\n }\n Stamp time = 2; // time precision\n string zone = 3; // ??? [ Europe/Kyiv | +03:00 ]',
							),
						default: zod
							.any()
							.optional()
							.describe(
								'The `default` expression will be used in `INSERT` operation\nthat does not specify a value for the field.\n\nIf there is no default for a field, then the default is null.',
							),
						disabled: zod.boolean().optional(),
						duration: zod
							.object({
								format: zod.string().optional(),
								max: zod.string().optional(),
								min: zod.string().optional(),
								violation: zod.record(zod.string(), zod.string()).optional(),
							})
							.optional(),
						float: zod
							.object({
								frac: zod.number().optional(),
								max: zod.number().optional(),
								min: zod.number().optional(),
								violation: zod.record(zod.string(), zod.string()).optional(),
							})
							.optional(),
						float32: zod
							.object({
								frac: zod.number().optional(),
								max: zod.number().optional(),
								min: zod.number().optional(),
								violation: zod.record(zod.string(), zod.string()).optional(),
							})
							.optional(),
						float64: zod
							.object({
								frac: zod.number().optional(),
								max: zod.number().optional(),
								min: zod.number().optional(),
								violation: zod.record(zod.string(), zod.string()).optional(),
							})
							.optional(),
						hidden: zod.boolean().optional(),
						hint: zod
							.string()
							.optional()
							.describe('Short description. Default: {name}.'),
						id: zod.string().optional().describe('Field [code] name.\n\ncode'),
						int: zod
							.object({
								max: zod.string().optional(),
								min: zod.string().optional(),
								violation: zod.record(zod.string(), zod.string()).optional(),
							})
							.optional(),
						int32: zod
							.object({
								max: zod.string().optional(),
								min: zod.string().optional(),
								violation: zod.record(zod.string(), zod.string()).optional(),
							})
							.optional(),
						int64: zod
							.object({
								max: zod.string().optional(),
								min: zod.string().optional(),
								violation: zod.record(zod.string(), zod.string()).optional(),
							})
							.optional(),
						kind: zod
							.enum([
								'none',
								'list',
								'bool',
								'int',
								'int32',
								'int64',
								'uint',
								'uint32',
								'uint64',
								'float',
								'float32',
								'float64',
								'binary',
								'lookup',
								'string',
								'richtext',
								'datetime',
								'duration',
							])
							.default(dictionariesUpdateTypeResponseFieldsItemKindDefault)
							.describe(
								'Kind of primitive data types.\n\n - none: option allow_alias = true;\n - list: [array]\n - int: int32\n - uint: uint32\n - float: float32\n - datetime: date &| time',
							),
						lookup: zod
							.object({
								display: zod
									.string()
									.optional()
									.describe(
										'[Readonly]. Display dataset field.\n(lookup).{`name`} value relation.',
									),
								name: zod
									.string()
									.optional()
									.describe('[Readonly]. Dataset title.'),
								path: zod
									.string()
									.optional()
									.describe(
										'[Required]. Reference dataset relative path\ne.g.: "contacts", "dictionaries/cities".\n(lookup).{`type`} value relation.',
									),
								primary: zod
									.string()
									.optional()
									.describe(
										'[Readonly]. Primary dataset field.\n(lookup).{`id`} value relation.',
									),
								query: zod.record(zod.string(), zod.string()).optional(),
								violation: zod.record(zod.string(), zod.string()).optional(),
							})
							.optional()
							.describe(
								'Lookup ( REFERENCE ) type descriptor.\nSimplified [webitel.custom.Struct] options.',
							),
						name: zod
							.string()
							.optional()
							.describe('Title of the field. Lang specific.\n\ntitle'),
						readonly: zod
							.boolean()
							.optional()
							.describe(
								'Optional. Disable any write (INSERT OR UPDATE) operations.\nREADONLY signifies that the field value will be always computed on any write (INSERT OR UPDATE) operations.\nIf selected, the `default` value MUST be specified.\n\nFIXME: Is base field ? [ id, created_, updated_ ]',
							),
						required: zod.boolean().optional(),
						richtext: zod
							.object({
								maxBytes: zod.number().optional(),
								maxChars: zod.number().optional(),
								multiline: zod.boolean().optional(),
								violation: zod.record(zod.string(), zod.string()).optional(),
							})
							.optional(),
						string: zod
							.object({
								maxBytes: zod.number().optional(),
								maxChars: zod.number().optional(),
								multiline: zod.boolean().optional(),
								violation: zod.record(zod.string(), zod.string()).optional(),
							})
							.optional(),
						uint: zod
							.object({
								max: zod.string().optional(),
								min: zod.string().optional(),
								violation: zod.record(zod.string(), zod.string()).optional(),
							})
							.optional(),
						uint32: zod
							.object({
								max: zod.string().optional(),
								min: zod.string().optional(),
								violation: zod.record(zod.string(), zod.string()).optional(),
							})
							.optional(),
						uint64: zod
							.object({
								max: zod.string().optional(),
								min: zod.string().optional(),
								violation: zod.record(zod.string(), zod.string()).optional(),
							})
							.optional(),
					})
					.describe('Field of the struct.'),
			)
			.optional()
			.describe('Fields of the struct type.'),
		id: zod
			.string()
			.optional()
			.describe(
				'Deprecated. Use `repo` instead. The [type] name (singular form), e.g.: `country`.',
			),
		indexes: zod
			.record(
				zod.string(),
				zod
					.object({
						fields: zod
							.array(zod.string())
							.optional()
							.describe(
								'A set of [struct.fields.id] to INDEX within [type] dataset.',
							),
						include: zod
							.array(zod.string())
							.optional()
							.describe(
								'A set of [struct.fields.id] to INCLUDE beside the [fields] index.',
							),
						unique: zod
							.boolean()
							.optional()
							.describe(
								'Indicates whether set of [fields] MUST be UNIQUE within [type].',
							),
					})
					.describe('INDEX [struct.fields].'),
			)
			.optional()
			.describe('INDEX fields.\n\nExtension extension = 15;'),
		name: zod
			.string()
			.optional()
			.describe('A User-friendly [id] name ; lang: specific.'),
		objclass: zod
			.string()
			.optional()
			.describe('Readonly. RbAC objclass identity.'),
		path: zod
			.string()
			.optional()
			.describe(
				'Readonly. Relative path to access the dataset APIs, e.g.: `dictionaries/countries`.',
			),
		primary: zod
			.string()
			.optional()
			.describe(
				'Required. Primary [fields.id] key.\nUsed as [lookup].id setting for this [struct] type.',
			),
		readonly: zod.boolean().optional(),
		repo: zod
			.string()
			.optional()
			.describe('Repository (dataset) name (plural form), e.g.: `countries`.'),
		updatedAt: zod.string().optional(),
		updatedBy: zod
			.object({
				id: zod.string().optional().describe('Required. Unique Identifier.'),
				name: zod.string().optional().describe('Readonly. Display name.'),
				type: zod.string().optional().describe('Optional. Reference type.'),
			})
			.optional(),
	})
	.describe('Type of the Structure.\n\nint64 dc = 0;');
